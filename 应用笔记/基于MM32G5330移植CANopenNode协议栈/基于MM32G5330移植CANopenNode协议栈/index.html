<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="http://192.168.105.192:1111/%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>CANopenNode移植 - 灵动微电子生态资料中心</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../../style.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "CANopenNode\u79fb\u690d";
        var mkdocs_page_input_path = "\u5e94\u7528\u7b14\u8bb0\\\u57fa\u4e8eMM32G5330\u79fb\u690dCANopenNode\u534f\u8bae\u6808\\\u57fa\u4e8eMM32G5330\u79fb\u690dCANopenNode\u534f\u8bae\u6808.md";
        var mkdocs_page_url = "/%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../..">
          <img src="../../../img/logo.png" class="logo" alt="Logo"/>
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">关于灵动微电子</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../..">项目简介</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="https://www.mindmotion.com.cn/">公司官网</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">软件开发套件</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/">MM32F系列</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../MM32G%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/">MM32G系列</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../MM32L%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/">MM32L系列</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../MM32A%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/">MM32A系列</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/">MM32SPIN系列</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../MM32W%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/">MM32W系列</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">应用笔记</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../../%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/">芯片勘误表</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">CANopenNode移植</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">引言</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#canopen">CANopen概述</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#canopen_1">CANopen 的诞生和作用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#canopencob-id">CANopen的COB-ID</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#canopen7">CANopen的7种报文类型</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#odobject-dictionary">OD(Object Dictionary，对象字典)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#canopen_2">CANopen主站和从站</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#canopen_3">CANopen网络组建</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#nmt">NMT网络管理</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#canopennode">CANopenNode简介</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#canopennode-vs-can-festival">CANopenNode vs CAN Festival</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#canopennode_1">获取CANopenNode源码</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#canopennode_2">CANopenNode 功能特性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#canopennode-basic-api-list">CANopenNode  Basic  API  List</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#mm32g5330canopennode">基于MM32G5330移植CANopenNode</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#canopennode_3">CANopenNode软件包的源文件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#canopennode_4">CANopenNode的移植方法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#flexcancanopennode">基于FlexCAN外设移植CANopenNode</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">调试与开发</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">环境搭建</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">上电调试</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">总结</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_6">参考文献</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/">LwIP移植</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/">TinyUSB移植</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">汽车电子软件</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../ComingSoon/">例程1</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../ComingSoon/">例程2</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../ComingSoon/">例程3</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">开发工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../ComingSoon/">工具1</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../ComingSoon/">工具2</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">认证资质</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../ComingSoon/">资质1</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../ComingSoon/">资质2</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../ComingSoon/">资质3</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">灵动微电子生态资料中心</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">应用笔记</li>
      <li class="breadcrumb-item active">CANopenNode移植</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="canopennode-mm32g5330">CANopenNode移植----基于MM32G5330</h1>
<hr />
<h2 id="_1">引言</h2>
<p>基本的CAN总线外设驱动程序能够提供基本的操作硬件电路系统的服务，但在具体的应用系统中，更多是基于协议栈开发上层应用，而不是针对某个具体的芯片平台编写定制的应用程序。目前CANopen是工业自动化领域最常用的协议栈标准之一。对应地，有一些实现CANopen协议的开源软件包，例如CANopenNode、CAN Festival等。</p>
<p><img alt="CANopen-intro-basics-guide-dummies-tutorial" src="../image/CANopen-intro-basics-guide-dummies-tutorial.svg" /></p>
<hr />
<h2 id="canopen">CANopen概述</h2>
<h3 id="canopen_1">CANopen 的诞生和作用</h3>
<p>CANopen 协议是在20世纪90年代末，由总部位于德国纽伦堡的<a href="http://www.can-cia.org">CiA(CAN-in-Automation)</a> 组织在CAL(CAN Application Layer)的基础上发展而来。由于CANopen协议的创始人团队也是CAN-bus的创始人团队，此协议充分发挥了CAN-bus所具备的所有优势，特别是 CiA 组织的主席蔡豪格(Holger Zeltwanger)先生对于CANopen协议坚持开放、免费、非盈利的原则。一经推出便在欧洲得到了广泛的认可与应用。虽然CiA组织背后没有强大的财阀支撑，但时至今日已经成为全世界最为流行的CAN应用层协议。</p>
<p>CANopen主要提供了两个服务：第一个是提供了一个基于CAN的通信协议，可以将多个设备连接到一个总线；第二个是提供了一个用于设备管理的标准，可以将多个设备组织成一个系统，以实现远程监控和控制。目前，CANopen作为工业自动化领域最常用的标准之一，被广泛应用于汽车、航空航天、楼宇自动化等行业。 </p>
<p>如图x所示，CNAopen是一个基于CAN总线的上层协议，其中CAN涵盖了OSI模型的前两层：物理层和数据链路层，CANopen涵盖了后五层：网络层（寻址、路由）、传输层（端到端可靠性）、会话层（同步）、表现层（以标准方式编码的数据、数据表现）和应用层。应用层规定了CANopen设备是如何配置、传输和同步。</p>
<p><img alt="OSI_Mode_For_CANopen" src="../image/OSI_Mode_For_CANopen.png" />
<center> 图x </center></p>
<p>CANopen从应用端到CAN总线的结构如下图x所示：  </p>
<ul>
<li>应用层(Application)<ul>
<li>用于实现各种应用对象</li>
</ul>
</li>
<li>对象字典(Object dictionary)<ul>
<li>用于描述CANopen节点设备的参数</li>
</ul>
</li>
<li>通信接口(Communication interface)<ul>
<li>定义了CANopen协议通信规则以及CAN控制器驱动之间对应关系</li>
</ul>
</li>
</ul>
<p><img alt="CANopen-Network-Model-Object-Dictionary-Communication-Application" src="../image/CANopen-Network-Model-Object-Dictionary-Communication-Application.svg" />
<center> 图 x </center></p>
<p>在CANopen网络中，通常需要多个设备进行通信，在CANopen网络中用到了如下三种通信模型：</p>
<p><img alt="3ModeOfCANopen" src="../image/3ModeforCANopen.png" />
<center> 图 x </center></p>
<ul>
<li>主机/从机模型(Master/Salve)<ul>
<li>一个节点(例如控制接口)充当应用程序主机控制器，从机(例如伺服电机)发送/请求数据，一般在诊断或状态管理中使用。</li>
<li>通信样例：NMT主机与NMT从机的通信<ul>
<li>所有节点通信地位平等，运行时允许自行发送报文，但CANopen网络为了稳定可靠可控，都需要设置一个网络管理主机 NMT-Master。</li>
<li>NMT主机一般是CANopen网络中具备监控的PLC或者PC(当然也可以是一般的功能节点)，所以也成为CANopen主站。相对应的其他CANopen节点就是NMT从机(NMT-slaves)。</li>
</ul>
</li>
</ul>
</li>
<li>客户端/服务端模型(Client/Server)<ul>
<li>客户机向服务器发送数据请求，服务器进行响应。例如，当应用程序主机需要来自从机OD的数据时使用。</li>
<li>通信样例：SDO客户端与SDO服务端的通信<ul>
<li>发送节点需要指定接收节点的地址(Node-ID)回应CAN报文来确认已经接收，如果超时没有确认，则发送节点将会重新发送原报文。</li>
</ul>
</li>
</ul>
</li>
<li>生产者/消费者模型(Producer/Consumer)<ul>
<li>生产者节点向网络广播数据，而网络由使用者节点使用。生产者可以根据请求发送此数据，也可以不发送特定请求。</li>
<li>通信样例：心跳生产者与心跳消费者的通信<ul>
<li>单向发送传输，无需接收节点回应CAN报文来确认。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="canopencob-id">CANopen的COB-ID</h3>
<ul>
<li>11位CAN ID在CANopen中被称为COB-ID，这11位COB-ID被分为两部分：前4位是功能码，后7位是(节点ID)，且7位的节点ID限制了CANopen网络上的设备数量为127个节点。</li>
</ul>
<p><img alt="CANopen-COB-ID-Message-Format-CAN-Frame_2" src="../image/CANopen-COB-ID-Message-Format-CAN-Frame_2.png" />
<center> 图 x </center></p>
<h3 id="canopen7">CANopen的7种报文类型</h3>
<ul>
<li>
<p>NMT(Network Management)</p>
<ul>
<li>控制CANopen设备状态，用于网络管理。</li>
</ul>
</li>
<li>
<p>SYNC(Synchronization)</p>
<ul>
<li>SYNC 消息用于同步多个 CANopen 设备的输入感应和驱动——通常由应用程序 Master 触发。</li>
</ul>
</li>
<li>
<p>EMCY(Emergency)</p>
<ul>
<li>在设备发生错误(例如传感器故障)时使用的，发送设备内部错误代码。</li>
</ul>
</li>
<li>
<p>TIME</p>
<ul>
<li>用于分配网络时间，议采用广播方式，无需节点应答，CAN-ID 为 100h，数据长度为 6，数据为当前时刻与1984年1月1日0时的时间差。节点将此时间存储在对象字典1012h的索引中。</li>
</ul>
</li>
<li>
<p>PDO(Process Object)</p>
<ul>
<li>PDO服务用于在设备之间传输实时数据，例如测量数据(如位置数据)或命令数据(如扭矩请求)。</li>
</ul>
</li>
<li>
<p>SDO(Sever D Object)</p>
<ul>
<li>用于访问/更改CANopen设备的对象字典中的值——例如，当应用程序主机需要更改CANopen设备的某些配置时。</li>
</ul>
</li>
<li>Heartbeat<ul>
<li>Heartbeat服务有两个用途: 提供“活动”消息和确认NMT命令。</li>
</ul>
</li>
</ul>
<h3 id="odobject-dictionary">OD(Object Dictionary，对象字典)</h3>
<ul>
<li>
<p>什么是对象字典？</p>
<ul>
<li>对象字典是一个标准的数据结构，描述了CANopen节点的不同的对象参数特性。</li>
<li>每个CANopen节点都包含一个对象字典，使用ESD文件来记录节点参数。</li>
<li>Master节点可通过SDO(且只能通过SDO)来访问和配置Slave节点的对象字典。</li>
</ul>
</li>
<li>
<p>对象字典中每个对象的构成</p>
<ul>
<li>Index (索引)：16位对象的基地址，其范围在0x0000到0xFFFF之间。</li>
<li>Sub Index (子索引)：为了避免数据大量时无索引可分配，所以在某些索引下也定义了一个8位的索引值，其范围是0x00到0xFF 之间。</li>
<li>Object name (对象名称): 如：制造商设备名称。</li>
<li>Object type(目标类型):  变量、数组或记录。</li>
<li>Data type (数据类型): 例如 字符串类型, UNSIGNED32类型UNSIGNED16类型。</li>
<li>Access (访问权限)：rw (read/write), ro (read-only), wo (write-only)。</li>
<li>Default Value(默认值): </li>
<li>Category (类型)：指定此参数是否为强制/可选(M/O)。</li>
</ul>
<p><img alt="" src="../image/CANopen-data-structural.png" />
<center> 图 x </center></p>
</li>
<li>
<p>EDS(The Electronic Data Sheet)</p>
<ul>
<li>在实际使用中，配置或管理复杂的 CANopen 网络将使用软件工具来完成，CiA 306标准定义了一个人类可读的且对机器友好的出厂文件格式即EDS格式文件，作为设备OD的“模板”。EDS文件通常由设备供应商提供，包含所有设备对象(但不包含参数值)的信息。简而言之，EDS是由CANopen设备厂商提供的不带参数的设备OD模板。</li>
</ul>
</li>
<li>
<p>对象字典编辑器</p>
<ul>
<li>对象字典编辑器是用于CANopen对象字典、设备信息等的GUI编辑器，可将 EDS 格式文件导入，通过编辑器编辑赋值后导出成 CANopen对象字典的C源代码文件。导出的在两个源代码文件CO_OD.c和CO_OD.h文件就是我们最终在软件开发时需要的对象字典源文件。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="canopen_2">CANopen主站和从站</h3>
<p>具有网络管理（Network Management：简称NMT）主机功能的设备通常被称为CANopen主站设备，通常也具有服务数据（Service Date Object：简称SDO）客户端功能。反之具有网络管理（NMT）从机功能的设备通常被称为CANopen从站设备，且其必须具备有服务数据服务器功能。这样CANopen主站设备就可以控制从站以及读写CANopen从站设备的对象字典。</p>
<ul>
<li>CANopen从站特性<ul>
<li>CANopen从站在CANopen网络中拥有唯一的节点地址，并且能独立完成特定的功能，例如数据采集、电机控制等等。对实时性要求高的数据，通常通过实时数据过程（Process Data Object：简称PDO）进行传输，因此CANopen从站应当支持一定数量的PDO传输功能。根据CANopen协议DS301 V4.02的定义，每个从站都预定义了4个TPDO（Transmit Process Data Object：简称TPDO）和4个RPDO（Receive Process Data Object），另外从站也应具有节点/寿命保护或心跳报文以及生产紧急报文等功能。每个CANopen从站都应有一个对象字典，描述了从站所具有的应用参数和通信参数。</li>
</ul>
</li>
<li>CANopen主站特性<ul>
<li>CANopen主站在网络所起的作用有别于CANopen从站，通常CANopen主站在网络中负责网络管理、从站参数配置以及从站数据的处理，其并不一定具有特定的功能，但也有自己的对象字典和唯一的节点地址，一般是CANopen网络中具备监控的PLC或者PC(当然也可以是一般的功能节点)。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="canopen_3">CANopen网络组建</h3>
<p>由于CANopen是基于CAN总线的一种应用层协议，因此其网络组建与CAN总线一致，典型的总线型结构，从站和主站都挂接在该总线上即可，在一个CANopen网络中只能有一个主站设备和若干个从站设备同时工作。CANopen网络布线时选用带屏蔽双绞线，提高总线抗干扰能力。表 x 所示为CAN通信比特率与总线长度的关系。</p>
<p>表 x</p>
<table>
<thead>
<tr>
<th><strong>Bit rate</strong></th>
<th>Bus length</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 Mbit/s</td>
<td>25 m</td>
</tr>
<tr>
<td>800 kbit/s</td>
<td>50 m</td>
</tr>
<tr>
<td>500 kbit/s</td>
<td>100 m</td>
</tr>
<tr>
<td>250 kbit/s</td>
<td>250 m</td>
</tr>
<tr>
<td>125 kbit/s</td>
<td>500 m</td>
</tr>
<tr>
<td>50 kbit/s</td>
<td>1.000 m</td>
</tr>
<tr>
<td>20 kbit/s</td>
<td>2.500 m</td>
</tr>
<tr>
<td>10 kbit/s</td>
<td>5.000 m</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>总线长度的估计是基于CANopen CiA 301 规范建议的采样点位置。</li>
<li>总线长度的估计是基于5 ns/m的传播延迟。此外，还需要考虑所用的CAN控制器、CAN收发器和光耦合器的延迟时间。</li>
</ul>
<p>如图x所示为CANopen网络的基本结构，在该网络中有一个CANopen主站，负责管理网络中的所有从站，每个设备都有一个独立的节点地址（NodeID）。从站与从站之间也能建立通信，通常需要事先对各个从站进行配置，使各个从站之间能够建立起独立的PDO通信。</p>
<p><img alt="image-20230224143027633" src="../image/CANopen_BasicNetwork.png" /></p>
<p><center> 图x </center></p>
<p>图x所示为带有网关设备的CANopen网络，与基本的CANopen网络相比，该网络中增加了一个CANopen网关设备，该网关设备可以是CANopen转DeviceNet、Profibus、Modbus或其它的设备。在CANopen网络中，我们也可把该网关设备作为一个从站设备或者是CANopen主站设备。</p>
<p><img alt="image-20230224144100523" src="../image/CANopen_ComplexesNetwork.png" /></p>
<p><center> 图x </center></p>
<hr />
<h3 id="nmt">NMT网络管理</h3>
<p>为实现CANopen网络稳定可靠高效运行，需要对CANopen网络进行网络管理，NMT主机通过下发命令，来控制NMT从机进行有序工作，故每个CANopen协议栈中都具有NMT网络管理的功能。</p>
<ul>
<li>CANopen节点设备运行时存在六种状态：<ul>
<li>初始化<ul>
<li>节点上电后对功能部件包括CAN控制器进行初始化。</li>
</ul>
</li>
<li>应用层复位<ul>
<li>节点中的应用程序复位（开始），比如开关量输出、模拟量输出的初始值。</li>
</ul>
</li>
<li>会话层复位<ul>
<li>节点中的CANopen通讯复位（开始），从这个时刻起，此节点就可以进行CANopen通讯了。</li>
</ul>
</li>
<li>预操作状态<ul>
<li>节点的CANopen通讯处于操作就绪状态，此时此节点不能进行PDO通信，而可以进行SDO进行参数配置和NMT网络管理的操作。</li>
</ul>
</li>
<li>操作状态<ul>
<li>节点收到NMT主机发来的启动命令后，CANopen通讯被激活，PDO通信启动后，按照对象字典里面规定的规则进行传输，同样SDO也可以对节点进行数据传输和参数修改。</li>
</ul>
</li>
<li>停止状态<ul>
<li>节点收到NMT主机发来的停止命令后，节点的PDO通信被停止，但SDO和NMT网络管理依然可以对节点进行操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如下图x所示，上述六种状态中除了初始化状态外，都可以通过NMT主机发送NMT命令让CANopen网络中任意一个节点进行其他5种状态的切换。</p>
<p><img alt="CANopen-status" src="../image/CANopen-status.png" />
<center> 图x </center></p>
<hr />
<h2 id="canopennode">CANopenNode简介</h2>
<p>CANopenNode是一款免费和开源的CANopen协议栈，使用用ANSI C语言以面向对象的方式编写的。它可以在不同的微控制器上运行，作为独立的应用程序或与RTOS一起运行。</p>
<p>变量（通信、设备、自定义）被收集在CANopen对象字典中，并且可以以两种方式修改：C源代码和CANopen网络。</p>
<p>CANopenNode的主页是位于：<a href="https://github.com/CANopenNode/CANopenNode">https://github.com/CANopenNode/CANopenNode</a></p>
<hr />
<h3 id="canopennode-vs-can-festival">CANopenNode vs CAN Festival</h3>
<p>表 x</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>CANopenNode</th>
<th>CANFestival</th>
</tr>
</thead>
<tbody>
<tr>
<td>License</td>
<td>Apache v2.0</td>
<td>LGPLv2</td>
</tr>
<tr>
<td>NMT master / slave</td>
<td>✓ / ✓</td>
<td>✓ / ✓</td>
</tr>
<tr>
<td>SDO client / server</td>
<td>✓ / ✓</td>
<td>✓ / ✓</td>
</tr>
<tr>
<td>PDO</td>
<td>✓ / ✓</td>
<td>✓ / ✓</td>
</tr>
<tr>
<td>紧急报文</td>
<td>✓ / ✓</td>
<td>✓ / ✓</td>
</tr>
<tr>
<td>LLS</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Non-volatile storage support</td>
<td>×</td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>CANFestival和CANopenNode都是用于在嵌入式系统上实现CANopen协议通信的开源软件协议栈。需要注意的是它们使用了不同的开放程度的开源协议。CANFestival使用LGPLv2开源协议。这意味着CANFestival的源代码是免费提供的，任何人都可以使用、修改和分发，只要任何衍生作品使用相同的GPL许可证。如果一个公司在产品中使用CANFestival，他们也必须按照同样的LGPLv2开源协议提供其产品的源代码。CANopenNode使用 Apache v2.0开源协议。这是一个自由度比LGPLv2更为开发的一个开源协议，允许在使用软件方面有更大的灵活性。任何人都可以使用、修改和发布CANopenNode，甚至用于商业目的，而不需要发布其衍生作品的源代码。</p>
<hr />
<h3 id="canopennode_1">获取CANopenNode源码</h3>
<p>选择 CANopenNode v1.3，该版本为CANopenNode官方验证发布版本，获取源码链接如下：<a href="https://github.com/CANopenNode/CANopenNode/releases/tag/v1.3">https://github.com/CANopenNode/CANopenNode/releases/tag/v1.3</a></p>
<hr />
<h3 id="canopennode_2">CANopenNode 功能特性</h3>
<ul>
<li>支持启动、停止、重启设备的NMT从机和简单的NMT主机。</li>
<li>支持基于生产者消费者模型的心跳机制用于错误控制。</li>
<li>支持用于快速交换过程变量的PDO链接和动态映射。</li>
<li>支持SDO加速、分段和块状传输，用于对所有参数的服务访问以及SDO主机。</li>
<li>支持紧急报文。</li>
<li>支持基于生产者消费者模型的同步机制。</li>
<li>支持时间协议(生产者消费者模式)。</li>
<li>支持非易失性存储（掉电保存）。</li>
<li>支持LSS主机和从机, LSS 快速扫描。</li>
</ul>
<p>如CANopenNode官方README文档给出的那样，CANopenNode分为三个线程进行运行，分别为：</p>
<ul>
<li>主线程<ul>
<li>负责处理大部分协议栈相关函数。</li>
</ul>
</li>
<li>定时中断线程<ul>
<li>1ms执行一次，负责处理和时间相关的任务。</li>
</ul>
</li>
<li>CAN接收线程<ul>
<li>当接收到CAN帧时进入到这里并处理。</li>
</ul>
</li>
</ul>
<pre><code>                            -----------------------
                           |     Program start     |
                            -----------------------
                                       |
                            -----------------------
                           |     CANopen init      |
                            -----------------------
                                       |
                            -----------------------
                           |     Start threads     |
                            -----------------------
                                 |     |     |
             --------------------      |      --------------------
            |                          |                          |
 -----------------------    -----------------------    -----------------------
| CAN receive thread    |  | Timer interval thread |  | Mainline thread       |
|                       |  |                       |  |                       |
| - Fast response.      |  | - Realtime thread with|  | - Processing of time  |
| - Detect CAN ID.      |  |   constant interval,  |  |   consuming tasks     |
| - Partially process   |  |   typically 1ms.      |  |   in CANopen objects: |
|   messages and copy   |  | - Network synchronized|  |    - SDO server,      |
|   data to target      |  | - Copy inputs (RPDOs, |  |    - Emergency,       |
|   CANopen objects.    |  |   HW) to Object Dict. |  |    - Network state,   |
|                       |  | - May call application|  |    - Heartbeat.       |
|                       |  |   for some processing.|  | - May cyclically call |
|                       |  | - Copy variables from |  |   application code.   |
|                       |  |   Object Dictionary to|  |                       |
|                       |  |   outputs (TPDOs, HW).|  |                       |
 -----------------------    -----------------------    -----------------------

              -----------------------
             | SDO client (optional) |
             |                       |
             | - Can be called by    |
             |   external application|
             | - Can read or write   |
             |   any variable from   |
             |   Object Dictionary   |
             |   from any node in the|
             |   CANopen network.    |
              -----------------------

              -----------------------
             | LSS client (optional) |
             |                       |
             | - Can be called by    |
             |   external application|
             | - Can do LSS requests |
             | - Can request node    |
             |   enumeration         |
              -----------------------
</code></pre>
<hr />
<h3 id="canopennode-basic-api-list">CANopenNode  Basic  API  List</h3>
<p>initialize CANopen</p>
<ul>
<li>CO_ReturnError_t CO_init(void *CANdriverState, uint8_t nodeId, uint16_t bitRate)<ul>
<li>Initialize CANopen stack. Function must be called in the communication reset section.</li>
</ul>
</li>
</ul>
<p>Start CAN</p>
<ul>
<li>void CO_CANsetNormalMode(CO_CANmodule_t *CANmodule)<ul>
<li>Request CAN normal (opearational) mode</li>
</ul>
</li>
</ul>
<p>CANopen process</p>
<ul>
<li>CO_NMT_reset_cmd_t CO_process(CO_t          <em>co, uint16_t timeDifference_ms, uint16_t </em>timerNext_ms)<ul>
<li>Process CANopen objects. Function must be called cyclically. It processes all "asynchronous" CANopen objects.</li>
</ul>
</li>
</ul>
<p>Process Sync</p>
<ul>
<li>bool_t CO_process_SYNC( CO_t          *co, uint32_t         timeDifference_us)<ul>
<li>Process CANopen SYNC objects. Function must be called cyclically from real time thread with constant interval (1ms typically). It processes SYNC CANopen objects.</li>
</ul>
</li>
</ul>
<p>Read inputs</p>
<ul>
<li>void CO_process_RPDO(CO_t          *co, bool_t          syncWas)<ul>
<li>Process CANopen RPDO objects. Function must be called cyclically from real time thread with constant. interval (1ms typically). It processes receive PDO CANopen objects.</li>
</ul>
</li>
</ul>
<p>Write outputs</p>
<ul>
<li>void CO_process_TPDO(CO_t          *co, bool_t          syncWas, uint32_t         timeDifference_us)<ul>
<li>Process CANopen TPDO objects. Function must be called cyclically from real time thread with constant. interval (1ms typically). It processes transmit PDO CANopen objects.</li>
</ul>
</li>
</ul>
<p>CAN interrupt function</p>
<ul>
<li>void CO_CANinterrupt(CO_CANmodule_t *CANmodule)<ul>
<li>Receives and transmits CAN messages. Function must be called directly from high priority CAN interrupt.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="mm32g5330canopennode">基于MM32G5330移植CANopenNode</h2>
<h3 id="canopennode_3">CANopenNode软件包的源文件</h3>
<pre><code>CANopenNode-1.3:
│  .clang-format
│  .gitignore
│  CANopen.c
│  CANopen.h
│  codingStyle
│  CO_driver.h
│  CO_types.h
│  Doxyfile
│  LICENSE
│  LICENSE.old
│  Makefile
│  README.md
│
├─example
│  │  application.c
│  │  application.h
│  │  CO_OD.c
│  │  CO_OD.h
│  │  IO.eds
│  │  IO.html
│  │  main.c
│  │  _project.html
│  │  _project.xml
│  │
│  └─CO_OD_with_trace
│          CO_OD.c
│          CO_OD.h
│
└─stack
    │  CO_Emergency.c
    │  CO_Emergency.h
    │  CO_HBconsumer.c
    │  CO_HBconsumer.h
    │  CO_LSS.h
    │  CO_LSSmaster.c
    │  CO_LSSmaster.h
    │  CO_LSSslave.c
    │  CO_LSSslave.h
    │  CO_NMT_Heartbeat.c
    │  CO_NMT_Heartbeat.h
    │  CO_PDO.c
    │  CO_PDO.h
    │  CO_SDO.c
    │  CO_SDO.h
    │  CO_SDOmaster.c
    │  CO_SDOmaster.h
    │  CO_SYNC.c
    │  CO_SYNC.h
    │  CO_TIME.c
    │  CO_TIME.h
    │  CO_trace.c
    │  CO_trace.h
    │  crc16-ccitt.c
    │  crc16-ccitt.h
    │
    ├─drvTemplate
    │      CO_driver.c
    │      CO_driver_target.h
    │      eeprom.c
    │      eeprom.h

</code></pre>
<p>注：上述仅包含移植用到的文件。</p>
<hr />
<h3 id="canopennode_4">CANopenNode的移植方法</h3>
<p>CANopenNode移植中涉及到三个文件需要修改：</p>
<ul>
<li>CANopenNode-1.3/example/main.c 文件。</li>
<li>CANopenNode-1.3/stack/drvTemplate/CO_driver.c 文件。</li>
<li>CANopenNode-1.3/stack//drvTemplate/CO_driver_target.h 文件。</li>
</ul>
<p>其中：</p>
<ul>
<li>
<p>在 mian.c 文件中实现 tmrTask_thread() 函数</p>
<ul>
<li>通加载进入1ms 定时中断服务函数进行 1ms 定时的信息同步。</li>
</ul>
</li>
<li>
<p>在 CO_driver.c 文件中实现 CO_CANmodule_init() 函数</p>
<ul>
<li>用于对 MCU 中的 CAN 模块进行初始，并配置CAN报文的收发参数以及开启 flexcan 中断。</li>
</ul>
</li>
<li>
<p>在 CO_driver.C 文件中实现 CO_CANinterrupt() 函数</p>
<ul>
<li>用于实现接收和发送CAN信息。该功能从高优先级的CAN中断中直接调用。</li>
</ul>
</li>
<li>
<p>在 CO_driver.C 文件中实现 CO_CANverifyErrorst() 函数</p>
<ul>
<li>用于对 CAN 总线进行错误检测和上报。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="flexcancanopennode">基于FlexCAN外设移植CANopenNode</h3>
<p>下面我们将以MM32G5330微控制器上集成的FlexCAN为例，实现对CANopenNode v1.3的移植过程。</p>
<p>首先在灵动官网下载基于Mini-G5330开发板的FlexCAN_Interrupt样例工程，并在MM32G5330的根目录文件夹下创建CANopenNode文件夹。将CANopenNode v1.3软件包中包含的下列文件无需修改，原封不动地复制到新建的 CANopenNode 文件夹中。</p>
<pre><code>./CANopen.c&amp;h
./CO_types.h
./stack/CO_Emergency.c&amp;h
./stack/CO_HBconsumer.c&amp;h
./stack/CO_LSS.h
./stack/CO_LSSmaster.c&amp;h
./stack/CO_LSSslave.c&amp;h
./stack/CO_NMT_Heartbeat.c&amp;h
./stack/CO_PDO.c&amp;h
./stack/CO_SDO.c&amp;h
./stack/CO_SDOmaster.c&amp;h
./stack/CO_SYNC.c&amp;h
./stack/CO_TIME.c&amp;h
./stack/CO_trace.c&amp;h
./stack/crc16-ccitt.c&amp;h
</code></pre>
<p>如下图x所示：</p>
<p><img alt="image-20231213182716874" src="../image/components-canopen.png" />
<center>图 x </center></p>
<p>接着将CANopenNode源码中提供的example文件夹的结构如下图x所示，其中CO_OD.c/h是 CANopen中使用到的对象字典， 我们将这两个文件复制到 MM32G5330样例工程的board文件夹下。main.c是 CANopenNode的主程序文件，我们将将原有的main.c文件进行替换。</p>
<p><img alt="image-20230130180116311" src="../image/CANopenNode-example.png" />
<center> 图 x </center></p>
<p>最后将如图x所示的位于CANopenNode-1.3/stack/drvTemplate文件夹下的CO_driver.c及CO_driver_target.h这两个文件复制到样例工程的文件夹下。</p>
<p><img alt="image-20230131094145961" src="../image/CANopenNode-drvTemp.png" />
<center> 图 x </center></p>
<p>由于本次移植是基于裸机移植，故按照CANopenNode的设计将Mainline线程放入while(1)中，CAN接收线程放入flexcan的中断服务程序中，定时线程放在一个1ms的定时中断服务程序中。</p>
<p><strong>在 <code>main.c</code> 文件中配置定时器</strong></p>
<pre><code class="language-c">/* Setup the timer. */
void app_tim_init(void)
{
    NVIC_InitTypeDef        NVIC_InitStruct;
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;

    RCC_ClocksTypeDef RCC_Clocks;

    RCC_GetClocksFreq(&amp;RCC_Clocks);

    RCC_APB2PeriphClockCmd(RCC_APB2ENR_TIM1, ENABLE);

    TIM_TimeBaseStructInit(&amp;TIM_TimeBaseInitStruct);
    TIM_TimeBaseInitStruct.TIM_Prescaler         = (RCC_Clocks.PCLK2_Frequency / APP_TIM_UPDATE_STEP - 1);
    TIM_TimeBaseInitStruct.TIM_CounterMode       = TIM_COUNTERMODE_UP;
    TIM_TimeBaseInitStruct.TIM_Period            = (APP_TIM_UPDATE_PERIOD - 1);
    TIM_TimeBaseInitStruct.TIM_ClockDivision     = TIM_CKD_DIV1;
    TIM_TimeBaseInitStruct.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseInitStruct);

    TIM_ClearFlag(TIM1, TIM_IT_UPDATE);
    TIM_ITConfig(TIM1, TIM_IT_UPDATE, ENABLE);

    NVIC_InitStruct.NVIC_IRQChannel = TIM1_UP_IRQn;
    NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&amp;NVIC_InitStruct);
}

void TIM1_UP_IRQHandler(void)
{
    TIM_ClearITPendingBit(TIM1, TIM_IT_UPDATE);
    tmrTask_thread();
}
</code></pre>
<p><strong>在 <code>main.c</code> 文件中实现定时线程任务处理</strong></p>
<pre><code class="language-c">/* timer thread executes in constant intervals ********************************/
void tmrTask_thread(void){

    INCREMENT_1MS(CO_timer1ms);

    if (CO-&gt;CANmodule[0]-&gt;CANnormal) {
        bool_t syncWas;

        /* Process Sync */
        syncWas = CO_process_SYNC(CO, TMR_TASK_INTERVAL);

        /* Read inputs */
        CO_process_RPDO(CO, syncWas);

        /* Further I/O or nonblocking application code may go here. */

        /* Write outputs */
        CO_process_TPDO(CO, syncWas, TMR_TASK_INTERVAL);

        /* verify timer overflow */
        if((TIM_GetITStatus(TIM1, TIM_IT_UPDATE) &amp; TIM_IT_UPDATE) != 0u) {
            CO_errorReport(CO-&gt;em, CO_EM_ISR_TIMER_OVERFLOW, CO_EMC_SOFTWARE_INTERNAL, 0u);
            TIM_ClearITPendingBit(TIM1, TIM_IT_UPDATE);
        }
    }
}
</code></pre>
<p><strong>在 <code>main.c</code> 文件中实现 FlexCAN 的中断服务函数</strong></p>
<pre><code class="language-c">/* CAN interrupt function *****************************************************/
void FLEXCAN_IRQHandler(void)
{
    FLEXCAN_TransferHandleIRQ(FLEXCAN, &amp;FlexCAN_Handle);
    CO_CANinterrupt(CO-&gt;CANmodule[0]);
    __DSB();
}
</code></pre>
<p><strong>在 <code>CO_driver.c</code> 文件中实现FlexCAN模块初始化</strong></p>
<pre><code class="language-c">void FlexCAN_Configure(uint32_t can_bitrate)
{
    GPIO_InitTypeDef GPIO_InitStruct;
    NVIC_InitTypeDef NVIC_InitStruct;
    RCC_ClocksTypeDef RCC_Clocks;

    flexcan_config_t       FlexCAN_ConfigStruct;
    flexcan_rx_mb_config_t FlexCAN_RxMB_ConfigStruct;

    RCC_GetClocksFreq(&amp;RCC_Clocks);

    RCC_APB1PeriphClockCmd(RCC_APB1PERIPH_FLEXCAN, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBENR_GPIOA, ENABLE);

    GPIO_PinAFConfig(GPIOA, GPIO_PINSOURCE11, GPIO_AF_9);
    GPIO_PinAFConfig(GPIOA, GPIO_PINSOURCE12, GPIO_AF_9);

    GPIO_StructInit(&amp;GPIO_InitStruct);
    GPIO_InitStruct.GPIO_Pin   = GPIO_PIN_11;
    GPIO_InitStruct.GPIO_Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.GPIO_Mode  = GPIO_MODE_FLOATING;
    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);

    GPIO_StructInit(&amp;GPIO_InitStruct);
    GPIO_InitStruct.GPIO_Pin   = GPIO_PIN_12;
    GPIO_InitStruct.GPIO_Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);

    NVIC_InitStruct.NVIC_IRQChannel = FLEXCAN_IRQn;
    NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&amp;NVIC_InitStruct);

    FLEXCAN_GetDefaultConfig(&amp;FlexCAN_ConfigStruct);
    FlexCAN_ConfigStruct.baudRate             = can_bitrate*1000;
    FlexCAN_ConfigStruct.clkSrc               = Enum_Flexcan_ClkSrc1;
    FlexCAN_ConfigStruct.enableLoopBack       = false;
    FlexCAN_ConfigStruct.disableSelfReception = true;
    FlexCAN_ConfigStruct.enableIndividMask    = true;

    #if 1    /* Baudrate calculate by automatically */
    FLEXCAN_CalculateImprovedTimingValues(FlexCAN_ConfigStruct.baudRate, RCC_Clocks.PCLK1_Frequency, &amp;FlexCAN_ConfigStruct.timingConfig);
#else  /* You can modify the parameters yourself */
    FlexCAN_ConfigStruct.timingConfig.preDivider = 23;
    FlexCAN_ConfigStruct.timingConfig.propSeg    = 6;
    FlexCAN_ConfigStruct.timingConfig.phaseSeg1  = 3;
    FlexCAN_ConfigStruct.timingConfig.phaseSeg2  = 3;    
    FlexCAN_ConfigStruct.timingConfig.rJumpwidth = 3; 
#endif

    FLEXCAN_Init(FLEXCAN, &amp;FlexCAN_ConfigStruct);

    /* Set Tx MB_2. */
    FLEXCAN_TxMbConfig(FLEXCAN, BOARD_FLEXCAN_TX_MB_CH, ENABLE);
    FLEXCAN_TransferCreateHandle(FLEXCAN, &amp;FlexCAN_Handle, FlexCAN_Transfer_Callback, NULL);

    /* Set Rx MB_0. */
    FlexCAN_RxMB_ConfigStruct.id     = FLEXCAN_ID_STD(0x222);
    FlexCAN_RxMB_ConfigStruct.format = Enum_Flexcan_FrameFormatStandard;
    FlexCAN_RxMB_ConfigStruct.type   = Enum_Flexcan_FrameTypeData;
    FLEXCAN_RxMbConfig(FLEXCAN, BOARD_FLEXCAN_RX_MB_CH, &amp;FlexCAN_RxMB_ConfigStruct, ENABLE);

    /* Set Rx Individual Mask. */
    FLEXCAN_SetRxIndividualMask(FLEXCAN, BOARD_FLEXCAN_RX_MB_CH, FLEXCAN_RX_MB_STD_MASK(0x000, 0, 0));

    FlexCAN_MB0_FrameStruct.length = (uint8_t)(8);
    FlexCAN_MB0_FrameStruct.type   = (uint8_t)Enum_Flexcan_FrameTypeData;
    FlexCAN_MB0_FrameStruct.format = (uint8_t)Enum_Flexcan_FrameFormatStandard;
    FlexCAN_MB0_FrameStruct.id     = FLEXCAN_ID_STD(0x222);

    FlexCAN_MB0_TransferStruct.mbIdx = BOARD_FLEXCAN_RX_MB_CH;
    FlexCAN_MB0_TransferStruct.frame = &amp;FlexCAN_MB0_FrameStruct;
    FLEXCAN_TransferReceiveNonBlocking(FLEXCAN, &amp;FlexCAN_Handle, &amp;FlexCAN_MB0_TransferStruct);
}

/******************************************************************************/
CO_ReturnError_t CO_CANmodule_init(
        CO_CANmodule_t         *CANmodule,
        void                   *CANdriverState,
        CO_CANrx_t              rxArray[],
        uint16_t                rxSize,
        CO_CANtx_t              txArray[],
        uint16_t                txSize,
        uint16_t                CANbitRate)
{
    uint16_t i;

    /* verify arguments */
    if(CANmodule==NULL || rxArray==NULL || txArray==NULL){
        return CO_ERROR_ILLEGAL_ARGUMENT;
    }

    /* Configure object variables */
    CANmodule-&gt;CANdriverState = CANdriverState;
    CANmodule-&gt;rxArray = rxArray;
    CANmodule-&gt;rxSize = rxSize;
    CANmodule-&gt;txArray = txArray;
    CANmodule-&gt;txSize = txSize;
    CANmodule-&gt;CANnormal = false;
    CANmodule-&gt;useCANrxFilters = false;/* microcontroller dependent */
    CANmodule-&gt;bufferInhibitFlag = false;
    CANmodule-&gt;firstCANtxMessage = true;
    CANmodule-&gt;CANtxCount = 0U;
    CANmodule-&gt;errOld = 0U;
    CANmodule-&gt;em = NULL;

    for(i=0U; i&lt;rxSize; i++){
        rxArray[i].ident = 0U;
        rxArray[i].mask = 0xFFFFU;
        rxArray[i].object = NULL;
        rxArray[i].pFunct = NULL;
    }
    for(i=0U; i&lt;txSize; i++){
        txArray[i].bufferFull = false;
    }

    FlexCAN_Configure(CANbitRate);

    return CO_ERROR_NO;
}
</code></pre>
<p>在 <code>CO_driver.c</code> 文件中实现FlexCAN的报文收发</p>
<pre><code class="language-c">/* Send a message frame. */
bool flexcan_tx(CO_CANtx_t *buffer)
{
    bool status = false;

    flexcan_frame_t       FlexCAN_FrameStruct;
    flexcan_mb_transfer_t FlexCAN_MB_TransferStruct;

    if (!buffer-&gt;rtr)
    {
        FlexCAN_FrameStruct.type = (uint8_t)Enum_Flexcan_FrameTypeData; /* Data frame type. */
    }
    else
    {
        FlexCAN_FrameStruct.type = (uint8_t)Enum_Flexcan_FrameTypeRemote; /* Remote frame type. */
    }

    FlexCAN_FrameStruct.length = (uint8_t)buffer-&gt;DLC;
    FlexCAN_FrameStruct.format = (uint8_t)Enum_Flexcan_FrameFormatStandard;
    FlexCAN_FrameStruct.id     = FLEXCAN_ID_STD(buffer-&gt;ident); /* Indicated ID number. */

    FlexCAN_FrameStruct.dataByte0 = buffer-&gt;data[0];
    FlexCAN_FrameStruct.dataByte1 = buffer-&gt;data[1];
    FlexCAN_FrameStruct.dataByte2 = buffer-&gt;data[2];
    FlexCAN_FrameStruct.dataByte3 = buffer-&gt;data[3];
    FlexCAN_FrameStruct.dataByte4 = buffer-&gt;data[4];
    FlexCAN_FrameStruct.dataByte5 = buffer-&gt;data[5];
    FlexCAN_FrameStruct.dataByte6 = buffer-&gt;data[6];
    FlexCAN_FrameStruct.dataByte7 = buffer-&gt;data[7];

    FlexCAN_MB_TransferStruct.mbIdx = 2;
    FlexCAN_MB_TransferStruct.frame = &amp;FlexCAN_FrameStruct;

    if (Status_Flexcan_Success == FLEXCAN_TransferSendNonBlocking(FLEXCAN, &amp;FlexCAN_Handle, &amp;FlexCAN_MB_TransferStruct))
    {
        status = true;
    }

    return status;
}


/******************************************************************************/
CO_ReturnError_t CO_CANsend(CO_CANmodule_t *CANmodule, CO_CANtx_t *buffer){
    CO_ReturnError_t err = CO_ERROR_NO;

    /* Verify overflow */
    if(buffer-&gt;bufferFull){
        if(!CANmodule-&gt;firstCANtxMessage){
            /* don't set error, if bootup message is still on buffers */
            CO_errorReport((CO_EM_t*)CANmodule-&gt;em, CO_EM_CAN_TX_OVERFLOW, CO_EMC_CAN_OVERRUN, buffer-&gt;ident);
        }
        err = CO_ERROR_TX_OVERFLOW;
    }

    CO_LOCK_CAN_SEND();
    bool tx_mb_status = flexcan_tx(buffer);

    if(tx_mb_status == true){
        CANmodule-&gt;bufferInhibitFlag = buffer-&gt;syncFlag;
    }
    /* if no buffer is free, message will be sent by interrupt */
    else{
        buffer-&gt;bufferFull = true;
        CANmodule-&gt;CANtxCount++;
    }
    CO_UNLOCK_CAN_SEND();

    return err;
}
</code></pre>
<pre><code class="language-c">void CO_CANinterrupt(CO_CANmodule_t *CANmodule){

    uint32_t status = FLEXCAN-&gt;IFLAG1;

    if (0 != (status &amp; (BOARD_FLEXCAN_RX_MB_STATUS)) || (FlexCAN_MB0_RxCompleteFlag))
    {
        /* receive interrupt */
        CO_CANrxMsg_t *rcvMsg;      /* pointer to received message in CAN module */
        CO_CANrxMsg_t rcvMsgBuff;

        uint16_t index;             /* index of received message */
        uint32_t rcvMsgIdent;       /* identifier of the received message */
        CO_CANrx_t *buffer = NULL;  /* receive message buffer from CO_CANmodule_t object. */
        bool_t msgMatched = false;

        /* get message from module here */
        rcvMsg = &amp;rcvMsgBuff;

        rcvMsg-&gt;ident   = (FlexCAN_MBTemp_FrameStruct.id&gt;&gt; CAN_ID_STD_SHIFT)&amp;0x7FF;
        rcvMsg-&gt;DLC     = FlexCAN_MBTemp_FrameStruct.length;
        rcvMsg-&gt;data[0] = FlexCAN_MBTemp_FrameStruct.dataByte0;
        rcvMsg-&gt;data[1] = FlexCAN_MBTemp_FrameStruct.dataByte1;
        rcvMsg-&gt;data[2] = FlexCAN_MBTemp_FrameStruct.dataByte2;
        rcvMsg-&gt;data[3] = FlexCAN_MBTemp_FrameStruct.dataByte3;
        rcvMsg-&gt;data[4] = FlexCAN_MBTemp_FrameStruct.dataByte4;
        rcvMsg-&gt;data[5] = FlexCAN_MBTemp_FrameStruct.dataByte5;
        rcvMsg-&gt;data[6] = FlexCAN_MBTemp_FrameStruct.dataByte6;
        rcvMsg-&gt;data[7] = FlexCAN_MBTemp_FrameStruct.dataByte7;

        rcvMsgIdent = rcvMsg-&gt;ident;

        FlexCAN_MB0_RxCompleteFlag = 0;

        /* CAN module filters are not used, message with any standard 11-bit identifier */
        /* has been received. Search rxArray form CANmodule for the same CAN-ID. */
        buffer = &amp;CANmodule-&gt;rxArray[0];
        for(index = CANmodule-&gt;rxSize; index &gt; 0U; index--){
            if(((rcvMsgIdent ^ buffer-&gt;ident) &amp; buffer-&gt;mask) == 0U){
                msgMatched = true;
                break;
            }
            buffer++;
        }

        /* Call specific function, which will process the message */
        if(msgMatched &amp;&amp; (buffer != NULL) &amp;&amp; (buffer-&gt;pFunct != NULL)){
            buffer-&gt;pFunct(buffer-&gt;object, rcvMsg);
        }

        /* Clear interrupt flag */
        FLEXCAN_ClearMbStatusFlags(FLEXCAN, BOARD_FLEXCAN_RX_MB_STATUS);
    }
    else if (0 != (status &amp; BOARD_FLEXCAN_TX_MB_STATUS))
    {
        /* Clear interrupt flag */
        FLEXCAN_ClearMbStatusFlags(FLEXCAN, BOARD_FLEXCAN_TX_MB_STATUS);

        /* First CAN message (bootup) was sent successfully */
        CANmodule-&gt;firstCANtxMessage = false;
        /* clear flag from previous message */
        CANmodule-&gt;bufferInhibitFlag = false;
        /* Are there any new messages waiting to be send */
        if(CANmodule-&gt;CANtxCount &gt; 0U){
            uint16_t i;             /* index of transmitting message */

            /* first buffer */
            CO_CANtx_t *buffer = &amp;CANmodule-&gt;txArray[0];
            /* search through whole array of pointers to transmit message buffers. */
            for(i = CANmodule-&gt;txSize; i &gt; 0U; i--){
                /* if message buffer is full, send it. */
                if(buffer-&gt;bufferFull){
                    buffer-&gt;bufferFull = false;
                    CANmodule-&gt;CANtxCount--;

                    /* Copy message to CAN buffer */
                    CANmodule-&gt;bufferInhibitFlag = buffer-&gt;syncFlag;
                    CO_CANsend(CANmodule, buffer);
                    break;                      /* exit for loop */
                }
                buffer++;
            }/* end of for loop */

            /* Clear counter if no more messages */
            if(i == 0U){
                CANmodule-&gt;CANtxCount = 0U;
            }
        }
    }
    else{
        /* some other interrupt reason */
    }
}
</code></pre>
<p><strong>在 <code>CO_driver.c</code> 文件中实现CAN总线错误检测</strong></p>
<pre><code class="language-c">void CO_CANverifyErrors(CO_CANmodule_t *CANmodule){
    uint16_t rxErrors, txErrors, overflow;
    CO_EM_t* em = (CO_EM_t*)CANmodule-&gt;em;
    uint32_t err;

    /* get error counters from module. Id possible, function may use different way to
     * determine errors. */
    rxErrors = (uint16_t) ((FLEXCAN-&gt;ECR &amp; CAN_ECR_RXERRCNT_MASK) &gt;&gt; CAN_ECR_RXERRCNT_SHIFT);
    txErrors = (uint16_t) ((FLEXCAN-&gt;ECR &amp; CAN_ECR_TXERRCNT_MASK) &gt;&gt; CAN_ECR_TXERRCNT_SHIFT);
    overflow = (uint16_t) ((FLEXCAN-&gt;ESR1 &amp; CAN_ESR1_ERROVR_MASK) &gt;&gt; CAN_ESR1_ERROVR_SHIFT);

    err = ((uint32_t)txErrors &lt;&lt; 16) | ((uint32_t)rxErrors &lt;&lt; 8) | overflow;

    if(CANmodule-&gt;errOld != err){
        CANmodule-&gt;errOld = err;

        if(txErrors &gt;= 256U){                               /* bus off */
            CO_errorReport(em, CO_EM_CAN_TX_BUS_OFF, CO_EMC_BUS_OFF_RECOVERED, err);
        }
        else{                                               /* not bus off */
            CO_errorReset(em, CO_EM_CAN_TX_BUS_OFF, err);

            if((rxErrors &gt;= 96U) || (txErrors &gt;= 96U)){     /* bus warning */
                CO_errorReport(em, CO_EM_CAN_BUS_WARNING, CO_EMC_NO_ERROR, err);
            }

            if(rxErrors &gt;= 128U){                           /* RX bus passive */
                CO_errorReport(em, CO_EM_CAN_RX_BUS_PASSIVE, CO_EMC_CAN_PASSIVE, err);
            }
            else{
                CO_errorReset(em, CO_EM_CAN_RX_BUS_PASSIVE, err);
            }

            if(txErrors &gt;= 128U){                           /* TX bus passive */
                if(!CANmodule-&gt;firstCANtxMessage){
                    CO_errorReport(em, CO_EM_CAN_TX_BUS_PASSIVE, CO_EMC_CAN_PASSIVE, err);
                }
            }
            else{
                bool_t isError = CO_isError(em, CO_EM_CAN_TX_BUS_PASSIVE);
                if(isError){
                    CO_errorReset(em, CO_EM_CAN_TX_BUS_PASSIVE, err);
                    CO_errorReset(em, CO_EM_CAN_TX_OVERFLOW, err);
                }
            }

            if((rxErrors &lt; 96U) &amp;&amp; (txErrors &lt; 96U)){       /* no error */
                CO_errorReset(em, CO_EM_CAN_BUS_WARNING, err);
            }
        }

        if(overflow != 0U){                                 /* CAN RX bus overflow */
            CO_errorReport(em, CO_EM_CAN_RXB_OVERFLOW, CO_EMC_CAN_OVERRUN, err);
        }
    }
}
</code></pre>
<p>将上述文件复制到对应的工程样例文件路径下，并将这些文件添加进工程编译文件列表中后，编译下载程序，CANopen节点上线向CAN网络发送CANopen节点上线报文，上位机收到一条如下报文：</p>
<p>表x:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">CAN-ID(hex)</th>
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Data(hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">70A</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">00</td>
</tr>
</tbody>
</table>
<p>之后该CANopen节点以 1000ms 的时间间隔向CAN网络发送节点心跳报文，上位机以1000ms的时间间隔收到如下报文：</p>
<p>表x:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">CAN-ID(hex)</th>
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Data(hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">70A</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">05</td>
</tr>
</tbody>
</table>
<p>如图x所示。</p>
<p><img alt="image-20230220110237610" src="../image/PCAN-View.png" />
<center>图x </center></p>
<p>至此，可验证该CANopen节点设备成功启动并开始正常运行。</p>
<p>同时在灵动提供的样例中，也提供了一些移植好的CANopenNode样例工程，供大家验证测试：</p>
<ul>
<li>CANopen_Basic样例<ul>
<li>演示了CANopenNode的基本样例功能。</li>
</ul>
</li>
<li>CANopen_PDO_TPDO&amp;CANopen_PDO_RPDO样例<ul>
<li>演示了CANopen的TPDO与RPDO之间通信的样例。</li>
</ul>
</li>
<li>CANopen_SDO_Server&amp;CANopen_SDO_Client样例<ul>
<li>演示了CANopen的SDO Server与SDO Client之间通信的样例。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="_2">调试与开发</h2>
<h3 id="_3">环境搭建</h3>
<p>使用搭载了MM32G5330 MCU的开发板Mini-G5330 ，以CANopen_Basic样例工程为例，将开发板上的CAN收发器与PCAN相连接，并将PCAN与PC机通过USB相连接，在PC端（基于Win10操作系统）使用PCAN-View上位机进行CAN通信，如图x所示。 </p>
<p><img alt="image-20221229200614147" src="../image/image-mcu%26pc.png" />
<center>图x MCU与PC机交互示意图 </center></p>
<p>这里我们使用了PCAN-USB，并使用了其官方的配套上位机PCAN-View。其PCAN-USB驱动下载链接为：<a href="https://peak-system.com.cn/driver/">https://peak-system.com.cn/driver/</a>；PCAN-View 安装包下载链接为: <a href="https://peak-system.com.cn/wp-content/uploads/2022/06/pcanview.zip">https://peak-system.com.cn/wp-content/uploads/2022/06/pcanview.zip</a>；PCAN-View使用说明见如下链接: <a href="https://peak-system.com.cn/software/apsoftware/pcan-view/">https://peak-system.com.cn/software/apsoftware/pcan-view/</a></p>
<hr />
<h3 id="_4">上电调试</h3>
<p>将上述环境搭建好后，将MCU上电并复位，并通过PC端上位机PCAN-View测试如下指令，观察CANopen节点其对指令的响应，来判断该CANopen节点是否处于正常运行状态。</p>
<ul>
<li>将NODE-ID为0x0A的节点设置为 Stop 模式，上位机PCAN-View发送如下指令：</li>
</ul>
<p>表x</p>
<table>
<thead>
<tr>
<th style="text-align: left;">CAN-ID(hex)</th>
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Data(hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">000</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">02 0A</td>
</tr>
</tbody>
</table>
<p>如下图x所示，可接收到如下报文：</p>
<p><img alt="image-20230220172938551" src="../image/Stop-the-Node.png" />
<center> 图 x </center></p>
<ul>
<li>将NODE-ID为0x0A的节点设置为 Start 模式，上位机PCAN-View发送如下指令：</li>
</ul>
<p>表x</p>
<table>
<thead>
<tr>
<th style="text-align: left;">CAN-ID(hex)</th>
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Data(hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">000</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">01 0A</td>
</tr>
</tbody>
</table>
<p>如下图x所示，可接收到如下报文：</p>
<p><img alt="image-20230220181043270" src="../image/Start-the-Node.png" />
<center> 图x </center></p>
<ul>
<li>将NODE-ID为0x0A的节点设置为Pre-operation模式，上位机PCAN-View发送如下指令：</li>
</ul>
<p>表x</p>
<table>
<thead>
<tr>
<th>CAN-ID(hex)</th>
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Data(hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td>70A</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">80 0A</td>
</tr>
</tbody>
</table>
<p>如下图x所示，该节点进入Pre-operation模式，可接收到如下报文：</p>
<p><img alt="image-20230220173143412" src="../image/Preoperaion-the-Node.png" />
<center> 图 x </center></p>
<ul>
<li>将NODE-ID为0x0A节点复位，上位机PCAN-View发送如下指令：</li>
</ul>
<p>表x</p>
<table>
<thead>
<tr>
<th style="text-align: left;">CAN-ID(hex)</th>
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Data(hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">70A</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">81 0A</td>
</tr>
</tbody>
</table>
<p>如下图x所示，该节点被复位：</p>
<p><img alt="image-20230220173338692" src="../image/Reset--the-Node.png" />
<center> 图 x </center></p>
<ul>
<li>将NODE-ID为0x0A节点的通信层复位，上位机PCAN-View发送如下指令：</li>
</ul>
<p>表x</p>
<table>
<thead>
<tr>
<th style="text-align: left;">CAN-ID(hex)</th>
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Data(hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">70A</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">82 0A</td>
</tr>
</tbody>
</table>
<p>如下图x所示，该节点通信层被复位，重新上线：</p>
<p><img alt="image-20230220181246407" src="../image/Reset-commu-the-Node.png" />
<center> 图 x </center></p>
<ul>
<li>获取NODE-ID为0x0A节点的心跳发送间隔时间，上位机PCAN-View发送如下指令：</li>
</ul>
<p>表x</p>
<table>
<thead>
<tr>
<th style="text-align: left;">CAN-ID(hex)</th>
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Data(hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">60A</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">40 17 10 00 00 00 00 00</td>
</tr>
</tbody>
</table>
<p>如下图x所示，返回该节点当前心跳发送间隔时间为1000(0x03E8)ms：</p>
<p><img alt="image-20230220174859554" src="../image/Get-heartbeat.png" />
<center> 图 x </center></p>
<ul>
<li>设置NODE-ID为0x0A节点的心跳发送间隔时间为500(0x01F4)ms，上位机PCAN-View发送如下指令：</li>
</ul>
<p>表x</p>
<table>
<thead>
<tr>
<th style="text-align: left;">CAN-ID(hex)</th>
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Data(hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">60A</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">2B 17 10 00 F4 01 00 00</td>
</tr>
</tbody>
</table>
<p>如下图x所示，该节点当前心跳发送间隔时间变为500ms：</p>
<p><img alt="image-20230220175604643" src="../image/Set-heartbeat.png" />
<center> 图 x </center></p>
<hr />
<h2 id="_5">总结</h2>
<p>本章节讲解了CANopen的基本概念，并对CANopenNode开源协议栈进行了介绍，讲解了如何基于MM32G5330 MCU对CANopenNode协议栈进行移植，以及对移植后的CANopen_Basic样例进行基本指令响应功能的验证。</p>
<hr />
<h2 id="_6">参考文献</h2>
<p>[CiA - CANopen] <a href="https://www.can-cia.org/canopen/">https://www.can-cia.org/canopen/</a></p>
<p>[CANopenNode] <a href="https://github.com/CANopenNode/CANopenNode">https://github.com/CANopenNode/CANopenNode</a></p>
<p>[CANopen_easy_begin] <a href="https://www.zlg.cn/data/upload/software/Can/CANopen_easy_begin.pdf">https://www.zlg.cn/data/upload/software/Can/CANopen_easy_begin.pdf</a></p>
<p>[CANopen Explained - A Simple Intro] <a href="https://www.csselectronics.com/pages/canopen-tutorial-simple-intro">https://www.csselectronics.com/pages/canopen-tutorial-simple-intro</a></p>
<p>[CANopen: The Ultimate Guide (2023) (autopi.io)] <a href="https://www.autopi.io/blog/canopen-simple-introduction-explained/">https://www.autopi.io/blog/canopen-simple-introduction-explained/</a></p>
<hr />
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/" class="btn btn-neutral float-left" title="芯片勘误表"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/" class="btn btn-neutral float-right" title="LwIP移植">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>© Copyright 2024, 上海灵动微电子股份有限公司 http://www.mindmotion.com.cn/</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../..";</script>
    <script src="../../../js/theme_extra.js"></script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
