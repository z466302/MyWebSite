{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u9879\u76ee\u7b80\u4ecb \u5728\u8fd9\u91cc\u60a8\u53ef\u4ee5\u83b7\u53d6\u7075\u52a8\u5fae\u7535\u5b50\u751f\u6001\u76f8\u5173\u7684\u6240\u6709\u8d44\u6599\uff0c\u5305\u62ec\u4f46\u662f\u4e0d\u9650\u4e8e\u5f00\u53d1\u677f\u3001\u56fa\u4ef6\u5e93\u3001UM\u3001DS\u3001Pack\u5305\u3001\u5f00\u53d1\u5de5\u5177\u4ee5\u53ca\u4e00\u4e9b\u5e94\u7528\u7b14\u8bb0\u3002\u60a8\u7684\u5f00\u53d1\u8fc7\u7a0b\u53ef\u80fd\u9700\u8981\u7684\u8d44\u6599\u8fd9\u91cc\u90fd\u6709\u51c6\u5907\uff0c\u60a8\u53ef\u4ee5\u6309\u5de6\u4fa7\u7684\u5bfc\u822a\u6761\u6309\u9700\u4e0b\u8f7d\uff0c\u4e5f\u53ef\u4ee5\u6309\u201cNext\u201d\u6216\u8005\u201cPrevious\u201d\u6309\u94ae\u6765\u6d4f\u89c8\u6574\u4e2a\u8d44\u6599\u5185\u5bb9\u3002 \u5173\u4e8e\u7075\u52a8 \u4e0a\u6d77\u7075\u52a8\u5fae\u7535\u5b50\u80a1\u4efd\u6709\u9650\u516c\u53f8\u6210\u7acb\u4e8e 2011 \u5e74\uff0c\u662f\u4e2d\u56fd\u672c\u571f\u9886\u5148\u7684\u901a\u7528 32 \u4f4d MCU \u4ea7\u54c1\u53ca\u89e3\u51b3\u65b9\u6848\u4f9b\u5e94\u5546\u3002\u516c\u53f8\u57fa\u4e8e Arm Cortex-M \u7cfb\u5217\u5185\u6838\u5f00\u53d1\u7684 MM32 MCU \u4ea7\u54c1\u62e5\u6709 F/G/L/A/SPIN/W \u516d\u5927\u7cfb\u5217\uff0c\u76ee\u524d\u5df2\u91cf\u4ea7\u8fd1 300 \u6b3e\u578b\u53f7\uff0c\u7d2f\u8ba1\u4ea4\u4ed8\u8d85 5 \u4ebf\u9897\uff0c\u6bcf\u5e74\u90fd\u6709\u8fd1\u4ebf\u53f0\u914d\u5907\u4e86\u7075\u52a8 MM32MCU \u7684\u4f18\u79c0\u4ea7\u54c1\u4ea4\u4ed8\u5230\u5ba2\u6237\u624b\u4e2d\uff0c\u5728\u672c\u571f\u901a\u7528 32 \u4f4d MCU \u516c\u53f8\u4e2d\u4f4d\u5c45\u524d\u5217\u3002 \u7075\u52a8\u5ba2\u6237\u6db5\u76d6\u667a\u80fd\u5de5\u4e1a\u3001\u6c7d\u8f66\u7535\u5b50\u3001\u901a\u4fe1\u57fa\u5efa\u3001\u533b\u7597\u5065\u5eb7\u3001\u667a\u6167\u5bb6\u7535\u3001\u7269\u8054\u7f51\u3001\u4e2a\u4eba\u8bbe\u5907\u3001\u624b\u673a\u548c\u7535\u8111\u7b49\u5e94\u7528\u9886\u57df\u3002\u7075\u52a8\u662f\u4e2d\u56fd\u4e3a\u6570\u4e0d\u591a\u7684\u540c\u65f6\u83b7\u5f97\u4e86 Arm-KEIL\u3001IAR\u3001SEGGER \u5b98\u65b9\u652f\u6301\u7684\u672c\u571f MCU \u516c\u53f8\uff0c\u5e76\u5efa\u7acb\u4e86\u72ec\u7acb\u3001\u5b8c\u6574\u7684\u901a\u7528 MCU \u751f\u6001\u4f53\u7cfb\u3002\u7075\u52a8\u59cb\u7ec8\u79c9\u627f\u7740\u201c\u8bda\u4fe1\u3001\u627f\u8bfa\u3001\u521b\u65b0\u3001\u5408\u4f5c\u201d\u7684\u7cbe\u795e\uff0c\u4e3a\u5ba2\u6237\u63d0\u4f9b\u4ece\u786c\u4ef6\u82af\u7247\u5230\u8f6f\u4ef6\u7b97\u6cd5\u3001\u4ece\u53c2\u8003\u65b9\u6848\u5230\u7cfb\u7edf\u8bbe\u8ba1\u7684\u5168\u65b9\u4f4d\u652f\u6301\u3002","title":"\u9879\u76ee\u7b80\u4ecb"},{"location":"#_1","text":"\u5728\u8fd9\u91cc\u60a8\u53ef\u4ee5\u83b7\u53d6\u7075\u52a8\u5fae\u7535\u5b50\u751f\u6001\u76f8\u5173\u7684\u6240\u6709\u8d44\u6599\uff0c\u5305\u62ec\u4f46\u662f\u4e0d\u9650\u4e8e\u5f00\u53d1\u677f\u3001\u56fa\u4ef6\u5e93\u3001UM\u3001DS\u3001Pack\u5305\u3001\u5f00\u53d1\u5de5\u5177\u4ee5\u53ca\u4e00\u4e9b\u5e94\u7528\u7b14\u8bb0\u3002\u60a8\u7684\u5f00\u53d1\u8fc7\u7a0b\u53ef\u80fd\u9700\u8981\u7684\u8d44\u6599\u8fd9\u91cc\u90fd\u6709\u51c6\u5907\uff0c\u60a8\u53ef\u4ee5\u6309\u5de6\u4fa7\u7684\u5bfc\u822a\u6761\u6309\u9700\u4e0b\u8f7d\uff0c\u4e5f\u53ef\u4ee5\u6309\u201cNext\u201d\u6216\u8005\u201cPrevious\u201d\u6309\u94ae\u6765\u6d4f\u89c8\u6574\u4e2a\u8d44\u6599\u5185\u5bb9\u3002","title":"\u9879\u76ee\u7b80\u4ecb"},{"location":"#_2","text":"\u4e0a\u6d77\u7075\u52a8\u5fae\u7535\u5b50\u80a1\u4efd\u6709\u9650\u516c\u53f8\u6210\u7acb\u4e8e 2011 \u5e74\uff0c\u662f\u4e2d\u56fd\u672c\u571f\u9886\u5148\u7684\u901a\u7528 32 \u4f4d MCU \u4ea7\u54c1\u53ca\u89e3\u51b3\u65b9\u6848\u4f9b\u5e94\u5546\u3002\u516c\u53f8\u57fa\u4e8e Arm Cortex-M \u7cfb\u5217\u5185\u6838\u5f00\u53d1\u7684 MM32 MCU \u4ea7\u54c1\u62e5\u6709 F/G/L/A/SPIN/W \u516d\u5927\u7cfb\u5217\uff0c\u76ee\u524d\u5df2\u91cf\u4ea7\u8fd1 300 \u6b3e\u578b\u53f7\uff0c\u7d2f\u8ba1\u4ea4\u4ed8\u8d85 5 \u4ebf\u9897\uff0c\u6bcf\u5e74\u90fd\u6709\u8fd1\u4ebf\u53f0\u914d\u5907\u4e86\u7075\u52a8 MM32MCU \u7684\u4f18\u79c0\u4ea7\u54c1\u4ea4\u4ed8\u5230\u5ba2\u6237\u624b\u4e2d\uff0c\u5728\u672c\u571f\u901a\u7528 32 \u4f4d MCU \u516c\u53f8\u4e2d\u4f4d\u5c45\u524d\u5217\u3002 \u7075\u52a8\u5ba2\u6237\u6db5\u76d6\u667a\u80fd\u5de5\u4e1a\u3001\u6c7d\u8f66\u7535\u5b50\u3001\u901a\u4fe1\u57fa\u5efa\u3001\u533b\u7597\u5065\u5eb7\u3001\u667a\u6167\u5bb6\u7535\u3001\u7269\u8054\u7f51\u3001\u4e2a\u4eba\u8bbe\u5907\u3001\u624b\u673a\u548c\u7535\u8111\u7b49\u5e94\u7528\u9886\u57df\u3002\u7075\u52a8\u662f\u4e2d\u56fd\u4e3a\u6570\u4e0d\u591a\u7684\u540c\u65f6\u83b7\u5f97\u4e86 Arm-KEIL\u3001IAR\u3001SEGGER \u5b98\u65b9\u652f\u6301\u7684\u672c\u571f MCU \u516c\u53f8\uff0c\u5e76\u5efa\u7acb\u4e86\u72ec\u7acb\u3001\u5b8c\u6574\u7684\u901a\u7528 MCU \u751f\u6001\u4f53\u7cfb\u3002\u7075\u52a8\u59cb\u7ec8\u79c9\u627f\u7740\u201c\u8bda\u4fe1\u3001\u627f\u8bfa\u3001\u521b\u65b0\u3001\u5408\u4f5c\u201d\u7684\u7cbe\u795e\uff0c\u4e3a\u5ba2\u6237\u63d0\u4f9b\u4ece\u786c\u4ef6\u82af\u7247\u5230\u8f6f\u4ef6\u7b97\u6cd5\u3001\u4ece\u53c2\u8003\u65b9\u6848\u5230\u7cfb\u7edf\u8bbe\u8ba1\u7684\u5168\u65b9\u4f4d\u652f\u6301\u3002","title":"\u5173\u4e8e\u7075\u52a8"},{"location":"ComingSoon/","text":"coming soon\u2026\u2026","title":"\u8d44\u8d283"},{"location":"ComingSoon/#coming-soon","text":"","title":"coming soon\u2026\u2026"},{"location":"MM32A%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/","text":"MM32A0140\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32A0160\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32A\u7cfb\u5217"},{"location":"MM32A%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32a0140","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32A0140\u7cfb\u5217"},{"location":"MM32A%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32a0160","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32A0160\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/","text":"MM32F0010\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe__Mini \u786c\u4ef6\u539f\u7406\u56fe_eMini \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F0020\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F0130\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe__Mini \u786c\u4ef6\u539f\u7406\u56fe__eMini \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F0140\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F0160\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F0040\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F0270\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F3270\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe__Mini \u786c\u4ef6\u539f\u7406\u56fe_PLUS \u786c\u4ef6\u539f\u7406\u56fe_EVB \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F5230\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F5330\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F5270\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe_Mini \u786c\u4ef6\u539f\u7406\u56fe__PLUS \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F5280\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F003\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F031xx_q\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32F103xx_n\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f0010","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe__Mini \u786c\u4ef6\u539f\u7406\u56fe_eMini \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F0010\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f0020","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F0020\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f0130","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe__Mini \u786c\u4ef6\u539f\u7406\u56fe__eMini \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F0130\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f0140","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F0140\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f0160","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F0160\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f0040","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F0040\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f0270","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F0270\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f3270","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe__Mini \u786c\u4ef6\u539f\u7406\u56fe_PLUS \u786c\u4ef6\u539f\u7406\u56fe_EVB \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F3270\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f5230","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F5230\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f5330","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F5330\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f5270","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe_Mini \u786c\u4ef6\u539f\u7406\u56fe__PLUS \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F5270\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f5280","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F5280\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f003","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F003\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f031xx_q","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F031xx_q\u7cfb\u5217"},{"location":"MM32F%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32f103xx_n","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32F103xx_n\u7cfb\u5217"},{"location":"MM32G%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/","text":"MM32G0001\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32G0020\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32G0140\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32G0160\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32G5330\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32G\u7cfb\u5217"},{"location":"MM32G%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32g0001","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32G0001\u7cfb\u5217"},{"location":"MM32G%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32g0020","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32G0020\u7cfb\u5217"},{"location":"MM32G%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32g0140","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32G0140\u7cfb\u5217"},{"location":"MM32G%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32g0160","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32G0160\u7cfb\u5217"},{"location":"MM32G%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32g5330","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32G5330\u7cfb\u5217"},{"location":"MM32L%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/","text":"MM32L0020\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32L0130\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32L0xx_n\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32L3xx_n\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32L\u7cfb\u5217"},{"location":"MM32L%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32l0020","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32L0020\u7cfb\u5217"},{"location":"MM32L%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32l0130","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32L0130\u7cfb\u5217"},{"location":"MM32L%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32l0xx_n","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32L0xx_n\u7cfb\u5217"},{"location":"MM32L%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32l3xx_n","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32L3xx_n\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/","text":"MM32SPIN023C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN222C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN422C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN030C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN040C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN080C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN560C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN580C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN160C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN360C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN320B\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN380C\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN120B\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN05\u7cfb\u5217 DS_VersionE DS_VersionF UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN06\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN07\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN0230\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN0280\u7cfb\u5217 DS_VersionB DS_VersionC UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32SPIN2x\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin023c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN023C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin222c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN222C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin422c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN422C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin030c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN030C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin040c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN040C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin080c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN080C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin560c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN560C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin580c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN580C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin160c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN160C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin360c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN360C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin320b","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN320B\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin380c","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN380C\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin120b","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN120B\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin05","text":"DS_VersionE DS_VersionF UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN05\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin06","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN06\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin07","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN07\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin0230","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN0230\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin0280","text":"DS_VersionB DS_VersionC UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN0280\u7cfb\u5217"},{"location":"MM32SPIN%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32spin2x","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32SPIN2x\u7cfb\u5217"},{"location":"MM32W%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/","text":"MM32WB0510\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305 MM32W0xx\u7cfb\u5217 DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32W\u7cfb\u5217"},{"location":"MM32W%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32wb0510","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32WB0510\u7cfb\u5217"},{"location":"MM32W%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/#mm32w0xx","text":"DS UM \u786c\u4ef6\u539f\u7406\u56fe \u5e93\u51fd\u6570\u548c\u4f8b\u7a0b Pack\u5305","title":"MM32W0xx\u7cfb\u5217"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/","text":"\u82af\u7247\u52d8\u8bef\u8868 FlexCAN ERR005829 FlexCAN\u4e0d\u4f20\u8f93\u5728\u4ef2\u88c1\u8fc7\u7a0b\u4e2d\u7684\u7279\u5b9a\u65f6\u523b\u542f\u7528\u4f20\u8f93\u7684\u6d88\u606f \u63cf\u8ff0 FlexCAN\u4e0d\u4f20\u8f93\u5728\u4ef2\u88c1\u8fc7\u7a0b\u4e2d\u7684\u7279\u5b9a\u65f6\u523b\u542f\u7528\u4f20\u8f93\u7684\u6d88\u606f\u3002\u51fa\u73b0\u8be5\u95ee\u9898\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6: \u2022\u53ea\u914d\u7f6e\u4e00\u4e2a\u6d88\u606f\u7f13\u51b2\u533a\u6765\u4f20\u8f93 \u2022\u5728\u4ef2\u88c1\u8fc7\u7a0b\u4e2d\u7684\u7279\u5b9a\u65f6\u949f\u671f\u95f4\uff0c\u4f7f\u6d88\u606f\u7f13\u51b2\u533a\u80fd\u591f\u4f20\u8f93\u7684\u5199\u64cd\u4f5c(\u5199\u5728\u63a7\u5236/\u72b6\u6001\u5b57\u4e0a)\u53d1\u751f\u3002 \u2022\u5728\u6b64\u4ef2\u88c1\u8fc7\u7a0b\u53d1\u751f\u540e\uff0c\u603b\u7ebf\u8fdb\u5165Idle\u72b6\u6001\uff0c\u5e76\u4e14\u603b\u7ebf\u4e0a\u6ca1\u6709\u6536\u5230\u65b0\u6d88\u606f\u3002 \u4f8b\u5982: 1. \u6d88\u606f\u7f13\u51b2\u533a13\u5728RxIntermission\u4e0a\u88ab\u505c\u7528(\u5c060x0\u5199\u5165CODE\u5b57\u6bb5) \u63a7\u5236/\u72b6\u6001\u5b57)[\u5148\u5199\u5165CODE] 2. \u91cd\u65b0\u914d\u7f6eID\u548cdata\u5b57\u6bb5 3. \u542f\u7528\u6d88\u606f\u7f13\u51b2\u533a13\u5728BusIdle\u4e0a\u4f20\u8f93(\u5728CODE\u5b57\u6bb5\u4e0a\u51990xC)[\u7b2c\u4e8c\u6b21\u5199\u5165CODE] 4. CAN\u603b\u7ebf\u4fdd\u6301\u5728\u7a7a\u95f2\u72b6\u6001 5. \u6ca1\u6709\u4ece\u4efb\u4f55\u6d88\u606f\u7f13\u51b2\u533a\u5199\u5165\u63a7\u5236/\u72b6\u6001\u3002 \u5728\u7b2c\u4e8c\u6b21\u5199\u5165CODE(\u6b65\u9aa43)\u671f\u95f4\uff0c\u5199\u5165\u5fc5\u987b\u5728\u4ef2\u88c1\u8fdb\u7a0b\u626b\u63cf\u5f53\u524d\u6d88\u606f\u7f13\u51b2\u533a13\u4e4b\u524d\u4e00\u4e2a\u65f6\u949f\u53d1\u751f\u3002\u5728\u672c\u4f8b\u4e2d\uff0c\u5b83\u4e0d\u68c0\u6d4b\u65b0\u4ee3\u7801 (0xC)\u5e76\u4e14\u6ca1\u6709\u5b89\u6392\u65b0\u7684\u4ef2\u88c1\u3002 \u53ea\u6709\u5f53\u6d88\u606f\u6d41\u91cf\u505c\u6b62\u5e76\u4e14can\u603b\u7ebf\u5728\u4e0a\u8ff0\u4e8b\u4ef6\u5e8f\u5217\u4e4b\u540e\u8fdb\u5165Idle\u72b6\u6001\u65f6\uff0c\u624d\u80fd\u68c0\u6d4b\u5230\u95ee\u9898\u3002 \u5982\u679c\u7b26\u5408\u4ee5\u4e0b\u4efb\u4f55\u6761\u4ef6\uff0c\u5219\u6ca1\u6709\u95ee\u9898: \u2022\u4efb\u4f55\u6d88\u606f\u7f13\u51b2\u533a(Tx\u6216Rx)\u90fd\u88ab\u91cd\u65b0\u914d\u7f6e(\u901a\u8fc7\u5199\u5165\u5176CS\u5b57\u6bb5) \u5e55\u95f4\u4f11\u606f\u3002 \u2022\u6709\u5176\u4ed6\u914d\u7f6e\u7684\u6d88\u606f\u7f13\u51b2\u533a\u8981\u4f20\u8f93\u3002 \u2022\u4efb\u4f55\u5916\u90e8\u8282\u70b9\u53d1\u9001\u7684\u65b0\u4f20\u5165\u6d88\u606f\u5728\u4e2d\u573a\u4f11\u606f\u5b57\u6bb5\u4e4b\u540e\u5f00\u59cb\u3002 \u53d7\u5f71\u54cd\u82af\u7247 \u82af\u72471 \u82af\u72472 \u82af\u72473 \u89e3\u51b3\u529e\u6cd5 \u8981\u4f20\u8f93CAN\u5e27\uff0cCPU\u5fc5\u987b\u901a\u8fc7\u6267\u884c\u4ee5\u4e0b\u6807\u51c6\u76845\u4e2a\u6b65\u9aa4\u4ee5\u751f\u6210\u7528\u4e8e\u4f20\u8f93\u7684\u6d88\u606f\u7f13\u51b2\u533a\uff1a 1. \u68c0\u67e5\u662f\u5426\u8bbe\u7f6e\u4e86\u76f8\u5e94\u7684\u4e2d\u65ad\u4f4d\u5e76\u6e05\u9664\u5b83 2. \u5982\u679c\u6d88\u606f\u7f13\u51b2\u533a\u5904\u4e8e\u6d3b\u52a8\u72b6\u6001\uff08\u4f20\u8f93\u6302\u8d77\uff09\uff0c\u8bf7\u5c06\u4e2d\u6b62\u4ee3\u7801\uff080b1001\uff09\u5199\u5165\u63a7\u5236/\u72b6\u6001\u5b57\u7684CODE\u5b57\u6bb5\uff0c\u4ee5\u8bf7\u6c42\u4e2d\u6b62\u4f20\u8f93\u3002\u901a\u8fc7\u8f6e\u8be2IFLAG\u5bc4\u5b58\u5668\u6216\u4e2d\u65ad\u8bf7\u6c42\uff08\u5982\u679c\u7531\u76f8\u5e94\u7684IMASK\u542f\u7528\uff09\u6765\u7b49\u5f85\u65ad\u8a00\u76f8\u5e94\u7684IFLAG\u3002\u7136\u540e\u8bfb\u56deCODE\u5b57\u6bb5\u4ee5\u68c0\u67e5\u4f20\u8f93\u662f\u5426\u5df2\u4e2d\u6b62\u6216\u5df2\u4f20\u8f93\u3002\u5982\u679c\u9700\u8981\u5411\u540e\u517c\u5bb9\uff08MCR[AEN]\u4f4d\u88ab\u5426\u5b9a\uff09\uff0c\u53ea\u9700\u5c06\u975e\u6d3b\u52a8\u4ee3\u7801\uff080b1000\uff09\u5199\u5165CODE\u5b57\u6bb5\u4ee5\u505c\u7528\u6d88\u606f\u7f13\u51b2\u533a\uff0c\u4f46\u968f\u540e\u53ef\u80fd\u4f1a\u5728\u4e0d\u901a\u77e5\u7684\u60c5\u51b5\u4e0b\u4f20\u8f93\u6302\u8d77\u7684\u5e27\u3002 3. \u5199ID\u5b57 4. \u5199\u5165\u6570\u636e\u5b57\u8282 5. \u5199\u5165\u63a7\u5236/\u72b6\u6001\u5b57\u7684DLC\u3001Control\u548cCODE\u5b57\u6bb5\u4ee5\u6fc0\u6d3b\u6d88\u606f\u7f13\u51b2\u533a 6. \u8be5\u89e3\u51b3\u65b9\u6cd5\u5305\u62ec\u6267\u884c\u4e24\u4e2a\u989d\u5916\u7684\u6b65\u9aa4\uff1a 7. \u5c06\u7b2c\u4e00\u4e2a\u6709\u6548\u90ae\u7bb1\u4fdd\u7559\u4e3a\u975e\u6d3b\u52a8\u90ae\u7bb1\uff08CODE = 0b1000\uff09\u3002\u5982\u679c\u7981\u7528\u4e86RX FIFO\uff0c\u5219\u6b64\u90ae\u7bb1\u5fc5\u987b\u662f\u90ae\u4ef6\u7f13\u51b2\u533a0\u3002\u5426\u5219\uff0c\u53ef\u4ee5\u4f7f\u7528\u82af\u7247\u53c2\u8003\u624b\u518cFlexCAN\u7ae0\u8282\u4e2d\u7684\u201cRX FIFO\u6ee4\u6ce2\u5668\u201d\u8868\u627e\u5230\u7b2c\u4e00\u4e2a\u6709\u6548\u90ae\u7bb1 8. \u5c06\u4e24\u6b21\u975e\u6d3b\u52a8\u4ee3\u7801\uff080b1000\uff09\u5199\u5165\u7b2c\u4e00\u4e2a\u6709\u6548\u90ae\u7bb1 ERR006032 \u5f53CAN\u603b\u7ebf\u5904\u4e8e\u603b\u7ebf\u7a7a\u95f2\u72b6\u6001\u65f6\uff0c\u6b63\u5728\u4f20\u8f93\u7684\u6d88\u606f\u7f13\u51b2\u533a\u4e2d\u6b62\u6216\u505c\u7528\u65f6\uff0c\u5177\u6709\u9519\u8befID\u6216\u6709\u6548\u8d1f\u8f7d\u7684\u5e27\u88ab\u4f20\u8f93\u5230CAN\u603b\u7ebf\u4e2d \u63cf\u8ff0 \u5982\u679c\u5728FlexCAN\u5904\u4e8e\u603b\u7ebf\u7a7a\u95f2\u72b6\u6001\u65f6\u914d\u7f6e\u4e86\u4e00\u4e2a\u6216\u591a\u4e2a\u6d88\u606f\u7f13\u51b2\u533a\uff08MB\uff09\u8fdb\u884c\u4f20\u8f93\uff0c\u5e76\u4e14\u9009\u62e9\u4f20\u8f93\u7684MB\u5728\u5f00\u59cb\u4f20\u8f93\u7684\u786e\u5207\u65f6\u523b\u88ab\u4e2d\u6b62\u6216\u505c\u7528\uff0c\u5219FlexCAN\u6a21\u5757\u53ef\u80fd\u4f1a\u4f20\u8f93\u4e0d\u6b63\u786e\u7684\u4fe1\u606f\u3002\u8fd9\u5c06\u5bfc\u81f4FlexCAN\u53d1\u9001\u8bed\u6cd5\u6b63\u786e\u7684\u6d88\u606f\uff0c\u4f46\u4f7f\u7528\u4e0d\u6b63\u786e\u7684ID\u6216\u6570\u636e\u5b57\u6bb5\u3002CRC\u4fe1\u606f\u5c06\u57fa\u4e8e\u4e0d\u6b63\u786e\u7684\u6570\u636e\uff08\u4ee5\u9632\u6570\u636e\u53d7\u5230\u5f71\u54cd\uff09\u8fdb\u884c\u8ba1\u7b97\uff0c\u4e14\u5e27\u4e2d\u7684\u6240\u6709\u5176\u4ed6\u5b57\u6bb5\u90fd\u5c06\u662f\u6b63\u786e\u7684\u3002 \u5728\u4f20\u8f93\u4e00\u5e27\u65f6\uff0c\u95ee\u9898\u53d1\u751f\u7684\u6982\u7387\u4ec5\u9650\u4e8e\u4e00\u4e2aCAN\u4f4d\uff0c\u5728\u975e\u5e38\u7279\u5b9a\u7684\u591a\u8d77\u4e8b\u4ef6\u7ec4\u5408\u4e0b\uff1a 1. Bug\u4e8b\u4ef6\u53ef\u80fd\u53d1\u751f\u5728\u6bcf\u5e27\u4e00\u4e2a\u7279\u5b9a\u7684CAN\u4f4d\u4e2d 2. CAN\u603b\u7ebf\u5fc5\u987b\u5904\u4e8e\u603b\u7ebf\u7a7a\u95f2\u72b6\u6001 3. \u5fc5\u987b\u89e6\u53d1CPU\u4ee5\u914d\u7f6e\u4e00\u4e2a\u6216\u591a\u4e2aMB\u4ee5\u5728\u603b\u7ebf\u7a7a\u95f2\u72b6\u6001\u4e0b\u8fdb\u884c\u4f20\u8f93 4. \u5728\u6b65\u9aa43\u4e2d\u5f00\u59cb\u914d\u7f6e\u7684\u77ed\u65f6\u95f4\u5185\uff0c\u5fc5\u987b\u89e6\u53d1CPU\uff0c\u901a\u8fc7\u505c\u7528\u5220\u9664\u521a\u521a\u914d\u7f6e\u7684 MB\u3002 \u7efc\u4e0a\u6240\u8ff0\uff0c\u53d1\u751f\u7684\u6982\u7387\u975e\u5e38\u4f4e\uff0c\u5927\u7ea6\u4e3a1/1000\u4e07\u3002\u6b64\u5916\uff0c\u5728\u6b63\u5e38\u5e94\u7528\u4e2d\u4e0d\u592a\u53ef\u80fd\u53d1\u751f\u914d\u7f6eMB\uff0c\u7136\u540e\u5728\u77ed\u65f6\u95f4\u5185\u505c\u7528\u76f8\u540cMB\u7684\u8fc7\u7a0b\u3002 \u5728\u5b9e\u8df5\u4e2d\uff0c\u5982\u679cCPU\u4fdd\u8bc1\u4f20\u8f93\u914d\u7f6e\u7684\u4efb\u4f55MB\u5c06\u5728\u4e0b\u4e00\u5e27\u4e2d\u6b62\u6216\u505c\u7528\uff0c\u5219\u6ca1\u6709\u95ee\u9898 \u53d7\u5f71\u54cd\u82af\u7247 \u82af\u72471 \u82af\u72472 \u82af\u72473 \u89e3\u51b3\u529e\u6cd5 \u5f53CAN\u603b\u7ebf\u5904\u4e8e\u603b\u7ebf\u7a7a\u95f2\u72b6\u6001\u65f6\uff0c\u7528\u6237\u53ef\u4ee5\u901a\u8fc7\u963b\u6b62\u5bf9\u4f20\u8f93\u8fdb\u884cMB\u914d\u7f6e\u6765\u907f\u514d\u8be5\u9519\u8bef\u3002FlexCAN\u8c03\u8bd5\u5bc4\u5b58\u5668\u4e2d\u6709\u4e00\u4e9b\u4f4d\u53ef\u7528\u4e8e\u786e\u5b9aCAN\u603b\u7ebf\u4f55\u65f6\u5904\u4e8e\u7a7a\u95f2\u72b6\u6001\u3002 \u8be5\u8c03\u8bd5\u5bc4\u5b58\u5668\u4f4d\u4e8e\uff1aFlexCAN\u8c03\u8bd51\u5bc4\u5b58\u5668\uff08CAN_DBG1\uff09- Base + 0x0058\u3002CAN_DBG1\u5bc4\u5b58\u5668\u7684CAN\u6709\u9650\u72b6\u6001\u673a\uff08CFSM\uff09\u4f4d\u76d1\u63a7FlexCAN\u7684\u5185\u90e8\u72b6\u6001\u3002CFSM\u662fCAN_DBG1\u5bc4\u5b58\u5668\u4e2d\u516d\u4e2a\u6700\u4f4e\u4f4d\u3002CAN\u4f4d\u6570\uff08CBN\uff09\u662fCAN_DBG1\u5bc4\u5b58\u5668\u4e2dbit\u4f4d3\u81f37\u5904\u7684\u4e94\u4f4d\u957f\u5b57\u6bb5\uff0c\u7528\u4e8e\u6307\u793a\u7ed9\u5b9aCFSM\u72b6\u6001\u503c\u4e2d\u7684\u5f53\u524d\u4f4d\u6570\u3002 CAN_DBG1.CFSM = 0x0000_003F CAN_DBG1.CBN = 0x1F00_0000 \u9700\u8981\u67e5\u627e\u51e0\u4e2a\u5185\u90e8\u72b6\u6001\u503c\uff0c\u4e0b\u9762\u5217\u51fa\u4e86\u5b83\u4eec\u76f8\u5e94\u7684CFSM\u503c RXINTERMISSION - 0x2F TXINTERMISSION - 0x14 BUSIDLE - 0x02 \u5fc5\u987b\u6267\u884c\u4ee5\u4e0b\u8fc7\u7a0b\u6765\u914d\u7f6eMB\u4f20\u8f93\uff1a 1. \u7981\u7528\u6240\u6709\u4e2d\u65ad 2. \u8bfb\u53d6CAN_DBG1.CFSM\u548cCAN_DBG1.CBN\u5b57\u6bb5 3. \u68c0\u67e5CFSM\u503c\u662f\u5426\u4e3aBUSIDLE\u3001RXINTERMISSION\u6216TXINTERMISSION \u5bf9\u4e8e\u540e\u4e24\u4e2a\u503c\uff0c\u8fd8\u8981\u68c0\u67e5CBN\u503c\u662f\u5426\u4e3a3\uff0c\u4ee5\u786e\u5b9a\u914d\u5bf9\u6761\u4ef6RXINTERMISSION bit 3\u6216TXINTERMISSION bit 3\uff0c\u5e76\u6309\u5982\u4e0b\u6240\u8ff0\u8fdb\u884c\u5904\u7406\u3002 3.1 \u5982\u679cCAN_DBG1\u5b57\u6bb5\u6307\u793a BUSIDLE\uff0c\u5219\u7b49\u5f85N\u4e2aCPU\u65f6\u949f 3.2 \u5426\u5219\uff0c\u82e5CAN_DBG1\u5982\u679c\u5b57\u6bb5\u6307\u793aRXINTERMISSION\u4f4d3\u6216TXINTERMISSION\u4f4d3\uff0c\u5219\u7b49\u5f85CFSM\u4e0eRXINTERMISSION\u6216TXINTERMISSION\u4e0d\u540c 4. \u5c060x0\u5199\u5165CS\u5b57\u7684\u4ee3\u7801\u5b57\u6bb5 5. \u4f7f\u80fd\u6240\u6709\u4e2d\u65ad 6. \u5199\u5165ID\u5b57 7. \u5199\u5165DATA\u5b57 8. \u5c060xC\u5199\u5165CS\u5b57\u7684\u4ee3\u7801\u5b57\u6bb5 ERR009527 \u4f20\u8f93\u4e2d\u6b62\u673a\u5236\u53ef\u80fd\u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c \u63cf\u8ff0 \u7075\u6d3b\u63a7\u5236\u5668\u5c40\u57df\u7f51\uff08FlexCAN\uff09\u65e0\u6cd5\u4e2d\u6b62\u4f20\u8f93\u5e27\uff0c\u5728\u4ee5\u4e0b\u60c5\u51b5\u4e0b\uff0c\u4e2d\u6b62\u8fc7\u7a0b\u53ef\u80fd\u4fdd\u6301\u5f85\u5b9a\u72b6\u6001\uff1a 1. \u5982\u679c\u5728FlexCAN\u63a5\u6536\u8fdc\u7a0b\u5e27\u65f6\u53d1\u751f\u6302\u8d77\u7684\u4e2d\u6b62\u8bf7\u6c42 2. \u5f53\u5e27\u5728\u5e27\u63a5\u6536\u540e\u7684\u91cd\u8f7d\u5e27\u671f\u95f4\u4e2d\u6b62\u65f6 3. \u5f53FlexCAN\u521a\u521a\u5f00\u59cb\u4f20\u8f93\u65f6\u5c31\u8bf7\u6c42\u4e2d\u6b62 4. \u5f53\u53d1\u751f\u51bb\u7ed3\u6a21\u5f0f\u8bf7\u6c42\u4e14FlexCAN\u521a\u521a\u5f00\u59cb\u4f20\u8f93\u65f6 \u53d7\u5f71\u54cd\u82af\u7247 \u82af\u72471 \u82af\u72472 \u82af\u72473 \u89e3\u51b3\u529e\u6cd5 \u4f7f\u7528\u90ae\u7bb1\u505c\u7528\u673a\u5236\u800c\u4e0d\u662f\u4f20\u8f93\u4e2d\u6b62\u673a\u5236\u3002\u6a21\u5757\u914d\u7f6e\u5bc4\u5b58\u5668\u7684\u4e2d\u6b62\u4f7f\u80fd\uff08AEN\uff09\u4f4d\u53ef\u4ee5\u4fdd\u6301\u6e05\u9664\u72b6\u6001\uff0c\u5e76\u4e14\u4e2d\u6b62\u4ee3\u7801\u503c\u201c0b1001\u201d\u4e0d\u80fd\u88ab\u5199\u5165\u6d88\u606f\u7f13\u51b2\u533a\u63a7\u5236\u548c\u72b6\u6001\u5b57\u7684CODE\u5b57\u6bb5\u3002 ERR009595 \u5982\u679c\u5728\u603b\u7ebf\u5173\u95ed\u72b6\u6001\u4e0b\u8fdb\u5165\u51bb\u7ed3\u6a21\u5f0f\u6216\u4f4e\u529f\u8017\u6a21\u5f0f\uff0c\u5219\u5e27\u53ef\u80fd\u635f\u574f \u63cf\u8ff0 \u5982\u679c\u6a21\u5757\u914d\u7f6e\u5bc4\u5b58\u5668\uff08MCR\uff09\u7684\u51bb\u7ed3\u4f7f\u80fd\u4f4d\uff08FRZ\uff09\u88ab\u7f6e\u4f4d\uff0c\u5e76\u4e14\u5728\u603b\u7ebf\u5173\u95ed\u72b6\u6001\u671f\u95f4\u901a\u8fc7\u7f6e\u4f4dMCR\u5bc4\u5b58\u5668\u7684\u505c\u6b62\u4f4d\uff08HALT\uff09\u6765\u8bf7\u6c42\u51bb\u7ed3\u6a21\u5f0f\uff0c\u5219\u9000\u51fa\u603b\u7ebf\u5173\u95ed\u6761\u4ef6\u540e\u7684\u4f20\u8f93\u5c06\u88ab\u635f\u574f\u3002\u4ec5\u5f53\u4f20\u8f93\u5728\u51bb\u7ed3\u6a21\u5f0f\u8bf7\u6c42\u4e4b\u524d\u5904\u4e8e\u6302\u8d77\u72b6\u6001\u65f6\uff0c\u624d\u4f1a\u51fa\u73b0\u6b64\u95ee\u9898\u3002\u6b64\u5916\uff0c\u5982\u679c\u8bf7\u6c42\u4f4e\u529f\u8017\u6a21\u5f0f\u800c\u4e0d\u662f\u51bb\u7ed3\u6a21\u5f0f\uff0c\u4e5f\u4f1a\u51fa\u73b0\u540c\u6837\u7684\u95ee\u9898\u3002 \u53d7\u5f71\u54cd\u82af\u7247 \u82af\u72471 \u82af\u72472 \u82af\u72473 \u89e3\u51b3\u529e\u6cd5 \u89e3\u51b3\u65b9\u6cd5\u53d6\u51b3\u4e8e\u5728\u8bf7\u6c42\u51bb\u7ed3\u6a21\u5f0f\u6216\u4f4e\u529f\u8017\u6a21\u5f0f\u4e4b\u524d\u662f\u5426\u53d1\u751fBus-Off\u6761\u4ef6\u3002 \u8fdb\u5165\u51bb\u7ed3\u6a21\u5f0f\u7684\u8fc7\u7a0b\uff1a 1. \u5728\u6a21\u5757\u63a7\u5236\u5bc4\u5b58\u5668\uff08MCR\uff09\u4e2d\u7f6e\u4f4d\u51bb\u7ed3\u4f7f\u80fd\u4f4d\uff08FRZ\uff09 2. \u68c0\u67e5MCR\u5bc4\u5b58\u5668\u7684\u6a21\u5757\u7981\u7528\u4f4d\uff08MDIS\uff09\u662f\u5426\u7f6e\u4f4d\u3002\u5982\u679c\u7f6e\u4f4d\uff0c\u6e05\u9664MDIS\u4f4d 3. \u8f6e\u8be2MCR\u5bc4\u5b58\u5668\uff0c\u76f4\u5230MCR\u4e2d\u7684\u4f4e\u529f\u8017\u6a21\u5f0f\u786e\u8ba4\uff08LPMACK\uff09\u4f4d\u88ab\u6e05\u9664\uff08\u8f6f\u4ef6\u5b9e\u73b0\u7684\u8d85\u65f6\u4e3a\u4e24\u4e2aCAN\u4f4d\u957f\u5ea6\uff09 4. \u8bfb\u53d6\u9519\u8bef\u548c\u72b6\u60011\u5bc4\u5b58\u5668\uff08ESR1\uff09\u4e2d\u7684\u6545\u969c\u9650\u5236\u72b6\u6001\uff08FLTCONF\uff09\u5b57\u6bb5\uff0c\u4ee5\u68c0\u67e5FlexCAN\u662f\u5426\u5904\u4e8e\u603b\u7ebf\u5173\u95ed\u72b6\u6001\u3002\u5982\u679c\u662f\uff0c\u8bf7\u8f6c\u5230\u6b65\u9aa45A\u3002\u5426\u5219\uff0c\u8bf7\u8f6c\u5230\u6b65\u9aa45B\u3002 5A. \u7f6e\u4f4dMCR\u5bc4\u5b58\u5668\u7684\u8f6f\u4ef6\u590d\u4f4d\u4f4d\uff08\uff08SOFTRST\uff09 6A. \u8f6e\u8be2MCR\u5bc4\u5b58\u5668\uff0c\u76f4\u5230\u8f6f\u4ef6\u590d\u4f4d\uff08SOFTRST\uff09\u4f4d\u88ab\u6e05\u9664\uff08\u8f6f\u4ef6\u5b9e\u73b0\u7684\u8d85\u65f6\u4e3a\u4e24\u4e2aCAN\u4f4d\u957f\u5ea6 7A. \u8f6e\u8be2MCR\u5bc4\u5b58\u5668\uff0c\u76f4\u5230\u7f6e\u4f4d\u51bb\u7ed3\u786e\u8ba4\uff08FRZACK\uff09\u4f4d\uff08\u8f6f\u4ef6\u5b9e\u73b0\u7684\u8d85\u65f6\u4e3a\u4e24\u4e2aCAN\u4f4d\u957f\u5ea6\uff09 8A. \u91cd\u65b0\u914d\u7f6eMCR\u5bc4\u5b58\u5668 9A. \u91cd\u65b0\u914d\u7f6e\u6240\u6709\u4e2d\u65ad\u63a9\u7801\u5bc4\u5b58\u5668\uff08IMASKn\uff09 5B. \u7f6e\u4f4dMCR\u5bc4\u5b58\u5668\u7684Halt FlexCAN\uff08HALT\uff09\u4f4d 6B. \u8f6e\u8be2MCR\u5bc4\u5b58\u5668\uff0c\u76f4\u5230\u7f6e\u4f4d\u51bb\u7ed3\u786e\u8ba4\uff08FRZACK\uff09\u4f4d\uff08\u8f6f\u4ef6\u5b9e\u73b0\u7684\u8d85\u65f6\u4e3a178\u4e2aCAN\u4f4d\u957f\u5ea6\uff09 Note\uff01\u6b65\u9aa44\u548c\u6b65\u9aa45B\u4e4b\u95f4\u7684\u65f6\u95f4\u5fc5\u987b\u5c0f\u4e8e1353\u4e2aCAN\u4f4d\u5468\u671f\u3002 \u8fdb\u5165\u4f4e\u529f\u8017\u6a21\u5f0f\u7684\u6b65\u9aa4\uff1a 1. \u8fdb\u5165\u51bb\u7ed3\u6a21\u5f0f\uff08\u6267\u884c\u8fc7\u7a0b A\uff09 2. \u8bf7\u6c42\u4f4e\u529f\u8017\u6a21\u5f0f 3. \u8f6e\u8be2MCR\u5bc4\u5b58\u5668\uff0c\u76f4\u5230MCR\u5bc4\u5b58\u5668\u7684\u4f4e\u529f\u8017\u6a21\u5f0f\u786e\u8ba4\uff08LPMACK\uff09\u4f4d\u88ab\u7f6e1\uff08\u8f6f\u4ef6\u5b9e\u73b0\u7684\u8d85\u65f6\u4e3a\u4e24\u4e2aCAN\u4f4d\u957f\u5ea6\uff09 ADC \u9519\u8bef\u53f7 \u9519\u8bef\u53f7 BKP \u9519\u8bef\u53f7 \u9519\u8bef\u53f7 CRC \u9519\u8bef\u53f7 \u9519\u8bef\u53f7 DBG \u9519\u8bef\u53f7 \u9519\u8bef\u53f7","title":"\u82af\u7247\u52d8\u8bef\u8868"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_1","text":"","title":"\u82af\u7247\u52d8\u8bef\u8868"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#flexcan","text":"","title":"FlexCAN"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#err005829-flexcan","text":"","title":"ERR005829  FlexCAN\u4e0d\u4f20\u8f93\u5728\u4ef2\u88c1\u8fc7\u7a0b\u4e2d\u7684\u7279\u5b9a\u65f6\u523b\u542f\u7528\u4f20\u8f93\u7684\u6d88\u606f"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_2","text":"FlexCAN\u4e0d\u4f20\u8f93\u5728\u4ef2\u88c1\u8fc7\u7a0b\u4e2d\u7684\u7279\u5b9a\u65f6\u523b\u542f\u7528\u4f20\u8f93\u7684\u6d88\u606f\u3002\u51fa\u73b0\u8be5\u95ee\u9898\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6: \u2022\u53ea\u914d\u7f6e\u4e00\u4e2a\u6d88\u606f\u7f13\u51b2\u533a\u6765\u4f20\u8f93 \u2022\u5728\u4ef2\u88c1\u8fc7\u7a0b\u4e2d\u7684\u7279\u5b9a\u65f6\u949f\u671f\u95f4\uff0c\u4f7f\u6d88\u606f\u7f13\u51b2\u533a\u80fd\u591f\u4f20\u8f93\u7684\u5199\u64cd\u4f5c(\u5199\u5728\u63a7\u5236/\u72b6\u6001\u5b57\u4e0a)\u53d1\u751f\u3002 \u2022\u5728\u6b64\u4ef2\u88c1\u8fc7\u7a0b\u53d1\u751f\u540e\uff0c\u603b\u7ebf\u8fdb\u5165Idle\u72b6\u6001\uff0c\u5e76\u4e14\u603b\u7ebf\u4e0a\u6ca1\u6709\u6536\u5230\u65b0\u6d88\u606f\u3002 \u4f8b\u5982: 1. \u6d88\u606f\u7f13\u51b2\u533a13\u5728RxIntermission\u4e0a\u88ab\u505c\u7528(\u5c060x0\u5199\u5165CODE\u5b57\u6bb5) \u63a7\u5236/\u72b6\u6001\u5b57)[\u5148\u5199\u5165CODE] 2. \u91cd\u65b0\u914d\u7f6eID\u548cdata\u5b57\u6bb5 3. \u542f\u7528\u6d88\u606f\u7f13\u51b2\u533a13\u5728BusIdle\u4e0a\u4f20\u8f93(\u5728CODE\u5b57\u6bb5\u4e0a\u51990xC)[\u7b2c\u4e8c\u6b21\u5199\u5165CODE] 4. CAN\u603b\u7ebf\u4fdd\u6301\u5728\u7a7a\u95f2\u72b6\u6001 5. \u6ca1\u6709\u4ece\u4efb\u4f55\u6d88\u606f\u7f13\u51b2\u533a\u5199\u5165\u63a7\u5236/\u72b6\u6001\u3002 \u5728\u7b2c\u4e8c\u6b21\u5199\u5165CODE(\u6b65\u9aa43)\u671f\u95f4\uff0c\u5199\u5165\u5fc5\u987b\u5728\u4ef2\u88c1\u8fdb\u7a0b\u626b\u63cf\u5f53\u524d\u6d88\u606f\u7f13\u51b2\u533a13\u4e4b\u524d\u4e00\u4e2a\u65f6\u949f\u53d1\u751f\u3002\u5728\u672c\u4f8b\u4e2d\uff0c\u5b83\u4e0d\u68c0\u6d4b\u65b0\u4ee3\u7801 (0xC)\u5e76\u4e14\u6ca1\u6709\u5b89\u6392\u65b0\u7684\u4ef2\u88c1\u3002 \u53ea\u6709\u5f53\u6d88\u606f\u6d41\u91cf\u505c\u6b62\u5e76\u4e14can\u603b\u7ebf\u5728\u4e0a\u8ff0\u4e8b\u4ef6\u5e8f\u5217\u4e4b\u540e\u8fdb\u5165Idle\u72b6\u6001\u65f6\uff0c\u624d\u80fd\u68c0\u6d4b\u5230\u95ee\u9898\u3002 \u5982\u679c\u7b26\u5408\u4ee5\u4e0b\u4efb\u4f55\u6761\u4ef6\uff0c\u5219\u6ca1\u6709\u95ee\u9898: \u2022\u4efb\u4f55\u6d88\u606f\u7f13\u51b2\u533a(Tx\u6216Rx)\u90fd\u88ab\u91cd\u65b0\u914d\u7f6e(\u901a\u8fc7\u5199\u5165\u5176CS\u5b57\u6bb5) \u5e55\u95f4\u4f11\u606f\u3002 \u2022\u6709\u5176\u4ed6\u914d\u7f6e\u7684\u6d88\u606f\u7f13\u51b2\u533a\u8981\u4f20\u8f93\u3002 \u2022\u4efb\u4f55\u5916\u90e8\u8282\u70b9\u53d1\u9001\u7684\u65b0\u4f20\u5165\u6d88\u606f\u5728\u4e2d\u573a\u4f11\u606f\u5b57\u6bb5\u4e4b\u540e\u5f00\u59cb\u3002","title":"\u63cf\u8ff0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_3","text":"\u82af\u72471 \u82af\u72472 \u82af\u72473","title":"\u53d7\u5f71\u54cd\u82af\u7247"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_4","text":"\u8981\u4f20\u8f93CAN\u5e27\uff0cCPU\u5fc5\u987b\u901a\u8fc7\u6267\u884c\u4ee5\u4e0b\u6807\u51c6\u76845\u4e2a\u6b65\u9aa4\u4ee5\u751f\u6210\u7528\u4e8e\u4f20\u8f93\u7684\u6d88\u606f\u7f13\u51b2\u533a\uff1a 1. \u68c0\u67e5\u662f\u5426\u8bbe\u7f6e\u4e86\u76f8\u5e94\u7684\u4e2d\u65ad\u4f4d\u5e76\u6e05\u9664\u5b83 2. \u5982\u679c\u6d88\u606f\u7f13\u51b2\u533a\u5904\u4e8e\u6d3b\u52a8\u72b6\u6001\uff08\u4f20\u8f93\u6302\u8d77\uff09\uff0c\u8bf7\u5c06\u4e2d\u6b62\u4ee3\u7801\uff080b1001\uff09\u5199\u5165\u63a7\u5236/\u72b6\u6001\u5b57\u7684CODE\u5b57\u6bb5\uff0c\u4ee5\u8bf7\u6c42\u4e2d\u6b62\u4f20\u8f93\u3002\u901a\u8fc7\u8f6e\u8be2IFLAG\u5bc4\u5b58\u5668\u6216\u4e2d\u65ad\u8bf7\u6c42\uff08\u5982\u679c\u7531\u76f8\u5e94\u7684IMASK\u542f\u7528\uff09\u6765\u7b49\u5f85\u65ad\u8a00\u76f8\u5e94\u7684IFLAG\u3002\u7136\u540e\u8bfb\u56deCODE\u5b57\u6bb5\u4ee5\u68c0\u67e5\u4f20\u8f93\u662f\u5426\u5df2\u4e2d\u6b62\u6216\u5df2\u4f20\u8f93\u3002\u5982\u679c\u9700\u8981\u5411\u540e\u517c\u5bb9\uff08MCR[AEN]\u4f4d\u88ab\u5426\u5b9a\uff09\uff0c\u53ea\u9700\u5c06\u975e\u6d3b\u52a8\u4ee3\u7801\uff080b1000\uff09\u5199\u5165CODE\u5b57\u6bb5\u4ee5\u505c\u7528\u6d88\u606f\u7f13\u51b2\u533a\uff0c\u4f46\u968f\u540e\u53ef\u80fd\u4f1a\u5728\u4e0d\u901a\u77e5\u7684\u60c5\u51b5\u4e0b\u4f20\u8f93\u6302\u8d77\u7684\u5e27\u3002 3. \u5199ID\u5b57 4. \u5199\u5165\u6570\u636e\u5b57\u8282 5. \u5199\u5165\u63a7\u5236/\u72b6\u6001\u5b57\u7684DLC\u3001Control\u548cCODE\u5b57\u6bb5\u4ee5\u6fc0\u6d3b\u6d88\u606f\u7f13\u51b2\u533a 6. \u8be5\u89e3\u51b3\u65b9\u6cd5\u5305\u62ec\u6267\u884c\u4e24\u4e2a\u989d\u5916\u7684\u6b65\u9aa4\uff1a 7. \u5c06\u7b2c\u4e00\u4e2a\u6709\u6548\u90ae\u7bb1\u4fdd\u7559\u4e3a\u975e\u6d3b\u52a8\u90ae\u7bb1\uff08CODE = 0b1000\uff09\u3002\u5982\u679c\u7981\u7528\u4e86RX FIFO\uff0c\u5219\u6b64\u90ae\u7bb1\u5fc5\u987b\u662f\u90ae\u4ef6\u7f13\u51b2\u533a0\u3002\u5426\u5219\uff0c\u53ef\u4ee5\u4f7f\u7528\u82af\u7247\u53c2\u8003\u624b\u518cFlexCAN\u7ae0\u8282\u4e2d\u7684\u201cRX FIFO\u6ee4\u6ce2\u5668\u201d\u8868\u627e\u5230\u7b2c\u4e00\u4e2a\u6709\u6548\u90ae\u7bb1 8. \u5c06\u4e24\u6b21\u975e\u6d3b\u52a8\u4ee3\u7801\uff080b1000\uff09\u5199\u5165\u7b2c\u4e00\u4e2a\u6709\u6548\u90ae\u7bb1","title":"\u89e3\u51b3\u529e\u6cd5"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#err006032-canidcan","text":"","title":"ERR006032  \u5f53CAN\u603b\u7ebf\u5904\u4e8e\u603b\u7ebf\u7a7a\u95f2\u72b6\u6001\u65f6\uff0c\u6b63\u5728\u4f20\u8f93\u7684\u6d88\u606f\u7f13\u51b2\u533a\u4e2d\u6b62\u6216\u505c\u7528\u65f6\uff0c\u5177\u6709\u9519\u8befID\u6216\u6709\u6548\u8d1f\u8f7d\u7684\u5e27\u88ab\u4f20\u8f93\u5230CAN\u603b\u7ebf\u4e2d"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_5","text":"\u5982\u679c\u5728FlexCAN\u5904\u4e8e\u603b\u7ebf\u7a7a\u95f2\u72b6\u6001\u65f6\u914d\u7f6e\u4e86\u4e00\u4e2a\u6216\u591a\u4e2a\u6d88\u606f\u7f13\u51b2\u533a\uff08MB\uff09\u8fdb\u884c\u4f20\u8f93\uff0c\u5e76\u4e14\u9009\u62e9\u4f20\u8f93\u7684MB\u5728\u5f00\u59cb\u4f20\u8f93\u7684\u786e\u5207\u65f6\u523b\u88ab\u4e2d\u6b62\u6216\u505c\u7528\uff0c\u5219FlexCAN\u6a21\u5757\u53ef\u80fd\u4f1a\u4f20\u8f93\u4e0d\u6b63\u786e\u7684\u4fe1\u606f\u3002\u8fd9\u5c06\u5bfc\u81f4FlexCAN\u53d1\u9001\u8bed\u6cd5\u6b63\u786e\u7684\u6d88\u606f\uff0c\u4f46\u4f7f\u7528\u4e0d\u6b63\u786e\u7684ID\u6216\u6570\u636e\u5b57\u6bb5\u3002CRC\u4fe1\u606f\u5c06\u57fa\u4e8e\u4e0d\u6b63\u786e\u7684\u6570\u636e\uff08\u4ee5\u9632\u6570\u636e\u53d7\u5230\u5f71\u54cd\uff09\u8fdb\u884c\u8ba1\u7b97\uff0c\u4e14\u5e27\u4e2d\u7684\u6240\u6709\u5176\u4ed6\u5b57\u6bb5\u90fd\u5c06\u662f\u6b63\u786e\u7684\u3002 \u5728\u4f20\u8f93\u4e00\u5e27\u65f6\uff0c\u95ee\u9898\u53d1\u751f\u7684\u6982\u7387\u4ec5\u9650\u4e8e\u4e00\u4e2aCAN\u4f4d\uff0c\u5728\u975e\u5e38\u7279\u5b9a\u7684\u591a\u8d77\u4e8b\u4ef6\u7ec4\u5408\u4e0b\uff1a 1. Bug\u4e8b\u4ef6\u53ef\u80fd\u53d1\u751f\u5728\u6bcf\u5e27\u4e00\u4e2a\u7279\u5b9a\u7684CAN\u4f4d\u4e2d 2. CAN\u603b\u7ebf\u5fc5\u987b\u5904\u4e8e\u603b\u7ebf\u7a7a\u95f2\u72b6\u6001 3. \u5fc5\u987b\u89e6\u53d1CPU\u4ee5\u914d\u7f6e\u4e00\u4e2a\u6216\u591a\u4e2aMB\u4ee5\u5728\u603b\u7ebf\u7a7a\u95f2\u72b6\u6001\u4e0b\u8fdb\u884c\u4f20\u8f93 4. \u5728\u6b65\u9aa43\u4e2d\u5f00\u59cb\u914d\u7f6e\u7684\u77ed\u65f6\u95f4\u5185\uff0c\u5fc5\u987b\u89e6\u53d1CPU\uff0c\u901a\u8fc7\u505c\u7528\u5220\u9664\u521a\u521a\u914d\u7f6e\u7684 MB\u3002 \u7efc\u4e0a\u6240\u8ff0\uff0c\u53d1\u751f\u7684\u6982\u7387\u975e\u5e38\u4f4e\uff0c\u5927\u7ea6\u4e3a1/1000\u4e07\u3002\u6b64\u5916\uff0c\u5728\u6b63\u5e38\u5e94\u7528\u4e2d\u4e0d\u592a\u53ef\u80fd\u53d1\u751f\u914d\u7f6eMB\uff0c\u7136\u540e\u5728\u77ed\u65f6\u95f4\u5185\u505c\u7528\u76f8\u540cMB\u7684\u8fc7\u7a0b\u3002 \u5728\u5b9e\u8df5\u4e2d\uff0c\u5982\u679cCPU\u4fdd\u8bc1\u4f20\u8f93\u914d\u7f6e\u7684\u4efb\u4f55MB\u5c06\u5728\u4e0b\u4e00\u5e27\u4e2d\u6b62\u6216\u505c\u7528\uff0c\u5219\u6ca1\u6709\u95ee\u9898","title":"\u63cf\u8ff0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_6","text":"\u82af\u72471 \u82af\u72472 \u82af\u72473","title":"\u53d7\u5f71\u54cd\u82af\u7247"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_7","text":"\u5f53CAN\u603b\u7ebf\u5904\u4e8e\u603b\u7ebf\u7a7a\u95f2\u72b6\u6001\u65f6\uff0c\u7528\u6237\u53ef\u4ee5\u901a\u8fc7\u963b\u6b62\u5bf9\u4f20\u8f93\u8fdb\u884cMB\u914d\u7f6e\u6765\u907f\u514d\u8be5\u9519\u8bef\u3002FlexCAN\u8c03\u8bd5\u5bc4\u5b58\u5668\u4e2d\u6709\u4e00\u4e9b\u4f4d\u53ef\u7528\u4e8e\u786e\u5b9aCAN\u603b\u7ebf\u4f55\u65f6\u5904\u4e8e\u7a7a\u95f2\u72b6\u6001\u3002 \u8be5\u8c03\u8bd5\u5bc4\u5b58\u5668\u4f4d\u4e8e\uff1aFlexCAN\u8c03\u8bd51\u5bc4\u5b58\u5668\uff08CAN_DBG1\uff09- Base + 0x0058\u3002CAN_DBG1\u5bc4\u5b58\u5668\u7684CAN\u6709\u9650\u72b6\u6001\u673a\uff08CFSM\uff09\u4f4d\u76d1\u63a7FlexCAN\u7684\u5185\u90e8\u72b6\u6001\u3002CFSM\u662fCAN_DBG1\u5bc4\u5b58\u5668\u4e2d\u516d\u4e2a\u6700\u4f4e\u4f4d\u3002CAN\u4f4d\u6570\uff08CBN\uff09\u662fCAN_DBG1\u5bc4\u5b58\u5668\u4e2dbit\u4f4d3\u81f37\u5904\u7684\u4e94\u4f4d\u957f\u5b57\u6bb5\uff0c\u7528\u4e8e\u6307\u793a\u7ed9\u5b9aCFSM\u72b6\u6001\u503c\u4e2d\u7684\u5f53\u524d\u4f4d\u6570\u3002 CAN_DBG1.CFSM = 0x0000_003F CAN_DBG1.CBN = 0x1F00_0000 \u9700\u8981\u67e5\u627e\u51e0\u4e2a\u5185\u90e8\u72b6\u6001\u503c\uff0c\u4e0b\u9762\u5217\u51fa\u4e86\u5b83\u4eec\u76f8\u5e94\u7684CFSM\u503c RXINTERMISSION - 0x2F TXINTERMISSION - 0x14 BUSIDLE - 0x02 \u5fc5\u987b\u6267\u884c\u4ee5\u4e0b\u8fc7\u7a0b\u6765\u914d\u7f6eMB\u4f20\u8f93\uff1a 1. \u7981\u7528\u6240\u6709\u4e2d\u65ad 2. \u8bfb\u53d6CAN_DBG1.CFSM\u548cCAN_DBG1.CBN\u5b57\u6bb5 3. \u68c0\u67e5CFSM\u503c\u662f\u5426\u4e3aBUSIDLE\u3001RXINTERMISSION\u6216TXINTERMISSION \u5bf9\u4e8e\u540e\u4e24\u4e2a\u503c\uff0c\u8fd8\u8981\u68c0\u67e5CBN\u503c\u662f\u5426\u4e3a3\uff0c\u4ee5\u786e\u5b9a\u914d\u5bf9\u6761\u4ef6RXINTERMISSION bit 3\u6216TXINTERMISSION bit 3\uff0c\u5e76\u6309\u5982\u4e0b\u6240\u8ff0\u8fdb\u884c\u5904\u7406\u3002 3.1 \u5982\u679cCAN_DBG1\u5b57\u6bb5\u6307\u793a BUSIDLE\uff0c\u5219\u7b49\u5f85N\u4e2aCPU\u65f6\u949f 3.2 \u5426\u5219\uff0c\u82e5CAN_DBG1\u5982\u679c\u5b57\u6bb5\u6307\u793aRXINTERMISSION\u4f4d3\u6216TXINTERMISSION\u4f4d3\uff0c\u5219\u7b49\u5f85CFSM\u4e0eRXINTERMISSION\u6216TXINTERMISSION\u4e0d\u540c 4. \u5c060x0\u5199\u5165CS\u5b57\u7684\u4ee3\u7801\u5b57\u6bb5 5. \u4f7f\u80fd\u6240\u6709\u4e2d\u65ad 6. \u5199\u5165ID\u5b57 7. \u5199\u5165DATA\u5b57 8. \u5c060xC\u5199\u5165CS\u5b57\u7684\u4ee3\u7801\u5b57\u6bb5","title":"\u89e3\u51b3\u529e\u6cd5"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#err009527","text":"","title":"ERR009527 \u4f20\u8f93\u4e2d\u6b62\u673a\u5236\u53ef\u80fd\u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_8","text":"\u7075\u6d3b\u63a7\u5236\u5668\u5c40\u57df\u7f51\uff08FlexCAN\uff09\u65e0\u6cd5\u4e2d\u6b62\u4f20\u8f93\u5e27\uff0c\u5728\u4ee5\u4e0b\u60c5\u51b5\u4e0b\uff0c\u4e2d\u6b62\u8fc7\u7a0b\u53ef\u80fd\u4fdd\u6301\u5f85\u5b9a\u72b6\u6001\uff1a 1. \u5982\u679c\u5728FlexCAN\u63a5\u6536\u8fdc\u7a0b\u5e27\u65f6\u53d1\u751f\u6302\u8d77\u7684\u4e2d\u6b62\u8bf7\u6c42 2. \u5f53\u5e27\u5728\u5e27\u63a5\u6536\u540e\u7684\u91cd\u8f7d\u5e27\u671f\u95f4\u4e2d\u6b62\u65f6 3. \u5f53FlexCAN\u521a\u521a\u5f00\u59cb\u4f20\u8f93\u65f6\u5c31\u8bf7\u6c42\u4e2d\u6b62 4. \u5f53\u53d1\u751f\u51bb\u7ed3\u6a21\u5f0f\u8bf7\u6c42\u4e14FlexCAN\u521a\u521a\u5f00\u59cb\u4f20\u8f93\u65f6","title":"\u63cf\u8ff0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_9","text":"\u82af\u72471 \u82af\u72472 \u82af\u72473","title":"\u53d7\u5f71\u54cd\u82af\u7247"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_10","text":"\u4f7f\u7528\u90ae\u7bb1\u505c\u7528\u673a\u5236\u800c\u4e0d\u662f\u4f20\u8f93\u4e2d\u6b62\u673a\u5236\u3002\u6a21\u5757\u914d\u7f6e\u5bc4\u5b58\u5668\u7684\u4e2d\u6b62\u4f7f\u80fd\uff08AEN\uff09\u4f4d\u53ef\u4ee5\u4fdd\u6301\u6e05\u9664\u72b6\u6001\uff0c\u5e76\u4e14\u4e2d\u6b62\u4ee3\u7801\u503c\u201c0b1001\u201d\u4e0d\u80fd\u88ab\u5199\u5165\u6d88\u606f\u7f13\u51b2\u533a\u63a7\u5236\u548c\u72b6\u6001\u5b57\u7684CODE\u5b57\u6bb5\u3002","title":"\u89e3\u51b3\u529e\u6cd5"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#err009595","text":"","title":"ERR009595 \u5982\u679c\u5728\u603b\u7ebf\u5173\u95ed\u72b6\u6001\u4e0b\u8fdb\u5165\u51bb\u7ed3\u6a21\u5f0f\u6216\u4f4e\u529f\u8017\u6a21\u5f0f\uff0c\u5219\u5e27\u53ef\u80fd\u635f\u574f"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_11","text":"\u5982\u679c\u6a21\u5757\u914d\u7f6e\u5bc4\u5b58\u5668\uff08MCR\uff09\u7684\u51bb\u7ed3\u4f7f\u80fd\u4f4d\uff08FRZ\uff09\u88ab\u7f6e\u4f4d\uff0c\u5e76\u4e14\u5728\u603b\u7ebf\u5173\u95ed\u72b6\u6001\u671f\u95f4\u901a\u8fc7\u7f6e\u4f4dMCR\u5bc4\u5b58\u5668\u7684\u505c\u6b62\u4f4d\uff08HALT\uff09\u6765\u8bf7\u6c42\u51bb\u7ed3\u6a21\u5f0f\uff0c\u5219\u9000\u51fa\u603b\u7ebf\u5173\u95ed\u6761\u4ef6\u540e\u7684\u4f20\u8f93\u5c06\u88ab\u635f\u574f\u3002\u4ec5\u5f53\u4f20\u8f93\u5728\u51bb\u7ed3\u6a21\u5f0f\u8bf7\u6c42\u4e4b\u524d\u5904\u4e8e\u6302\u8d77\u72b6\u6001\u65f6\uff0c\u624d\u4f1a\u51fa\u73b0\u6b64\u95ee\u9898\u3002\u6b64\u5916\uff0c\u5982\u679c\u8bf7\u6c42\u4f4e\u529f\u8017\u6a21\u5f0f\u800c\u4e0d\u662f\u51bb\u7ed3\u6a21\u5f0f\uff0c\u4e5f\u4f1a\u51fa\u73b0\u540c\u6837\u7684\u95ee\u9898\u3002","title":"\u63cf\u8ff0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_12","text":"\u82af\u72471 \u82af\u72472 \u82af\u72473","title":"\u53d7\u5f71\u54cd\u82af\u7247"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_13","text":"\u89e3\u51b3\u65b9\u6cd5\u53d6\u51b3\u4e8e\u5728\u8bf7\u6c42\u51bb\u7ed3\u6a21\u5f0f\u6216\u4f4e\u529f\u8017\u6a21\u5f0f\u4e4b\u524d\u662f\u5426\u53d1\u751fBus-Off\u6761\u4ef6\u3002 \u8fdb\u5165\u51bb\u7ed3\u6a21\u5f0f\u7684\u8fc7\u7a0b\uff1a 1. \u5728\u6a21\u5757\u63a7\u5236\u5bc4\u5b58\u5668\uff08MCR\uff09\u4e2d\u7f6e\u4f4d\u51bb\u7ed3\u4f7f\u80fd\u4f4d\uff08FRZ\uff09 2. \u68c0\u67e5MCR\u5bc4\u5b58\u5668\u7684\u6a21\u5757\u7981\u7528\u4f4d\uff08MDIS\uff09\u662f\u5426\u7f6e\u4f4d\u3002\u5982\u679c\u7f6e\u4f4d\uff0c\u6e05\u9664MDIS\u4f4d 3. \u8f6e\u8be2MCR\u5bc4\u5b58\u5668\uff0c\u76f4\u5230MCR\u4e2d\u7684\u4f4e\u529f\u8017\u6a21\u5f0f\u786e\u8ba4\uff08LPMACK\uff09\u4f4d\u88ab\u6e05\u9664\uff08\u8f6f\u4ef6\u5b9e\u73b0\u7684\u8d85\u65f6\u4e3a\u4e24\u4e2aCAN\u4f4d\u957f\u5ea6\uff09 4. \u8bfb\u53d6\u9519\u8bef\u548c\u72b6\u60011\u5bc4\u5b58\u5668\uff08ESR1\uff09\u4e2d\u7684\u6545\u969c\u9650\u5236\u72b6\u6001\uff08FLTCONF\uff09\u5b57\u6bb5\uff0c\u4ee5\u68c0\u67e5FlexCAN\u662f\u5426\u5904\u4e8e\u603b\u7ebf\u5173\u95ed\u72b6\u6001\u3002\u5982\u679c\u662f\uff0c\u8bf7\u8f6c\u5230\u6b65\u9aa45A\u3002\u5426\u5219\uff0c\u8bf7\u8f6c\u5230\u6b65\u9aa45B\u3002 5A. \u7f6e\u4f4dMCR\u5bc4\u5b58\u5668\u7684\u8f6f\u4ef6\u590d\u4f4d\u4f4d\uff08\uff08SOFTRST\uff09 6A. \u8f6e\u8be2MCR\u5bc4\u5b58\u5668\uff0c\u76f4\u5230\u8f6f\u4ef6\u590d\u4f4d\uff08SOFTRST\uff09\u4f4d\u88ab\u6e05\u9664\uff08\u8f6f\u4ef6\u5b9e\u73b0\u7684\u8d85\u65f6\u4e3a\u4e24\u4e2aCAN\u4f4d\u957f\u5ea6 7A. \u8f6e\u8be2MCR\u5bc4\u5b58\u5668\uff0c\u76f4\u5230\u7f6e\u4f4d\u51bb\u7ed3\u786e\u8ba4\uff08FRZACK\uff09\u4f4d\uff08\u8f6f\u4ef6\u5b9e\u73b0\u7684\u8d85\u65f6\u4e3a\u4e24\u4e2aCAN\u4f4d\u957f\u5ea6\uff09 8A. \u91cd\u65b0\u914d\u7f6eMCR\u5bc4\u5b58\u5668 9A. \u91cd\u65b0\u914d\u7f6e\u6240\u6709\u4e2d\u65ad\u63a9\u7801\u5bc4\u5b58\u5668\uff08IMASKn\uff09 5B. \u7f6e\u4f4dMCR\u5bc4\u5b58\u5668\u7684Halt FlexCAN\uff08HALT\uff09\u4f4d 6B. \u8f6e\u8be2MCR\u5bc4\u5b58\u5668\uff0c\u76f4\u5230\u7f6e\u4f4d\u51bb\u7ed3\u786e\u8ba4\uff08FRZACK\uff09\u4f4d\uff08\u8f6f\u4ef6\u5b9e\u73b0\u7684\u8d85\u65f6\u4e3a178\u4e2aCAN\u4f4d\u957f\u5ea6\uff09 Note\uff01\u6b65\u9aa44\u548c\u6b65\u9aa45B\u4e4b\u95f4\u7684\u65f6\u95f4\u5fc5\u987b\u5c0f\u4e8e1353\u4e2aCAN\u4f4d\u5468\u671f\u3002 \u8fdb\u5165\u4f4e\u529f\u8017\u6a21\u5f0f\u7684\u6b65\u9aa4\uff1a 1. \u8fdb\u5165\u51bb\u7ed3\u6a21\u5f0f\uff08\u6267\u884c\u8fc7\u7a0b A\uff09 2. \u8bf7\u6c42\u4f4e\u529f\u8017\u6a21\u5f0f 3. \u8f6e\u8be2MCR\u5bc4\u5b58\u5668\uff0c\u76f4\u5230MCR\u5bc4\u5b58\u5668\u7684\u4f4e\u529f\u8017\u6a21\u5f0f\u786e\u8ba4\uff08LPMACK\uff09\u4f4d\u88ab\u7f6e1\uff08\u8f6f\u4ef6\u5b9e\u73b0\u7684\u8d85\u65f6\u4e3a\u4e24\u4e2aCAN\u4f4d\u957f\u5ea6\uff09","title":"\u89e3\u51b3\u529e\u6cd5"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#adc","text":"","title":"ADC"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_14","text":"","title":"\u9519\u8bef\u53f7"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_15","text":"","title":"\u9519\u8bef\u53f7"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#bkp","text":"","title":"BKP"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_16","text":"","title":"\u9519\u8bef\u53f7"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_17","text":"","title":"\u9519\u8bef\u53f7"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#crc","text":"","title":"CRC"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_18","text":"","title":"\u9519\u8bef\u53f7"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_19","text":"","title":"\u9519\u8bef\u53f7"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#dbg","text":"","title":"DBG"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_20","text":"","title":"\u9519\u8bef\u53f7"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E8%8A%AF%E7%89%87%E5%8B%98%E8%AF%AF%E8%A1%A8/#_21","text":"","title":"\u9519\u8bef\u53f7"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/","text":"LwIP\u534f\u8bae\u6808\u79fb\u690d\u7b14\u8bb0 LwIP\u534f\u8bae\u6808\u79fb\u690d\u7b14\u8bb0 LwIP\u7b80\u4ecb \u79fb\u690d\u63a5\u53e3\u89e3\u6790 \u79fb\u690dLwIP\u534f\u8bae\u6808 low_level_init\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0 low_level_output\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0 low_level_input\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0 ENET_IRQHandler\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u5b9e\u73b0 platform\u53c2\u6570\u53ca\u51fd\u6570\u5b9e\u73b0 \u6837\u4f8b\u8bf4\u660e lwip_tcp_client lwip_tcp_server lwip_udp_client lwip_udp_server \u7ed3\u8bed \u6ce8\u610f\u4e8b\u9879 LwIP\u7b80\u4ecb LwIP\u662f\u8f7b\u91cf\u5316\u7684TCP/IP\u534f\u8bae\uff0c\u7531\u745e\u5178\u8ba1\u7b97\u673a\u79d1\u5b66\u9662(SICS)\u7684Adam Dunkels \u5f00\u53d1\u7684\u4e00\u4e2a\u5c0f\u578b\u5f00\u6e90\u7684TCP/IP\u534f\u8bae\u6808\u3002LwIP\u5177\u6709\u9ad8\u5ea6\u53ef\u79fb\u690d\u6027\u3001\u4ee3\u7801\u5f00\u6e90\uff0c\u63d0\u4f9b\u4e86\u4e09\u79cd\u7f16\u7a0b\u63a5\u53e3\uff08API\uff09\uff1aRAW API\u3001NETCONN API \u548c Socket API\uff0c\u7528\u4e8e\u4e0eTCP/IP\u4ee3\u7801\u8fdb\u884c\u901a\u4fe1\u3002 \u901a\u8fc7\u5b98\u7f51\uff08http://savannah.nongnu.org/projects/lwip/\uff09\u53ef\u83b7\u53d6LwIP\u6e90\u7801\u5305\u53cacontrib\u5305\u3002\u6e90\u4ee3\u7801\u5305\u4e3b\u8981\u5305\u542bLwIP\u5185\u6838\u7684\u6e90\u7801\u6587\u4ef6\uff0ccontrib\u5305\u4e2d\u5305\u542b\u90e8\u5206\u79fb\u690d\u548c\u5e94\u7528LwIP\u7684demo\u3002contrib\u5305\u4e0d\u5c5e\u4e8eLwIP\u5185\u6838\u7684\u4e00\u90e8\u5206\uff0c\u4f46\u5f88\u6709\u53c2\u8003\u4ef7\u503c\u3002 \u4ee5lwip-2.1.2\u7248\u672c\u7684\u6e90\u7801\u5305\u4e3a\u4f8b\uff0c\u5982\u56fex\u6240\u793a\uff0c\u8be5\u6e90\u7801\u5305\u5206\u4e3a\u4e09\u90e8\u5206\uff0c src \u6587\u4ef6\u4e3aLWIP\u6e90\u4ee3\u7801\u6587\u4ef6\uff0c doc \u6587\u4ef6\u5305\u542bLwIP\u76f8\u5173\u6587\u6863\uff0c test \u4e3aLwIP\u6d4b\u8bd5\u6587\u4ef6\uff0c\u4f7f\u7528\u65f6\u4e3b\u8981\u5173\u6ce8\u4e8e src \u6587\u4ef6\u4e0b\u7684\u5185\u5bb9\u3002 LwIP\u5185\u6838\u662f\u7531\u4e00\u7cfb\u5217\u6a21\u5757\u7ec4\u5408\u800c\u6210\uff0c\u5305\u62ec TCP/IP \u534f\u8bae\u6808\u7684\u5404\u79cd\u534f\u8bae\u3001\u5185\u5b58\u7ba1\u7406\u3001\u6570\u636e\u5305\u7ba1\u7406\u3001\u7f51\u5361\u63a5\u53e3\u3001\u57fa\u7840\u529f\u80fd\u7c7b\u6a21\u5757\u3001API\u7b49\uff0c\u6784\u6210\u8fd9\u4e9b\u6a21\u5757\u7684\u6e90\u6587\u4ef6\u5c31\u5206\u5e03\u5728api\u3001apps\u3001core\u3001netif\u4e2d\uff0c\u5934\u6587\u4ef6\u5219\u6c47\u603b\u5728include\u4e2d\u3002 api\uff1aNETCONN API\u548cSocket API\u76f8\u5173\u7684\u6e90\u6587\u4ef6\uff0c\u53ea\u6709\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684\u73af\u5883\u4e2d\uff0c\u624d\u80fd\u88ab\u7f16\u8bd1 apps\uff1a\u5e94\u7528\u7a0b\u5e8f\u7684\u6e90\u6587\u4ef6\uff0c\u5305\u62ec\u5e38\u89c1\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u5982httpd\u3001mqtt\u3001tftp\u3001sntp\u3001snmp\u7b49 core\uff1aLwIP\u7684\u5185\u6838\u6e90\u6587\u4ef6 include\uff1aLwIP\u6240\u6709\u6a21\u5757\u5bf9\u5e94\u7684\u5934\u6587\u4ef6 netif\uff1a\u4e0e\u7f51\u5361\u79fb\u690d\u6709\u5173\u7684\u6587\u4ef6 LwIP-2.1.2\u6e90\u7801\u5305 \u79fb\u690d\u63a5\u53e3\u89e3\u6790 LwIP\u4f7f\u7528\u6570\u636e\u7ed3\u6784\u4f53netif\u6765\u63cf\u8ff0\u7f51\u5361\uff0c\u5e76\u63d0\u4f9b\u7edf\u4e00\u63a5\u53e3\uff0c\u9700\u8981\u4e0e\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u63a5\u53e3\u51fd\u6570\u7ed3\u5408\u4f7f\u7528\uff0c\u4f8b\u5982\u5e95\u5c42\u9a71\u52a8\u8d1f\u8d23\u5b8c\u6210\u7f51\u5361\u7684\u521d\u59cb\u5316\u3001\u7f51\u5361\u7684\u6570\u636e\u6536\u53d1\u7b49\uff0c\u5f53LwIP\u5185\u6838\u9700\u8981\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u5305\u65f6\uff0c\u5c31\u4f1a\u901a\u8fc7LWIP\u63d0\u4f9b\u7684\u63a5\u53e3\u51fd\u6570\u53bb\u8c03\u7528\u5e95\u5c42\u7f51\u5361\u7684\u53d1\u9001\u51fd\u6570\uff0c\u5c06\u6570\u636e\u7531\u786c\u4ef6\u63a5\u53e3\u4e0e\u8f6f\u4ef6\u5185\u6838\u8854\u63a5\u5728\u4e00\u8d77\u3002 contrib\u6587\u4ef6\u4e2d\u5305\u542b\u90e8\u5206\u53ef\u4f7f\u7528\u7684\u7f51\u5361\u79fb\u690d\u6a21\u677f\u6587\u4ef6\uff0c\u5176\u4e2dethernetif.c\u6587\u4ef6\uff08contrib-2.1.0\\examples\\ethernetif\u76ee\u5f55\u4e0b\u7684ethernetif.c\u6587\u4ef6\uff09\u4e3a\u5e95\u5c42\u63a5\u53e3\u9a71\u52a8\u7684\u6a21\u677f\uff0c\u4ee5 LibSamples \u4e3a\u4f8b\uff0c\u82e5\u8981\u57fa\u4e8e LibSample\u7684\u4ee5\u592a\u7f51\u9a71\u52a8\u79fb\u690dLwIP\uff0c\u5219\u9700\u53c2\u8003ethernetif.c\u6a21\u677f\uff0c\u6839\u636e\u4ee5\u592a\u7f51\u9a71\u52a8\u53ca\u6240\u9700\u914d\u7f6e\u8fdb\u884c\u4fee\u6539\uff0c\u5c06\u5e95\u5c42\u9a71\u52a8 ethernet \u76f8\u5173\u51fd\u6570\u586b\u5145\u5230LwIP\u6240\u9700\u7684\u6307\u5b9a\u529f\u80fd\u51fd\u6570\u4e2d\u3002 ethernetif.c\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u901a\u5e38\u4e3a\u4e0e\u786c\u4ef6\u6253\u4ea4\u9053\u7684\u5e95\u5c42\u51fd\u6570\uff0c\u5f53\u6709\u6570\u636e\u9700\u8981\u901a\u8fc7\u7f51\u5361\u63a5\u6536\u6216\u8005\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\u5c31\u4f1a\u88ab\u8c03\u7528\uff0c\u7ecf\u8fc7LwIP\u534f\u8bae\u6808\u5185\u90e8\u8fdb\u884c\u5904\u7406\u540e\uff0c\u4ece\u5e94\u7528\u5c42\u5c31\u80fd\u5f97\u5230\u6570\u636e\u6216\u8005\u53ef\u4ee5\u53d1\u9001\u6570\u636e\u3002\u8be5\u6587\u4ef6\u4e2d\u5305\u62ec\u51fd\u6570\uff1alow_level_init()\u3001low_level_output()\u3001low_level_input()\u3001ethernetif_input()\u548cethernetif_init()\u51fd\u6570\u3002 ethernetif_init() LwIP\u4e2d\u9ed8\u8ba4\u7684\u7f51\u5361\u521d\u59cb\u5316\u51fd\u6570\uff0c\u5185\u90e8\u5c01\u88c5\u4e86low_level_init()\u51fd\u6570 ethernetif_input() \u8be5\u51fd\u6570\u7528\u4e8e\u63a5\u6536\u7f51\u5361\u6570\u636e\uff0c\u5185\u90e8\u5c01\u88c5\u4e86low_level_input()\u51fd\u6570\uff0c\u5728\u63a5\u6536\u5b8c\u6bd5\u65f6\uff0c\u5c06\u6570\u636e\u901a\u8fc7pbuf\u9012\u4ea4\u7ed9\u4e0a\u5c42\u3002 low_level_init() low_level_init()\u51fd\u6570\u4e3b\u8981\u662f\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u5bf9\u7f51\u5361\u8fdb\u884c\u4e00\u7cfb\u5217\u7684\u521d\u59cb\u5316\u5de5\u4f5c\uff0c\u4f8b\u5982\uff1a\u521d\u59cb\u5316MAC\u5730\u5740\u3001\u957f\u5ea6\uff0c \u8bbe\u7f6e\u6700\u5927\u4f20\u8f93\u5305\u7684\u5927\u5c0f\uff0c\u8bbe\u7f6e\u7f51\u5361\u7684\u5c5e\u6027\u5b57\u6bb5\u7b49\u529f\u80fd\u3002 \u8be5\u51fd\u6570\u4e2d\u9700\u8981\u8c03\u7528\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u4e2d\u7684\u76f8\u5173\u521d\u59cb\u5316\u51fd\u6570\uff0c\u4ee5 MindSDK \u4e3a\u4f8b\uff0c\u8be5\u51fd\u6570\u9700\u8981\u8c03\u7528\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8 enet_0 \u7684 PHY\u3001MAC\u3001DMA\u76f8\u5173\u521d\u59cb\u5316\u51fd\u6570\u5e76\u8fdb\u884c\u914d\u7f6e\u3002 low_level_output() \u8be5\u51fd\u6570\u7528\u4e8e\u5b9e\u73b0\u7f51\u5361\u53d1\u9001\u6570\u636e\uff0c\u662f\u4e00\u4e2a\u5e95\u5c42\u9a71\u52a8\u51fd\u6570\uff0c\u9700\u6839\u636e\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u8fdb\u884c\u76f8\u5e94\u4fee\u6539\uff0c\u82e5\u60f3\u901a\u8fc7\u4e00\u4e2a\u7f51\u5361\u53d1\u9001\u6570\u636e\uff0c\u5219\u9700\u8981\u5c06\u8be5\u6570\u636e\u4f20\u5165LwIP\u5185\u6838\u4e2d\uff0c\u7ecf\u8fc7\u5c42\u5c42\u5c01\u88c5\u6700\u540e\u5b58\u50a8\u5728pbuf\u6570\u636e\u5305\u4e2d\uff0c\u9700\u6ce8\u610fpbuf\u4ee5\u94fe\u8868\u7684\u5f62\u5f0f\u5b58\u5728\uff0c\u6570\u636e\u53d1\u9001\u65f6\u662f\u4ee5\u4e00\u6574\u4e2a\u6570\u636e\u5305\u5168\u90e8\u53d1\u9001\u7684\u3002 low_level_input() low_level_input()\u51fd\u6570\u7528\u4e8e\u4ece\u7f51\u5361\u4e2d\u63a5\u6536\u4e00\u4e2a\u6570\u636e\u5305\uff0c\u5e76\u5c06\u8be5\u6570\u636e\u5305\u5c01\u88c5\u5728pbuf\u4e2d\u9012\u4ea4\u7ed9\u4e0a\u5c42\uff0c\u8be5\u51fd\u6570\u9700\u8981\u8c03\u7528\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u4e2d\u7684\u63a5\u6536\u51fd\u6570\u3002 \u79fb\u690dLwIP\u534f\u8bae\u6808 \u57fa\u4e8eLibSamples\u7684\u4ee5\u592a\u7f51\u9a71\u52a8\u5bf9LwIP\u8fdb\u884c\u79fb\u690d\uff0c\u9700\u5148\u5c06LwIP\u6e90\u6587\u4ef6\u4e2d\u7684\u90e8\u5206\u6587\u4ef6\u6dfb\u52a0\u5230LibSamples\u4e2d\uff0c\u5982\uff1a src \u6e90\u6587\u4ef6\u3001 include \u5934\u6587\u4ef6\u3002 \u82e5\u60f3\u4ee4LwIP\u8fd0\u884c\uff0c\u8fd8\u9700\u8865\u5145contrib\u6587\u4ef6\u4e2d\u90e8\u5206\u5185\u5bb9\uff0c\u5982\u56fex\u6240\u793a\uff0c\u7531\u4e8e\u90e8\u5206\u6e90\u6587\u4ef6\u4e2d\u4f7f\u7528\u5934\u6587\u4ef6\u5199\u6cd5\u4e3a\u201darch/xx\u201d\uff0c\u56e0\u6b64\uff0c\u5728src\u6587\u4ef6\u4e0b\u65b0\u5efaarch\u6587\u4ef6\uff0c\u5e76\u5c06\u9700\u8981\u4fee\u6539\u7684\u6a21\u677f\u6587\u4ef6\u53cacontrib\u4e2d\u7684\u90e8\u5206\u63a5\u53e3\u6587\u4ef6\u653e\u5165arch\u6587\u4ef6\u4e2d\u3002 ethernetif.c\u7f51\u5361\u79fb\u690d\u6a21\u677f\u6587\u4ef6 cc.h\u6587\u4ef6\u4e3b\u8981\u5b8c\u6210\u534f\u8bae\u6808\u5185\u90e8\u4f7f\u7528\u7684\u6570\u636e\u7c7b\u578b\u7684\u5b9a\u4e49 lwipopts.h\u6587\u4ef6\u5305\u542b\u4e86\u7528\u6237\u5bf9\u534f\u8bae\u6808\u5185\u6838\u53c2\u6570\u8fdb\u884c\u7684\u914d\u7f6e\uff0c\u82e5\u672a\u5728lwipopts.h\u6587\u4ef6\u4e2d\u8fdb\u884c\u914d\u7f6e\uff0c\u5219LwIP\u4f1a\u4f7f\u7528opt.h\u4e2d\u7684\u9ed8\u8ba4\u53c2\u6570 perf.h\u6587\u4ef6\u662f\u5b9e\u73b0\u4e0e\u7cfb\u901a\u901a\u8ba1\u548c\u6d4b\u91cf\u76f8\u5173\u7684\u529f\u80fd\uff0c\u82e5\u672a\u4f7f\u7528\u8be5\u529f\u80fd\uff0c\u5219\u65e0\u9700\u4fee\u6539 bpstruct.h\u3001epstruct.h\u7531contrib\u6587\u4ef6\u4e0b\u7684ports\u6587\u4ef6\u6240\u63d0\u4f9b\uff0c\u5c5e\u4e8e\u5806\u6808\u7684\u4e00\u90e8\u5206\uff0c\u65e0\u9700\u4fee\u6539 \u56fex LWIP\u79fb\u690d\u6240\u9700\u90e8\u5206\u6587\u4ef6 lwipopts.h\u6587\u4ef6\u4e2d\u9700\u8981\u6839\u636e\u662f\u5426\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u6a21\u62df\u5c42\u3001\u5806\u5185\u5b58\u5927\u5c0f\u3001\u662f\u5426\u4f7f\u7528TCP\u53caTCP\u76f8\u5173\u914d\u7f6e\u7b49\u8fdb\u884c\u5b8f\u5b9a\u4e49\u914d\u7f6e\uff0c\u4f8b\u5982\uff1a\u5b8f\u5b9a\u4e49 NO_SYS \u8868\u793a\u65e0\u64cd\u4f5c\u7cfb\u7edf\u6a21\u62df\u5c42\uff0c\u56e0\u4e3a\u5f53\u524d\u4e3a\u65e0\u64cd\u4f5c\u7cfb\u7edf\u7684\u79fb\u690d\uff0c\u6240\u4ee5\u8bbe\u7f6e\u8be5\u5b8f\u5b9a\u4e49\u4e3a1\u3002 ... /** * NO_SYS==1: Provides VERY minimal functionality. Otherwise, * use LwIPfacilities. */ #define NO_SYS 1 ... cc.h\u6587\u4ef6\u4e2d\u5305\u542b\u5904\u7406\u5668\u76f8\u5173\u7684\u53d8\u91cf\u7c7b\u578b\u3001\u6570\u636e\u7ed3\u6784\u53ca\u5b57\u8282\u5bf9\u9f50\u7684\u76f8\u5173\u5b8f\uff0c\u9700\u6839\u636e\u5904\u7406\u5668\u53ca\u7f16\u8bd1\u5668\u8fdb\u884c\u4fee\u6539\u3002 ... #define LWIP_NO_STDINT_H 1 typedef unsigned char u8_t; typedef signed char s8_t; typedef unsigned short u16_t; typedef signed short s16_t; typedef unsigned long u32_t; typedef signed long s32_t; typedef u32_t mem_ptr_t; typedef int sys_prot_t; #define U16_F \"hu\" #define S16_F \"d\" #define X16_F \"hx\" #define U32_F \"u\" #define S32_F \"d\" #define X32_F \"x\" #define SZT_F \"uz\" ... #elif defined (__GNUC__) #define PACK_STRUCT_BEGIN #define PACK_STRUCT_STRUCT __attribute__ ((__packed__)) #define PACK_STRUCT_END #define PACK_STRUCT_FIELD(x) x ... low_level_init\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0 \u5934\u6587\u4ef6\u914d\u7f6e\u5e76\u4fee\u6539\u5b8c\u6210\u540e\uff0c\u9700\u8981\u5bf9\u79fb\u690d\u6a21\u677f\u6587\u4ef6 ethernetif.c \u8fdb\u884c\u4fee\u6539\u3002 \u5728\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u4e0eLwIP\u521d\u59cb\u5316\u63a5\u53e3\u7684\u8854\u63a5\u4e0a\uff0c\u5bf9low_level_init()\u8fdb\u884c\u4fee\u6539\uff0c\u5728\u5bf9LwIP\u7684netif\u7ed3\u6784\u4f53\u8fdb\u884c\u76f8\u5173\u914d\u7f6e\u4e4b\u524d\uff0c\u9700\u8981\u901a\u8fc7\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u4f7f\u786c\u4ef6\u88ab\u521d\u59cb\u5316\uff1b\u521d\u59cb\u5316\u540e\uff0c\u914d\u7f6e MAC \u786c\u4ef6\u5730\u5740\uff0c\u94fe\u63a5\u53d1\u9001\u63cf\u8ff0\u7b26\u53ca\u63a5\u6536\u63cf\u8ff0\u7b26\u5e76\u8fdb\u884c\u63cf\u8ff0\u7b26\u5185\u5bb9\u914d\u7f6e\uff0c\u914d\u7f6e\u63cf\u8ff0\u7b26\u5730\u5740\uff0c\u914d\u7f6e\u5b8c\u6210\u540e\uff0c\u4f7f\u80fd\u4ee5\u592a\u7f51 DMA \u542f\u52a8\u4f20\u8f93\uff0c\u6b64\u65f6\uff0c\u521d\u59cb\u5316\u5b8c\u6210\u3002 static void low_level_init(struct netif *netif) { struct ethernetif *ethernetif = netif->state; /* set MAC hardware address length */ netif->hwaddr_len = ETHARP_HWADDR_LEN; /* set MAC hardware address */ netif->hwaddr[0] = BOARD_MAC_ADDR0; netif->hwaddr[1] = BOARD_MAC_ADDR1; netif->hwaddr[2] = BOARD_MAC_ADDR2; netif->hwaddr[3] = BOARD_MAC_ADDR3; netif->hwaddr[4] = BOARD_MAC_ADDR4; netif->hwaddr[5] = BOARD_MAC_ADDR5; /* maximum transfer unit */ netif->mtu = 1500; /* device capabilities */ /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */ netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP; #if LWIP_IPV6 && LWIP_IPV6_MLD /* * For hardware/netifs that implement MAC filtering. * All-nodes link-local is handled by default, so we must let the hardware know * to allow multicast packets in. * Should set mld_mac_filter previously. */ if (netif->mld_mac_filter != NULL) { ip6_addr_t ip6_allnodes_ll; ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll); netif->mld_mac_filter(netif, &ip6_allnodes_ll, NETIF_ADD_MAC_FILTER); } #endif /* LWIP_IPV6 && LWIP_IPV6_MLD */ ETH_GPIOInit(); SysTick->CTRL |= ((uint32_t)0x00000004); SysTick_Config(120000000 / 1000); ETH_InitTypeDef ptr; ETH_StructInit(&ptr); ptr.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; ETH_Init(&ptr, ENET_PHY_ADDR); ETH->DMAOMR &= ~ETH_DMAOMR_OSF; /* Enable ETH DMA interrupt. */ ETH_DMAITConfig(ETH_DMA_IT_NIS|ETH_DMA_IT_R, ENABLE); NVIC_InitTypeDef NVIC_InitStruct; NVIC_InitStruct.NVIC_IRQChannel = ENET_IRQn; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&NVIC_InitStruct); /* Config macd filter address. */ ENET_SetupMacAddrFilter(0x1u<<31|0x1u<<5, ENET_ADDR_FILTER_NUM, 0u, netif->hwaddr); /* Set tx dma desp link. */ memset(enet_txdma_desp_tbl, 0, sizeof(enet_txdma_desp_tbl)); for (uint32_t i = 0u; i < ENET_TX_NUM - 1; i++) { enet_txdma_desp_tbl[0].CS |= TXDMA_DES0_TCH; /* TCH = 1u. */ enet_txdma_desp_tbl[0].BUF1ADDR = (uint32_t)(enet_txbuf[i]); enet_txdma_desp_tbl[0].BUF2NDADDR = (uint32_t)(&enet_txdma_desp_tbl[i + 1]); } enet_txdma_desp_tbl[0].CS |= TXDMA_DES0_TCH; /* TCH = 1u. */ enet_txdma_desp_tbl[0].BUF1ADDR = (uint32_t)(enet_txbuf[ENET_TX_NUM - 1]); enet_txdma_desp_tbl[0].BUF2NDADDR = (uint32_t)(&enet_txdma_desp_tbl[0]); /* Set enet tx dma descriptor first address. */ ETH->DMATXDSAR = (uint32_t)(&enet_txdma_desp_tbl[0]); enet_usable_txdma_desp = &enet_txdma_desp_tbl[0]; /* Set rx dma desp link. */ memset(enet_rxdma_desp_tbl, 0, sizeof(enet_rxdma_desp_tbl)); for (uint32_t i = 0; i < ENET_RX_NUM - 1; i++) { enet_rxdma_desp_tbl[i].CS |= RXDMA_DES0_OWN; /* RDES0[OWN] = 1. */ enet_rxdma_desp_tbl[i].BL |= RXDMA_DES1_RCH; /* RDES1[RCH] = 1. */ enet_rxdma_desp_tbl[i].BL &= ~ RXDMA_DES1_RBS1; enet_rxdma_desp_tbl[i].BL |= ENET_RX_BUFLEN; /* RDES1[RBS1] = ENET_RX_BUFLEN. */ enet_rxdma_desp_tbl[i].BUF1ADDR = (uint32_t)enet_rxbuf[i]; enet_rxdma_desp_tbl[i].BUF2NDADDR = (uint32_t)(&enet_rxdma_desp_tbl[i+1]); } enet_rxdma_desp_tbl[ENET_RX_NUM - 1].CS |= RXDMA_DES0_OWN; /* RDES0[OWN] = 1. */ enet_rxdma_desp_tbl[ENET_RX_NUM - 1].BL |= RXDMA_DES1_RCH; /* RDES1[RCH] = 1. */ enet_rxdma_desp_tbl[ENET_RX_NUM - 1].BL &= ~ RXDMA_DES1_RBS1; enet_rxdma_desp_tbl[ENET_RX_NUM - 1].BL |= ENET_RX_BUFLEN; /* RDES1[RBS1] = ENET_RX_BUFLEN. */ enet_rxdma_desp_tbl[ENET_RX_NUM - 1].BUF1ADDR = (uint32_t)enet_rxbuf[ENET_RX_NUM - 1]; enet_rxdma_desp_tbl[ENET_RX_NUM - 1].BUF2NDADDR = (uint32_t)(&enet_rxdma_desp_tbl[0]); ETH->DMARXDSAR = (uint32_t)enet_rxdma_desp_tbl; enet_first_rxdma_desp = &enet_rxdma_desp_tbl[0]; ETH_Start(); } low_level_output\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0 low_level_output()\u51fd\u6570\u4e0e\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u7684\u53d1\u9001\u529f\u80fd\u51fd\u6570\u76f8\u7ed3\u5408\uff0c\u5c06LwIP\u8981\u53d1\u9001\u7684\u6570\u636e\u5b58\u50a8\u5230\u4ee5\u592a\u7f51\u53d1\u9001\u63cf\u8ff0\u7b26\u4e2d\u6240\u6307\u5b9a\u7684\u5b58\u50a8\u533a\u57df\u4e2d\uff0c\u518d\u5bf9\u53d1\u9001\u63cf\u8ff0\u7b26\u8fdb\u884c\u914d\u7f6e\u5e76\u8fdb\u884c\u53d1\u9001\u3002 static err_t low_level_output(struct netif *netif, struct pbuf *p) { struct ethernetif *ethernetif = netif->state; struct pbuf *q; /* Get current destination address. */ ETH_DMADESCTypeDef * txdma_desp = enet_usable_txdma_desp; if (0u != (txdma_desp->CS & TXDMA_DES0_OWN) ){ return ERR_USE; } #if ETH_PAD_SIZE pbuf_remove_header(p, ETH_PAD_SIZE); /* drop the padding word */ #endif uint32_t e_offset = 0; /* record enet module buf offset. */ for (q = p; q != NULL; q = q->next) { /* Send the data from the pbuf to the interface, one pbuf at a time. The size of the data in each pbuf is kept in the ->len variable. */ for (uint32_t i = 0; i < q->len; i++) { ((uint8_t*)(txdma_desp->BUF1ADDR))[e_offset] = ((uint8_t*)(q->payload))[i]; e_offset++; if (e_offset == ENET_TX_BUFLEN) { txdma_desp = (ETH_DMADESCTypeDef*)(txdma_desp->BUF2NDADDR); if ((txdma_desp->CS & TXDMA_DES0_OWN) != 0u) { return ERR_USE; } e_offset = 0; } } } if (p->tot_len <= ENET_TX_BUFLEN) { enet_usable_txdma_desp->CS |= TXDMA_DES0_TFS | TXDMA_DES0_TLS | TXDMA_DES0_OWN; enet_usable_txdma_desp->BL &= ~0x1FFF; enet_usable_txdma_desp->BL |= p->tot_len; /* TBS1!< Transfer buffer size 1. */ enet_usable_txdma_desp = (ETH_DMADESCTypeDef*)enet_usable_txdma_desp->BUF2NDADDR; } else { enet_usable_txdma_desp->CS |= TXDMA_DES0_TFS; /* TFS = 1u. */ enet_usable_txdma_desp->CS &= ~TXDMA_DES0_TLS; /* TLS = 0u. */ enet_usable_txdma_desp->BL &= ~0x1FFF; enet_usable_txdma_desp->BL |= ENET_TX_BUFLEN; /*!< Transfer buffer size 1. */ enet_usable_txdma_desp = (ETH_DMADESCTypeDef*)enet_usable_txdma_desp->BUF2NDADDR; for (uint32_t i = ENET_TX_BUFLEN; i < p->tot_len - ENET_TX_BUFLEN; i+= ENET_TX_BUFLEN) { enet_usable_txdma_desp->CS &= ~TXDMA_DES0_TFS; /* TFS = 0u. */ enet_usable_txdma_desp->CS &= ~TXDMA_DES0_TLS; /* TLS = 0u. */ enet_usable_txdma_desp->BL &= ~0x1FFF; enet_usable_txdma_desp->BL |= ENET_TX_BUFLEN; enet_usable_txdma_desp = (ETH_DMADESCTypeDef*)enet_usable_txdma_desp->BUF2NDADDR; } enet_usable_txdma_desp = (ETH_DMADESCTypeDef*)enet_usable_txdma_desp->BUF2NDADDR; enet_usable_txdma_desp->CS &= ~TXDMA_DES0_TFS; /* TFS = 0u. */ enet_usable_txdma_desp->CS |= TXDMA_DES0_TLS; /* TLS = 1u. */ enet_usable_txdma_desp->BL &= ~0x1FFF; enet_usable_txdma_desp->BL |= (p->tot_len % ENET_TX_BUFLEN); } if (0 != (ETH->DMASR &ETH_DMA_TransmitProcess_Suspended)){ ETH_ResumeDMATransmission(); } MIB2_STATS_NETIF_ADD(netif, ifoutoctets, p->tot_len); if (((u8_t *)p->payload)[0] & 1) { /* broadcast or multicast packet*/ MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts); } else { /* unicast packet */ MIB2_STATS_NETIF_INC(netif, ifoutucastpkts); } /* increase ifoutdiscards or ifouterrors on error */ #if ETH_PAD_SIZE pbuf_add_header(p, ETH_PAD_SIZE); /* reclaim the padding word */ #endif LINK_STATS_INC(link.xmit); return ERR_OK; } low_level_input\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0 low_level_input()\u51fd\u6570\u4e0e\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u7684\u63a5\u6536\u529f\u80fd\u51fd\u6570\u76f8\u7ed3\u5408\uff0c\u5c06\u63a5\u6536\u5230\u7684\u6570\u636e\u5b58\u5165LwIP\u7684pbuf\u94fe\u4e2d\u3002ethernetif_input()\u51fd\u6570\u8c03\u7528low_level_input()\u51fd\u6570\u3002 static struct pbuf * low_level_input(struct netif *netif) { struct ethernetif *ethernetif = netif->state; struct pbuf *p, *q; u16_t len; ETH_DMADESCTypeDef * rxdma_desp = enet_first_rxdma_desp; for (uint32_t i = 0; i < ENET_RX_NUM; i++) { if ((rxdma_desp->CS & RXDMA_DES0_RLS) != 0) { len = (uint32_t)(rxdma_desp->CS & RXDMA_DES0_FL)>>16; break; } else if ((rxdma_desp->CS & RXDMA_DES0_OWN) != 0) { return NULL; } else { rxdma_desp = (ETH_DMADESCTypeDef*)(rxdma_desp->BUF2NDADDR); } } #if ETH_PAD_SIZE len += ETH_PAD_SIZE; /* allow room for Ethernet padding */ #endif /* We allocate a pbuf chain of pbufs from the pool. */ p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL); if (p != NULL) { #if ETH_PAD_SIZE pbuf_remove_header(p, ETH_PAD_SIZE); /* drop the padding word */ #endif /* We iterate over the pbuf chain until we have read the entire * packet into the pbuf. */ uint32_t e_offset = 0; rxdma_desp = enet_first_rxdma_desp; for (q = p; q != NULL; q = q->next) { /* Read enough bytes to fill this pbuf in the chain. The * available data in the pbuf is given by the q->len * variable. * This does not necessarily have to be a memcpy, you can also preallocate * pbufs for a DMA-enabled MAC and after receiving truncate it to the * actually received size. In this case, ensure the tot_len member of the * pbuf is the sum of the chained pbuf len members. */ for (uint32_t i = 0; i < q->len; i++) { ((uint8_t*)q->payload)[i] = ((uint8_t*)rxdma_desp->BUF1ADDR)[e_offset]; e_offset++; if (e_offset == ENET_RX_BUFLEN) { rxdma_desp = (ETH_DMADESCTypeDef*)(rxdma_desp->BUF2NDADDR); e_offset = 0; } } } MIB2_STATS_NETIF_ADD(netif, ifinoctets, p->tot_len); if (((u8_t *)p->payload)[0] & 1) { /* broadcast or multicast packet*/ MIB2_STATS_NETIF_INC(netif, ifinnucastpkts); } else { /* unicast packet*/ MIB2_STATS_NETIF_INC(netif, ifinucastpkts); } #if ETH_PAD_SIZE pbuf_add_header(p, ETH_PAD_SIZE); /* reclaim the padding word */ #endif LINK_STATS_INC(link.recv); } else { LINK_STATS_INC(link.memerr); LINK_STATS_INC(link.drop); MIB2_STATS_NETIF_INC(netif, ifindiscards); } do { enet_first_rxdma_desp->CS |= RXDMA_DES0_OWN; /* Set OWN bit. */ enet_first_rxdma_desp = (ETH_DMADESCTypeDef*)enet_first_rxdma_desp->BUF2NDADDR; } while ((enet_first_rxdma_desp->CS&RXDMA_DES0_OWN) == 0); if (RESET != (ETH_GetDMAFlagStatus((0x4 << 17)) ) ){ /*!< ENET dma rx fifo not active, need to be weak up. */ ETH_ResumeDMAReception(); /* Wakeup enet dma receive. */ } return p; } ENET_IRQHandler\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u5b9e\u73b0 /* ENET IRQHandler. */ void ENET_IRQHandler() { if (0 != ETH_GetDMAFlagStatus(ETH_DMA_FLAG_R)) { ethernetif_input(gnetif); ETH_DMAClearFlag(ETH_DMA_FLAG_R); } } platform\u53c2\u6570\u53ca\u51fd\u6570\u5b9e\u73b0 platform.h \u6587\u4ef6\u4e2d\u9700\u8981\u6839\u636e\u5b9e\u9645\u9009\u7528\u7684\u5f00\u53d1\u677f\u548c\u8fd0\u884c\u53c2\u6570\u7b49\u8fdb\u884c\u5b8f\u5b9a\u4e49\u914d\u7f6e\uff0c\u5982 IP \u5730\u5740\u3001\u7aef\u53e3\u53f7\u3001MAC\u5730\u5740\u9700\u8981\u6839\u636e\u5b9e\u9645\u7684\u7f51\u7edc\u73af\u5883\u8fdb\u884c\u914d\u7f6e\u3002 /* initialization enet. */ #define ENET_PHY_ADDR 0x00 /* Select PHY address. */ #define ENET_PHY_CONTROLREG 0u /* PHY control register address. */ #define ENET_PHY_STATUSREG 1u /* PHY status register sddress. */ #define ENET_PHY_RESET 0x8000 /* Set PHY reset, use in ENET_PHY_CR registers */ #define ENET_PHY_SPEED100M 0x2000 /* Set PHY speed. */ #define ENET_PHY_FULLDUPLEX 0x0100 /* Set PHY duplex mode about full duplex. */ #define ENET_PHY_LINK 0x0004 /* PHY link-up. */ #define ENET_PHY_UNIDIRECTIONAL 0x0080 /* PHY has the ability to encode and transmit data from PHY through MII interface, regardless of whether PHY has determined that an effective link has been connected and established. */ #define ENET_PHY_AUTONEGOTIATION 0x1000 /* PHY auto negotiation. */ #define ENET_TX_BUFLEN 1518u /* Tx buffer length. */ #define ENET_TX_NUM 5u /* The number of tx. */ #define ENET_RX_BUFLEN 1518u /* Configure the frame length of a received frame. */ #define ENET_RX_NUM 5u /* The configured number of received descriptor that can be used for receiving. */ #define ENET_ADDR_FILTER_NUM 1u /* Select MAC address filter number from 0~5. */ #define BOARD_MAC_ADDR0 2u #define BOARD_MAC_ADDR1 0u #define BOARD_MAC_ADDR2 0u #define BOARD_MAC_ADDR3 0u #define BOARD_MAC_ADDR4 0u #define BOARD_MAC_ADDR5 0u #define BOARD_IP_ADDR0 169u #define BOARD_IP_ADDR1 254u #define BOARD_IP_ADDR2 102u #define BOARD_IP_ADDR3 101u #define BOARD_NETMASK_ADDR0 255u #define BOARD_NETMASK_ADDR1 255u #define BOARD_NETMASK_ADDR2 255u #define BOARD_NETMASK_ADDR3 0u #define BOARD_GW_ADDR0 192u #define BOARD_GW_ADDR1 168u #define BOARD_GW_ADDR2 1u #define BOARD_GW_ADDR3 1u #define BOARD_UDP_OWN_PORT 6800u #define TXDMA_DES0_TCH 0x01u<<20 #define TXDMA_DES0_TFS 0x01u<<28 #define TXDMA_DES0_TLS 0x01u<<29 #define TXDMA_DES0_OWN 0x01u<<31 #define RXDMA_DES0_RLS 0x01u<<8 #define RXDMA_DES0_FL 0x3FFFu<<16 #define RXDMA_DES0_OWN 0x01u<<31 #define RXDMA_DES1_RCH 0x01u<<14 #define RXDMA_DES1_RBS1 0x1FFFu EXTERN volatile uint32_t systime_ms; platform.c\u6587\u4ef6\u4e2d\u9664\u4e86\u5bf9Ethernet\u76f8\u5173\u7684\u65f6\u949f\u5f15\u811a\u8fdb\u884c\u914d\u7f6e\u53ca\u4f7f\u7528\u5230\u7684\u7cfb\u7edf\u65f6\u949f\u5bf9\u5e94\u53c2\u6570\u7533\u660e\u5916\uff0c\u4e5f\u6839\u636eLwIP\u534f\u8bae\u6808\u5b9e\u9645\u7684\u5e94\u7528\u9700\u6c42\uff0c\u5b9e\u73b0\u4e86\u5173\u4e8eMAC\u5730\u5740\u8fc7\u6ee4\u5668\u7684\u51fd\u6570\u3002 void ENET_SetupMacAddrFilter(uint32_t filter, uint32_t addr_id, uint32_t addr_mask, uint8_t * addr) { ETH->MACAFR |= filter; if ( (0u != (filter & ETH_SourceAddrFilter_Normal_Enable)) || (0u != (filter & 0x100)) ) /* Set source address filter. */ { ETH->MACA0HR = ( 0x1u<<31 | 0x1u<<30 | (uint32_t)addr[4u] | ((uint32_t)addr[5u]<<8u) );; ETH->MACA0LR = ( (uint32_t)addr[0u] | ((uint32_t)addr[1u] << 8u) | ((uint32_t)addr[2u] << 16u) | ((uint32_t)addr[3u] << 24u) );; } else if ( (0u != (filter & 0x10)) || (0u != (filter & 0x100)) ) /* Set destination address filter. */ { ETH->MACAFR &= ~(0x1u<<4 | 0x1u<<1); } if (0u != addr_mask) { ETH->MACA0HR|= addr_mask; } } /* Returns the current time in milliseconds, this API from lwip/sys.h */ uint32_t sys_now(void) { return systime_ms; } uint32_t sys_jiffies(void) { return systime_ms * 1000000; } \u6837\u4f8b\u8bf4\u660e \u57fa\u4e8e\u79fb\u690d\u7684 LwIP\u534f\u8bae\uff0cLibSamples\u8fd8\u63d0\u4f9b\u4e86\u5c55\u793a LwIP\u4e2d\u90e8\u5206\u534f\u8bae\u529f\u80fd\u7684\u6837\u4f8b\u5de5\u7a0b\uff0c\u4ee5 PLUS-F5270 V2.0 \u5f00\u53d1\u677f\u4e3a\u4f8b\uff0c\u5c55\u793a TCP \u534f\u8bae\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u901a\u4fe1\u7684 lwip_tcp_client\u3001lwip_tcp_server\u6837\u4f8b\uff0c\u5c55\u793a UDP \u534f\u8bae\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u901a\u4fe1\u7684 lwip_udp_client\u3001lwip_udp_server\u3002 \u6837\u4f8b\u5b9e\u73b0\u73af\u5883\u642d\u5efa \u672c\u6587\u57fa\u4e8e\u642d\u8f7d\u4e86MM32F5277E9P MCU\u7684\u5f00\u53d1\u677f PLUS-F5270 V2.0\u8fdb\u884c\u5b9e\u73b0\uff0c\u4f7f\u75282\u6839\u7f51\u7ebf\uff0c\u5206\u522b\u8fde\u63a5\u7535\u8111\u4e0e\u8def\u7531\u5668\u3001\u5f00\u53d1\u677f\u4e0e\u8def\u7531\u5668\u3002 \u5728\u5b98\u7f51(http://free.cmsoft.cn/reslink.php?id=205)\u4e0b\u8f7d\u7f51\u7edc\u8c03\u8bd5\u52a9\u624bNetAssist\u5e76\u5b89\u88c5\uff0c\u7528\u4e8e\u540e\u7eed\u7684\u6837\u4f8b\u529f\u80fd\u9a8c\u8bc1\u3002 \u6253\u5f00\u7535\u8111\u7ec8\u7aef(WIN+R\u952e\uff0c\u8f93\u5165CMD)\uff0c\u7136\u540e\u8f93\u5165\u6307\u4ee4 ipconfig/all \uff0c\u67e5\u770b\u672c\u673a\u7684\u4ee5\u592a\u7f51IP\u5730\u5740\u4e3a 192.168.108.85 \uff0c \u5728\u7ec8\u7aef\u4e2d\u8f93\u5165\u547d\u4ee4 netstat -na \u83b7\u53d6\u672c\u5730\u5f00\u653e\u7aef\u53e3\uff0c\u8fd9\u91cc\u6211\u4eec\u83b7\u53d6\u5230\u53ef\u7528\u7aef\u53e3\u53f7\u4e3a 49153 \u3002 lwip_tcp_client lwip_tcp_client \u6837\u4f8b\u7528\u4e8e\u5c55\u793a\u57fa\u4e8e\u4ee5\u592a\u7f51\u53ca LwIP\u4f7f\u7528 TCP \u534f\u8bae\u4f5c\u4e3a\u5ba2\u6237\u7aef\uff0c\u8fdb\u884c\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u3002 \u82e5\u60f3\u4f7f\u7528LWIP\uff0c\u5219\u9700\u8981\u5148\u5c06\u534f\u8bae\u6808\u521d\u59cb\u5316\uff0c\u5e76\u8bbe\u7f6e\u4e3b\u673a\u7684IP\u5730\u5740\u3001\u5b50\u7f51\u63a9\u7801\u3001\u7f51\u5173\u5730\u5740\u7b49\u3002\u9700\u6ce8\u610f\uff0c\u6837\u4f8b\u5de5\u7a0b\u4e2d\u6240\u8bbe\u7f6e\u7684IP\u5730\u5740\u9700\u8981\u4e0e\u8def\u7531\u5668\u5904\u4e8e\u540c\u4e00\u5b50\u7f51\uff0c\u5982\u56fex\u6240\u793a\uff0c\u5728\u547d\u4ee4\u63d0\u793a\u7b26\uff08CMD\uff09\u4e2d\u4f7f\u7528\u547d\u4ee4 ipconfig/all \u53ef\u67e5\u770b\u5404IP\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u4f8b\u5982\u6240\u67e5\u51fa\u7684\u4ee5\u592a\u7f51IPx4\u5730\u5740\u4e3a192.168.108.85\uff0c\u5219\u5728\u6837\u4f8b\u5de5\u7a0b\u4e2d\u53ef\u8bbe\u7f6eIP\u5730\u5740\u4e3a192.168.108.98\uff0c\u7f51\u5173\u5730\u5740\u4e0e\u5b50\u7f51\u63a9\u7801\u7684\u914d\u7f6e\u9700\u4e0e\u6240\u67e5\u51fa\u7684\u4ee5\u592a\u7f51\u9ed8\u8ba4\u7f51\u5173\u53ca\u5b50\u7f51\u63a9\u7801\u76f8\u540c\u3002 void app_lwip_init(void) { ip4_addr_t ipaddr; ip4_addr_t netmask; ip4_addr_t gw; IP4_ADDR(&ipaddr, BOARD_IP_ADDR0, BOARD_IP_ADDR1, BOARD_IP_ADDR2, BOARD_IP_ADDR3); IP4_ADDR(&netmask, BOARD_NETMASK_ADDR0, BOARD_NETMASK_ADDR1, BOARD_NETMASK_ADDR2, BOARD_NETMASK_ADDR3); IP4_ADDR(&gw, BOARD_GW_ADDR0, BOARD_GW_ADDR1, BOARD_GW_ADDR2, BOARD_GW_ADDR3); lwip_init(); ... } \u56fex \u5728CMD\u754c\u9762\u901a\u8fc7\u547d\u4ee4\u67e5\u8be2\u4ee5\u592a\u7f51IP\u4fe1\u606f \u5728\u914d\u7f6e\u5b8cIP\u5730\u5740\u7b49\u5fc5\u8981\u4fe1\u606f\u540e\uff0c\u9700\u6302\u8f7d\u7f51\u5361\uff0c\u5728LWIP\u4e2d\u7f51\u5361\u6302\u8f7d\u51fd\u6570\u4e3a netif_add() \u51fd\u6570\uff0c\u5c06\u6240\u914d\u7f6e\u7684\u6570\u636e\u4f20\u5165\u8be5\u51fd\u6570\u4e2d\u3002 void app_lwip_init(void) { ... netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input); netif_set_default(&gnetif); if (netif_is_link_up(&gnetif)) { netif_set_up(&gnetif); } else { netif_set_down(&gnetif); } } lwip\u534f\u8bae\u6808\u521d\u59cb\u5316\u540e\uff0c\u9700\u8981\u5bf9\u6240\u4f7f\u7528\u7684 TCP Client\uff08TCP\u5ba2\u6237\u7aef\uff09\u8fdb\u884c\u521d\u59cb\u5316\u914d\u7f6e\u3002\u5728 LwIP\u4e2d\u5b58\u5728\u591a\u4e2a\u4e0e TCP \u76f8\u5173\u7684\u51fd\u6570\uff0clwip_tcp_client \u6837\u4f8b\u6240\u4f7f\u7528\u5230\u7684\u51fd\u6570\u5305\u62ec\uff1a tcp_new() \u521b\u5efa\u4e00\u4e2aTCP\u7684PCB\u63a7\u5236\u5757 tcp_connect() \u8fde\u63a5\u8fdc\u7aef\u4e3b\u673a tcp_err() \u63a7\u5236\u5757err\u5b57\u6bb5\u6ce8\u518c\u7684\u56de\u8c03\u51fd\u6570\uff0c\u9047\u5230\u9519\u8bef\u65f6\u88ab\u8c03\u7528 tcp_write() \u6784\u9020\u4e00\u4e2a\u62a5\u6587\u5e76\u653e\u5165\u63a7\u5236\u5757\u7684\u53d1\u9001\u7f13\u51b2\u961f\u5217\u4e2d tcp_recv() \u63a7\u5236\u5757rev\u5b57\u6bb5\u6ce8\u518c\u7684\u56de\u8c03\u51fd\u6570\uff0c\u5f53\u63a5\u6536\u5230\u65b0\u6570\u636e\u662f\u88ab\u8c03\u7528 tcp_recved() \u5f53\u7a0b\u5e8f\u5904\u7406\u5b8c\u6570\u636e\u540e\u8c03\u7528\u8be5\u51fd\u6570\uff0c\u901a\u77e5\u5185\u6838\u66f4\u65b0\u63a5\u6536\u7a97\u53e3 tcp_close() \u5173\u95ed\u4e00\u4e2aTCP\u8fde\u63a5 TCP \u5ba2\u6237\u7aef\u7684\u5de5\u4f5c\u6d41\u7a0b\u5305\u62ec\uff1a\u65b0\u5efa\u63a7\u5236\u5757\u3001\u5efa\u7acb\u8fde\u63a5\u3001\u53d1\u9001\u8bf7\u6c42\u4e0e\u63a5\u6536\u6570\u636e\u5e76\u5904\u7406\u3002TCP\u5ba2\u6237\u7aef\u5de5\u4f5c\u6d41\u7a0b\u5982\u56fex\u6240\u793a\u3002 \u56fex TCP\u5ba2\u6237\u7aef\u6d41\u7a0b\u56fe TCP Client\uff08TCP\u5ba2\u6237\u7aef\uff09\u8fdb\u884c\u521d\u59cb\u5316\u914d\u7f6e\u65f6\uff0c\u901a\u8fc7 IP4_ADDR() \u51fd\u6570\u5c06\u76ee\u6807\u670d\u52a1\u5668\u7684IP\u5199\u5165\u7ed3\u6784\u4f53\uff1b\u518d\u901a\u8fc7 tcp_new() \u51fd\u6570\u4e3aTCP\u5ba2\u6237\u7aef\u5206\u914d\u4e00\u4e2a\u7ed3\u6784\uff0c\u5f53\u8be5\u7ed3\u6784\u4e0d\u4e3a\u7a7a\u65f6\uff0c\u4f7f\u7528 tcp_connect() \u51fd\u6570\u4e0e\u76ee\u6807\u670d\u52a1\u5668\u8fdb\u884c\u8fde\u63a5\uff0c\u8be5\u51fd\u6570\u4e2d\u914d\u7f6e\u76ee\u6807\u7aef\u53e3\u548c\u76ee\u6807IP\u53c2\u6570\u5e76\u8c03\u7528\u8fde\u63a5\u5b8c\u6210\u56de\u8c03\u51fd\u6570\u3002 void app_tcp_client_init(void) { struct tcp_pcb *tcp_client_pcb; ip_addr_t app_server_ip; /* Write the IP of the target server into a structure, which is the local connection IP address of the pc. */ IP4_ADDR(&app_server_ip, BOARD_TCP_SERVER_IPADDR0, BOARD_TCP_SERVER_IPADDR1, BOARD_TCP_SERVER_IPADDR2, BOARD_TCP_SERVER_IPADDR3); /* Assign a structure to the TCP client */ tcp_client_pcb = tcp_new(); if (tcp_client_pcb != NULL) { /* Connect with the target server, and the parameters include the target port and the target IP. */ tcp_connect(tcp_client_pcb, &app_server_ip, BOARD_TCP_SERVER_PORT, app_tcp_client_connected); /* Registered connection error handling callback function. */ tcp_err(tcp_client_pcb, app_tcp_client_connecterror); } } \u5728\u8fde\u63a5\u5b8c\u6210\u56de\u8c03\u51fd\u6570\u4e2d\uff0c\u4f7f\u7528 tcp_write() \u51fd\u6570\u53d1\u9001\u95ee\u5019\u5b57\u7b26\u4e32\u4ee5\u5efa\u7acb\u8fde\u63a5\uff0c\u5e76\u4f7f\u7528 tcp_recv() \u51fd\u6570\u914d\u7f6e\u63a5\u6536\u56de\u8c03\u51fd\u6570\u3002 static err_t app_tcp_client_connected(void *arg, struct tcp_pcb *pcb, err_t err) { /* Send a greeting string to establish a connection */ tcp_write(pcb, clientstring, strlen(clientstring), 1u); /* Configure the receive callback function */ tcp_recv(pcb, app_tcp_client_xfer); return ERR_OK; } \u5728TCP\u5ba2\u6237\u7aef\u63a5\u6536\u6570\u636e\u540e\u7684\u6570\u636e\u5904\u7406\u56de\u8c03\u51fd\u6570\u4e2d\uff0c\u63a5\u6536\u5230\u6709\u6548\u6570\u636e\u540e\uff0c\u901a\u8fc7tcp_recved()\u66f4\u65b0\u63a5\u6536\u7a97\u53e3\uff0c\u4f7f\u7528 tcp_write() \u51fd\u6570\u5c06\u63a5\u6536\u5230\u7684\u670d\u52a1\u5668\u5185\u5bb9\u56de\u663e\u3002 static err_t app_tcp_client_xfer(void *arg, struct tcp_pcb *pcb, struct pbuf *tcp_recv_pbuf, err_t err) { if (tcp_recv_pbuf != NULL) { /* Update the receiving window */ tcp_recved(pcb, tcp_recv_pbuf->tot_len); tcp_write(pcb, tcp_recv_pbuf->payload, tcp_recv_pbuf->len, 1u); pbuf_free(tcp_recv_pbuf); } else if (err == ERR_OK) { tcp_close(pcb); app_tcp_client_init(); return ERR_OK; } return ERR_OK; } lwip_tcp_client \u6837\u4f8b\u7684\u5b9e\u9a8c\u73b0\u8c61\u5982\u56fex\u6240\u793a\uff0c\u901a\u8fc7\u7f51\u7edc\u8c03\u8bd5\u52a9\u624b\u53ef\u67e5\u770b\u5230\u8fde\u63a5\u6210\u529f\u540e\uff0c\u8fdc\u7aef\u670d\u52a1\u5668\u6536\u5230\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u6570\u636e\uff0c\u670d\u52a1\u5668\u5411\u5ba2\u6237\u7aef\u53d1\u9001\u4efb\u610f\u6570\u636e\u5305\u540e\uff0c\u5ba2\u6237\u7aef\u56de\u663e\u76f8\u540c\u6570\u636e\u3002 \u56fex lwip_tcp_client\u6837\u4f8b\u5b9e\u9a8c\u73b0\u8c61 lwip_tcp_server lwip_tcp_server \u6837\u4f8b\u7528\u4e8e\u5c55\u793a\u57fa\u4e8e\u4ee5\u592a\u7f51\u53ca LwIP\u4f7f\u7528 TCP \u534f\u8bae\u4f5c\u4e3a\u670d\u52a1\u5668\uff0c\u8fdb\u884c\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u3002lwip_tcp_server \u6837\u4f8b\u5728 LwIP\u534f\u8bae\u6808\u521d\u59cb\u5316\u90e8\u5206\u53ca\u8bbe\u7f6eIP\u5730\u5740\u3001\u5b50\u7f51\u63a9\u7801\u3001\u7f51\u5173\u5730\u5740\u7b49\u53c2\u6570\u7684\u914d\u7f6e\uff0c\u4e0elwip_tcp_client \u6837\u4f8b\u76f8\u540c\u3002 TCP\u670d\u52a1\u5668\u7684\u5de5\u4f5c\u6d41\u7a0b\u5305\u62ec\uff1a\u65b0\u5efa\u63a7\u5236\u5757\u3001\u7ed1\u5b9a\u63a7\u5236\u5757\u3001\u63a7\u5236\u5757\u76d1\u542c\u3001\u5efa\u7acb\u8fde\u63a5\u4ee5\u53ca\u63a5\u6536\u5e76\u5904\u7406\u6570\u636e\uff0c\u5982\u56fex\u6240\u793a\u3002 \u56fex TCP \u670d\u52a1\u5668\u5de5\u4f5c\u6d41\u7a0b \u521d\u59cb\u5316 TCP Server\uff08TCP \u670d\u52a1\u5668\uff09\uff0c\u901a\u8fc7 tcp_new() \u51fd\u6570\u4e3aTCP\u670d\u52a1\u5668\u5206\u914d\u4e00\u4e2a\u7ed3\u6784\u4f53\uff0c\u4f7f\u7528 tcp_bind\uff08\uff09 \u51fd\u6570\u7ed1\u5b9a\u672c\u5730\u7aef\u53e3\u53f7\u53caIP\u5730\u5740\uff0c\u8bbe\u5b9a\u7aef\u53e3\u53f7\u4e3a BOARD_TCP_SERVER_PORT \uff0cIP\u5730\u5740\u4e3a IP_ADDR_ANY \uff0c\u4f7f\u7528 tcp_listen() \u51fd\u6570\u76d1\u542c\u4e4b\u524d\u521b\u5efa\u7684\u7ed3\u6784\u4f53\uff0c\u6700\u540e\u901a\u8fc7 tcp_accept() \u51fd\u6570\u521d\u59cb\u5316\u7ed3\u6784\u4f53\u63a5\u6536\u56de\u8c03\u51fd\u6570\u3002 void app_tcp_server_init(void) { struct tcp_pcb *pcb; /* Create new control block. */ pcb = tcp_new(); /* Binding local port and IP address. */ tcp_bind(pcb, IP_ADDR_ANY, BOARD_TCP_SERVER_PORT); /* Start monitoring. */ pcb = tcp_listen(pcb); /* Initialize the structure to receive the callback function. */ tcp_accept(pcb, app_tcp_server_accept); } TCP\u670d\u52a1\u5668\u63a5\u6536\u56de\u8c03\u51fd\u6570\u4e2d\uff0c\u901a\u8fc7 tcp_recv() \u51fd\u6570\u6ce8\u518c\u63a5\u6536\u56de\u8c03\u51fd\u6570\uff0c\u8be5\u56de\u8c03\u51fd\u6570\u4e2d\u5305\u542bTCP\u670d\u52a1\u5668\u63a5\u6536\u6570\u636e\u5904\u7406\uff0c\u5728\u63a5\u6536\u5230\u5ba2\u6237\u7aef\u7684\u6570\u636e\u540e\uff0c\u670d\u52a1\u5668\u5411\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u6bb5\u5b57\u7b26\u6570\u636e\u8868\u793a\u5df2\u63a5\u6536\u5230\u5e76\u5c06\u63a5\u53d7\u7684\u6570\u636e\u53d1\u9001\u56de\u53bb\uff0c\u91ca\u653epbuf\u5e76\u7ed3\u675f\u6b64\u6b21TCP\u8fde\u63a5\u3002 static err_t app_tcp_server_accept(void *arg, struct tcp_pcb *pcb, err_t err) { tcp_recv(pcb, app_tcp_server_receive); return ERR_OK; } /* TCP server receive processing. */ static err_t app_tcp_server_receive(void *arg, struct tcp_pcb *pcb, struct pbuf *tcp_recv_pbuf, err_t err) { if (tcp_recv_pbuf != NULL) { /* Update the receiving window */ tcp_recved(pcb, tcp_recv_pbuf->tot_len); tcp_write(pcb,echostring, strlen(echostring), 1u); /* send the receive data. */ tcp_write(pcb, tcp_recv_pbuf->payload, tcp_recv_pbuf->len, 1u); pbuf_free(tcp_recv_pbuf); tcp_close(pcb); /* close connect. */ } else if(err == ERR_OK) { return tcp_close(pcb); } return ERR_OK; } lwip_tcp_server \u6837\u4f8b\u7684\u5b9e\u9a8c\u73b0\u8c61\u5982\u56fex\u6240\u793a\u3002\u7f51\u7edc\u8c03\u8bd5\u52a9\u624b\u505aTCP\u5ba2\u6237\u7aef\uff0c\u5411\u5f00\u53d1\u677f\u6240\u505a\u7684\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\uff0c\u670d\u52a1\u5668\u63a5\u6536\u6570\u636e\u540e\u53d1\u9001\u4e00\u6bb5\u5b57\u7b26\u5e76\u5c06\u8be5\u6570\u636e\u53d1\u56de\u5ba2\u6237\u7aef\u3002 \u56fex lwip_tcp_server\u5b9e\u9a8c\u73b0\u8c61 lwip_udp_client lwip_udp_client \u6837\u4f8b\u7528\u4e8e\u5c55\u793a\u57fa\u4e8e\u4ee5\u592a\u7f51\u53ca LwIP\u4f7f\u7528 UDP \u534f\u8bae\u4f5c\u4e3a\u5ba2\u6237\u7aef\uff0c\u8fdb\u884c\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u3002\u5728 LwIP\u4e2d\u5b58\u5728\u591a\u4e2a\u4e0e UDP \u76f8\u5173\u7684\u51fd\u6570\uff0c\u4f8b\u5982\uff1a udp_new \u65b0\u5efa\u4e00\u4e2aUDP\u7684PCB\u5757 udp_remove \u5c06\u4e00\u4e2aPCB\u63a7\u5236\u5757\u4ece\u94fe\u8868\u4e2d\u5220\u9664\uff0c\u5e76\u91ca\u653e\u76f8\u5e94\u7684\u5185\u5b58 udp_bind \u4e3aUDP\u7684PCB\u63a7\u5236\u5757\u7ed1\u5b9a\u4e00\u4e2a\u672c\u5730IP\u5730\u5740\u548c\u7aef\u53e3\u53f7 udp_connect \u8fde\u63a5\u5230\u6307\u5b9aIP\u5730\u5740\u4e3b\u673a\u7684\u6307\u5b9a\u7aef\u53e3\u4e0a udp_disconnect \u65ad\u5f00\u8fde\u63a5\uff0c\u5c06\u63a7\u5236\u5757\u8bbe\u7f6e\u4e3a\u975e\u8fde\u7eed\u72b6\u6001 udp_send \u901a\u8fc7\u4e00\u4e2aPCB\u63a7\u5236\u5757\u53d1\u9001\u6570\u636e udp_recv \u9700\u8981\u521b\u5efa\u7684\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u5f53\u63a5\u6536\u5230\u6570\u636e\u7684\u65f6\u5019\u88ab\u8c03\u7528 lwip_udp_client \u6837\u4f8b\u5728 LwIP\u534f\u8bae\u6808\u521d\u59cb\u5316\u90e8\u5206\u53ca\u8bbe\u7f6eIP\u5730\u5740\u3001\u5b50\u7f51\u63a9\u7801\u3001\u7f51\u5173\u5730\u5740\u7b49\u53c2\u6570\u7684\u914d\u7f6e\uff0c\u4e0elwip_tcp_client \u6837\u4f8b\u76f8\u540c\u3002 LWIP\u534f\u8bae\u6808\u521d\u59cb\u5316\u5b8c\u6210\u540e\uff0c\u8fdb\u884c UDP \u505a\u5ba2\u6237\u7aef\u521d\u59cb\u5316\uff0c\u901a\u8fc7 IP4_ADDR() \u51fd\u6570\u8bbe\u7f6e\u670d\u52a1\u7aef\u7684IP\u5730\u5740\uff0c\u518d\u7531 udp_new() \u51fd\u6570\u521b\u5efa\u4e00\u4e2a\u65b0\u7684UDP\u63a7\u5236\u5757\uff0c\u901a\u8fc7 udp_bind() \u7684 \u51fd\u6570\u4e3aUDP\u7684PCB\u63a7\u5236\u5757\u7ed1\u5b9a\u4e00\u4e2a\u672c\u5730IP\u5730\u5740\u548c\u7aef\u53e3\u53f7\uff0c\u8bbe\u7f6e\u7aef\u53e3\u53f7\u4e3a BOARD_UDP_OWN_PORT \u3002\u7531udp_connect() \u51fd\u6570\u8fde\u63a5\u5230\u6307\u5b9aIP\u5730\u5740\u4e3b\u673a\u7684\u6307\u5b9a\u7aef\u53e3\uff0c\u7aef\u53e3\u4e3a BOARD_UDP_ECHO_PORT \uff0c\u901a\u8fc7 udp_recv() \u51fd\u6570\u6ce8\u518c\u56de\u8c03\u51fd\u6570\u3002 void app_udp_client_init(void) { ip_addr_t udp_server_addr; struct udp_pcb * pcb; IP4_ADDR(&udp_server_addr, BOARD_UDP_SERVER_IPADDR0, BOARD_UDP_SERVER_IPADDR1, BOARD_UDP_SERVER_IPADDR2, BOARD_UDP_SERVER_IPADDR3); pcb = udp_new(); /* Generate a new UDP control block */ if (pcb != NULL) { udp_bind(pcb, IP_ADDR_ANY, BOARD_UDP_OWN_PORT); udp_connect(pcb, &udp_server_addr, BOARD_UDP_ECHO_PORT); udp_recv(pcb, app_udp_server_callback, NULL); /* Receive callback. */ app_udp_client_send(pcb, app_udp_client_data); } } UDP \u505a\u5ba2\u6237\u7aef\u5148\u53d1\u9001\u81ea\u5b9a\u5b57\u7b26\u6570\u636e\uff0c\u7b49\u5f85\u6536\u5230\u6765\u81ea\u670d\u52a1\u5668\u7684\u6570\u636e\u540e\uff0c\u5c06\u6570\u636e\u53d1\u56de\u670d\u52a1\u5668\u3002lwip_udp_client \u6837\u4f8b\u5b9e\u9a8c\u73b0\u8c61\u5982\u56fex\u6240\u793a\u3002 \u56fex lwip_udp_client\u5b9e\u9a8c\u73b0\u8c61 lwip_udp_server lwip_udp_server \u6837\u4f8b\u7528\u4e8e\u5c55\u793a\u57fa\u4e8e\u4ee5\u592a\u7f51\u53ca LwIP\u4f7f\u7528 UDP \u534f\u8bae\u4f5c\u4e3a\u670d\u52a1\u5668\uff0c\u8fdb\u884c\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u3002 lwip_udp_server \u6837\u4f8b\u5728 LwIP\u534f\u8bae\u6808\u521d\u59cb\u5316\u90e8\u5206\u53ca\u8bbe\u7f6eIP\u5730\u5740\u3001\u5b50\u7f51\u63a9\u7801\u3001\u7f51\u5173\u5730\u5740\u7b49\u53c2\u6570\u7684\u914d\u7f6e\uff0c\u4e0elwip_udp_client \u6837\u4f8b\u76f8\u540c\u3002 LWIP\u534f\u8bae\u6808\u521d\u59cb\u5316\u5b8c\u6210\u540e\uff0c\u8fdb\u884c UDP \u505a\u670d\u52a1\u5668\u521d\u59cb\u5316\uff0c\u901a\u8fc7 udp_new() \u51fd\u6570\u751f\u6210\u4e00\u4e2a\u65b0\u7684UDP\u63a7\u5236\u5757\uff0cudp_bind() \u51fd\u6570\u7ed1\u5b9a\u4efb\u610fIP\u5730\u5740 IP_ADDR_ANY \u53ca\u6307\u5b9a\u7aef\u53e3 BOARD_UDP_OWN_PORT \uff0c\u901a\u8fc7 udp_recv() \u51fd\u6570\u6ce8\u518c\u56de\u8c03\u51fd\u6570\u3002 void app_udp_server_init(void) { struct udp_pcb * pcb; pcb = udp_new(); /* Generate a new UDP control block */ udp_bind(pcb, IP_ADDR_ANY, BOARD_UDP_OWN_PORT); /* Bind upcb block to any IP address and specified port */ udp_recv(pcb, app_udp_server_callback, NULL); /* Receive callback. */ } UDP\u670d\u52a1\u5668\u56de\u8c03\u51fd\u6570\u7528\u4e8e\u53d1\u9001\u51fd\u6570\u5230\u5ba2\u6237\u7aef\uff0c\u901a\u8fc7 udp_sendto() \u51fd\u6570\u53d1\u9001\u6570\u636e\u5305\uff0cudp_disconnect() \u51fd\u6570\u65ad\u5f00\u94fe\u63a5\u3002 static void app_udp_server_callback(void *arg,struct udp_pcb *upcb,struct pbuf *p,const ip_addr_t *addr, u16_t port) { udp_sendto(upcb, p, addr, port); /* Send data to destination address. */ udp_disconnect(upcb); /* Remove the remote end of the pcb. */ } lwip_udp_server \u6837\u4f8b\u7684\u5b9e\u9a8c\u73b0\u8c61\u5982\u56fex\u6240\u793a\u3002 \u56fex lwip_udp_server \u5b9e\u9a8c\u73b0\u8c61 \u7ed3\u8bed \u672c\u6587\u5bf9LwIP\u534f\u8bae\u6808\u8fdb\u884c\u4e86\u7b80\u5355\u4ecb\u7ecd\uff0c\u5e76\u5bf9 TCP \u534f\u8bae\u4e0e UDP \u534f\u8bae\u7684\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u8fdb\u884c\u5206\u6790\uff0c\u6700\u540e\u5bf9 LwIP\u7684\u79fb\u690d\u548c\u6837\u4f8b\u6f14\u793a\u64cd\u4f5c\u8fdb\u884c\u4e86\u8bb2\u89e3\u3002 \u6ce8\u610f\u4e8b\u9879 \u5728\u914d\u7f6e IP \u5730\u5740\u548c\u7aef\u53e3\u53f7\u65f6\uff0c\u5f53\u8fde\u63a5\u4e86WIFI\u540e\u9700\u8981\u6ce8\u610f\u6211\u4eec\u9009\u7528\u7684\u662f\u4ee5\u592a\u7f51\u7684IP\u5730\u5740\uff0c\u800c\u975eWLAN\u7684IP\u5730\u5740\u3002 lwip_tcp_server \u6837\u4f8b\u6f14\u793a\u4e2d\uff0c\u5728 \u7f51\u7edc\u8c03\u8bd5\u52a9\u624b \u5de5\u5177\u4e2d\u7684\u5de6\u4fa7 \u8fdc\u7a0b\u4e3b\u673a\u5730\u5740 \u53c2\u6570\u586b\u5199\u8981\u548c\u4fee\u6539\u6837\u4f8b\u4e2d\u7684 BOARD_IP_ADDR0~3 \u7684\u53c2\u6570\u4e00\u81f4\uff0c\u4e14\u8981\u5728\u4e3b\u673a\u4ee5\u592a\u7f51\u6240\u5206\u914d\u7684\u5c40\u57df\u7f51IP\u5730\u5740\u8303\u56f4\u5185\u3002\uff08BOARD_GW_ADDR0~3\u53c2\u6570\u5168\u7a0b\u53ef\u4e0d\u4fee\u6539\uff09 \u5728\u88f8\u673a\u8fd0\u884c\u73af\u5883\u4e2d\uff0c\u4f7f\u7528\u5230\u4e86 Systick \u4f5c\u4e3a\u65f6\u95f4\u57fa\u51c6\uff0c\u9700\u8981\u5728 platform.c/.h \u6587\u4ef6\u4e2d\u8fdb\u884c\u58f0\u660e\u548c\u5b9a\u4e49\uff0c\u4ee5\u53ca\u5728 mm32f5270_it.c \u6587\u4ef6\u4e2d\u8fdb\u884c\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u7684\u5b9e\u73b0\u3002","title":"LwIP\u79fb\u690d"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#lwip","text":"LwIP\u534f\u8bae\u6808\u79fb\u690d\u7b14\u8bb0 LwIP\u7b80\u4ecb \u79fb\u690d\u63a5\u53e3\u89e3\u6790 \u79fb\u690dLwIP\u534f\u8bae\u6808 low_level_init\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0 low_level_output\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0 low_level_input\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0 ENET_IRQHandler\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u5b9e\u73b0 platform\u53c2\u6570\u53ca\u51fd\u6570\u5b9e\u73b0 \u6837\u4f8b\u8bf4\u660e lwip_tcp_client lwip_tcp_server lwip_udp_client lwip_udp_server \u7ed3\u8bed \u6ce8\u610f\u4e8b\u9879","title":"LwIP\u534f\u8bae\u6808\u79fb\u690d\u7b14\u8bb0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#lwip_1","text":"LwIP\u662f\u8f7b\u91cf\u5316\u7684TCP/IP\u534f\u8bae\uff0c\u7531\u745e\u5178\u8ba1\u7b97\u673a\u79d1\u5b66\u9662(SICS)\u7684Adam Dunkels \u5f00\u53d1\u7684\u4e00\u4e2a\u5c0f\u578b\u5f00\u6e90\u7684TCP/IP\u534f\u8bae\u6808\u3002LwIP\u5177\u6709\u9ad8\u5ea6\u53ef\u79fb\u690d\u6027\u3001\u4ee3\u7801\u5f00\u6e90\uff0c\u63d0\u4f9b\u4e86\u4e09\u79cd\u7f16\u7a0b\u63a5\u53e3\uff08API\uff09\uff1aRAW API\u3001NETCONN API \u548c Socket API\uff0c\u7528\u4e8e\u4e0eTCP/IP\u4ee3\u7801\u8fdb\u884c\u901a\u4fe1\u3002 \u901a\u8fc7\u5b98\u7f51\uff08http://savannah.nongnu.org/projects/lwip/\uff09\u53ef\u83b7\u53d6LwIP\u6e90\u7801\u5305\u53cacontrib\u5305\u3002\u6e90\u4ee3\u7801\u5305\u4e3b\u8981\u5305\u542bLwIP\u5185\u6838\u7684\u6e90\u7801\u6587\u4ef6\uff0ccontrib\u5305\u4e2d\u5305\u542b\u90e8\u5206\u79fb\u690d\u548c\u5e94\u7528LwIP\u7684demo\u3002contrib\u5305\u4e0d\u5c5e\u4e8eLwIP\u5185\u6838\u7684\u4e00\u90e8\u5206\uff0c\u4f46\u5f88\u6709\u53c2\u8003\u4ef7\u503c\u3002 \u4ee5lwip-2.1.2\u7248\u672c\u7684\u6e90\u7801\u5305\u4e3a\u4f8b\uff0c\u5982\u56fex\u6240\u793a\uff0c\u8be5\u6e90\u7801\u5305\u5206\u4e3a\u4e09\u90e8\u5206\uff0c src \u6587\u4ef6\u4e3aLWIP\u6e90\u4ee3\u7801\u6587\u4ef6\uff0c doc \u6587\u4ef6\u5305\u542bLwIP\u76f8\u5173\u6587\u6863\uff0c test \u4e3aLwIP\u6d4b\u8bd5\u6587\u4ef6\uff0c\u4f7f\u7528\u65f6\u4e3b\u8981\u5173\u6ce8\u4e8e src \u6587\u4ef6\u4e0b\u7684\u5185\u5bb9\u3002 LwIP\u5185\u6838\u662f\u7531\u4e00\u7cfb\u5217\u6a21\u5757\u7ec4\u5408\u800c\u6210\uff0c\u5305\u62ec TCP/IP \u534f\u8bae\u6808\u7684\u5404\u79cd\u534f\u8bae\u3001\u5185\u5b58\u7ba1\u7406\u3001\u6570\u636e\u5305\u7ba1\u7406\u3001\u7f51\u5361\u63a5\u53e3\u3001\u57fa\u7840\u529f\u80fd\u7c7b\u6a21\u5757\u3001API\u7b49\uff0c\u6784\u6210\u8fd9\u4e9b\u6a21\u5757\u7684\u6e90\u6587\u4ef6\u5c31\u5206\u5e03\u5728api\u3001apps\u3001core\u3001netif\u4e2d\uff0c\u5934\u6587\u4ef6\u5219\u6c47\u603b\u5728include\u4e2d\u3002 api\uff1aNETCONN API\u548cSocket API\u76f8\u5173\u7684\u6e90\u6587\u4ef6\uff0c\u53ea\u6709\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684\u73af\u5883\u4e2d\uff0c\u624d\u80fd\u88ab\u7f16\u8bd1 apps\uff1a\u5e94\u7528\u7a0b\u5e8f\u7684\u6e90\u6587\u4ef6\uff0c\u5305\u62ec\u5e38\u89c1\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u5982httpd\u3001mqtt\u3001tftp\u3001sntp\u3001snmp\u7b49 core\uff1aLwIP\u7684\u5185\u6838\u6e90\u6587\u4ef6 include\uff1aLwIP\u6240\u6709\u6a21\u5757\u5bf9\u5e94\u7684\u5934\u6587\u4ef6 netif\uff1a\u4e0e\u7f51\u5361\u79fb\u690d\u6709\u5173\u7684\u6587\u4ef6 LwIP-2.1.2\u6e90\u7801\u5305","title":"LwIP\u7b80\u4ecb"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#_1","text":"LwIP\u4f7f\u7528\u6570\u636e\u7ed3\u6784\u4f53netif\u6765\u63cf\u8ff0\u7f51\u5361\uff0c\u5e76\u63d0\u4f9b\u7edf\u4e00\u63a5\u53e3\uff0c\u9700\u8981\u4e0e\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u63a5\u53e3\u51fd\u6570\u7ed3\u5408\u4f7f\u7528\uff0c\u4f8b\u5982\u5e95\u5c42\u9a71\u52a8\u8d1f\u8d23\u5b8c\u6210\u7f51\u5361\u7684\u521d\u59cb\u5316\u3001\u7f51\u5361\u7684\u6570\u636e\u6536\u53d1\u7b49\uff0c\u5f53LwIP\u5185\u6838\u9700\u8981\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u5305\u65f6\uff0c\u5c31\u4f1a\u901a\u8fc7LWIP\u63d0\u4f9b\u7684\u63a5\u53e3\u51fd\u6570\u53bb\u8c03\u7528\u5e95\u5c42\u7f51\u5361\u7684\u53d1\u9001\u51fd\u6570\uff0c\u5c06\u6570\u636e\u7531\u786c\u4ef6\u63a5\u53e3\u4e0e\u8f6f\u4ef6\u5185\u6838\u8854\u63a5\u5728\u4e00\u8d77\u3002 contrib\u6587\u4ef6\u4e2d\u5305\u542b\u90e8\u5206\u53ef\u4f7f\u7528\u7684\u7f51\u5361\u79fb\u690d\u6a21\u677f\u6587\u4ef6\uff0c\u5176\u4e2dethernetif.c\u6587\u4ef6\uff08contrib-2.1.0\\examples\\ethernetif\u76ee\u5f55\u4e0b\u7684ethernetif.c\u6587\u4ef6\uff09\u4e3a\u5e95\u5c42\u63a5\u53e3\u9a71\u52a8\u7684\u6a21\u677f\uff0c\u4ee5 LibSamples \u4e3a\u4f8b\uff0c\u82e5\u8981\u57fa\u4e8e LibSample\u7684\u4ee5\u592a\u7f51\u9a71\u52a8\u79fb\u690dLwIP\uff0c\u5219\u9700\u53c2\u8003ethernetif.c\u6a21\u677f\uff0c\u6839\u636e\u4ee5\u592a\u7f51\u9a71\u52a8\u53ca\u6240\u9700\u914d\u7f6e\u8fdb\u884c\u4fee\u6539\uff0c\u5c06\u5e95\u5c42\u9a71\u52a8 ethernet \u76f8\u5173\u51fd\u6570\u586b\u5145\u5230LwIP\u6240\u9700\u7684\u6307\u5b9a\u529f\u80fd\u51fd\u6570\u4e2d\u3002 ethernetif.c\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u901a\u5e38\u4e3a\u4e0e\u786c\u4ef6\u6253\u4ea4\u9053\u7684\u5e95\u5c42\u51fd\u6570\uff0c\u5f53\u6709\u6570\u636e\u9700\u8981\u901a\u8fc7\u7f51\u5361\u63a5\u6536\u6216\u8005\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\u5c31\u4f1a\u88ab\u8c03\u7528\uff0c\u7ecf\u8fc7LwIP\u534f\u8bae\u6808\u5185\u90e8\u8fdb\u884c\u5904\u7406\u540e\uff0c\u4ece\u5e94\u7528\u5c42\u5c31\u80fd\u5f97\u5230\u6570\u636e\u6216\u8005\u53ef\u4ee5\u53d1\u9001\u6570\u636e\u3002\u8be5\u6587\u4ef6\u4e2d\u5305\u62ec\u51fd\u6570\uff1alow_level_init()\u3001low_level_output()\u3001low_level_input()\u3001ethernetif_input()\u548cethernetif_init()\u51fd\u6570\u3002 ethernetif_init() LwIP\u4e2d\u9ed8\u8ba4\u7684\u7f51\u5361\u521d\u59cb\u5316\u51fd\u6570\uff0c\u5185\u90e8\u5c01\u88c5\u4e86low_level_init()\u51fd\u6570 ethernetif_input() \u8be5\u51fd\u6570\u7528\u4e8e\u63a5\u6536\u7f51\u5361\u6570\u636e\uff0c\u5185\u90e8\u5c01\u88c5\u4e86low_level_input()\u51fd\u6570\uff0c\u5728\u63a5\u6536\u5b8c\u6bd5\u65f6\uff0c\u5c06\u6570\u636e\u901a\u8fc7pbuf\u9012\u4ea4\u7ed9\u4e0a\u5c42\u3002 low_level_init() low_level_init()\u51fd\u6570\u4e3b\u8981\u662f\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u5bf9\u7f51\u5361\u8fdb\u884c\u4e00\u7cfb\u5217\u7684\u521d\u59cb\u5316\u5de5\u4f5c\uff0c\u4f8b\u5982\uff1a\u521d\u59cb\u5316MAC\u5730\u5740\u3001\u957f\u5ea6\uff0c \u8bbe\u7f6e\u6700\u5927\u4f20\u8f93\u5305\u7684\u5927\u5c0f\uff0c\u8bbe\u7f6e\u7f51\u5361\u7684\u5c5e\u6027\u5b57\u6bb5\u7b49\u529f\u80fd\u3002 \u8be5\u51fd\u6570\u4e2d\u9700\u8981\u8c03\u7528\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u4e2d\u7684\u76f8\u5173\u521d\u59cb\u5316\u51fd\u6570\uff0c\u4ee5 MindSDK \u4e3a\u4f8b\uff0c\u8be5\u51fd\u6570\u9700\u8981\u8c03\u7528\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8 enet_0 \u7684 PHY\u3001MAC\u3001DMA\u76f8\u5173\u521d\u59cb\u5316\u51fd\u6570\u5e76\u8fdb\u884c\u914d\u7f6e\u3002 low_level_output() \u8be5\u51fd\u6570\u7528\u4e8e\u5b9e\u73b0\u7f51\u5361\u53d1\u9001\u6570\u636e\uff0c\u662f\u4e00\u4e2a\u5e95\u5c42\u9a71\u52a8\u51fd\u6570\uff0c\u9700\u6839\u636e\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u8fdb\u884c\u76f8\u5e94\u4fee\u6539\uff0c\u82e5\u60f3\u901a\u8fc7\u4e00\u4e2a\u7f51\u5361\u53d1\u9001\u6570\u636e\uff0c\u5219\u9700\u8981\u5c06\u8be5\u6570\u636e\u4f20\u5165LwIP\u5185\u6838\u4e2d\uff0c\u7ecf\u8fc7\u5c42\u5c42\u5c01\u88c5\u6700\u540e\u5b58\u50a8\u5728pbuf\u6570\u636e\u5305\u4e2d\uff0c\u9700\u6ce8\u610fpbuf\u4ee5\u94fe\u8868\u7684\u5f62\u5f0f\u5b58\u5728\uff0c\u6570\u636e\u53d1\u9001\u65f6\u662f\u4ee5\u4e00\u6574\u4e2a\u6570\u636e\u5305\u5168\u90e8\u53d1\u9001\u7684\u3002 low_level_input() low_level_input()\u51fd\u6570\u7528\u4e8e\u4ece\u7f51\u5361\u4e2d\u63a5\u6536\u4e00\u4e2a\u6570\u636e\u5305\uff0c\u5e76\u5c06\u8be5\u6570\u636e\u5305\u5c01\u88c5\u5728pbuf\u4e2d\u9012\u4ea4\u7ed9\u4e0a\u5c42\uff0c\u8be5\u51fd\u6570\u9700\u8981\u8c03\u7528\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u4e2d\u7684\u63a5\u6536\u51fd\u6570\u3002","title":"\u79fb\u690d\u63a5\u53e3\u89e3\u6790"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#lwip_2","text":"\u57fa\u4e8eLibSamples\u7684\u4ee5\u592a\u7f51\u9a71\u52a8\u5bf9LwIP\u8fdb\u884c\u79fb\u690d\uff0c\u9700\u5148\u5c06LwIP\u6e90\u6587\u4ef6\u4e2d\u7684\u90e8\u5206\u6587\u4ef6\u6dfb\u52a0\u5230LibSamples\u4e2d\uff0c\u5982\uff1a src \u6e90\u6587\u4ef6\u3001 include \u5934\u6587\u4ef6\u3002 \u82e5\u60f3\u4ee4LwIP\u8fd0\u884c\uff0c\u8fd8\u9700\u8865\u5145contrib\u6587\u4ef6\u4e2d\u90e8\u5206\u5185\u5bb9\uff0c\u5982\u56fex\u6240\u793a\uff0c\u7531\u4e8e\u90e8\u5206\u6e90\u6587\u4ef6\u4e2d\u4f7f\u7528\u5934\u6587\u4ef6\u5199\u6cd5\u4e3a\u201darch/xx\u201d\uff0c\u56e0\u6b64\uff0c\u5728src\u6587\u4ef6\u4e0b\u65b0\u5efaarch\u6587\u4ef6\uff0c\u5e76\u5c06\u9700\u8981\u4fee\u6539\u7684\u6a21\u677f\u6587\u4ef6\u53cacontrib\u4e2d\u7684\u90e8\u5206\u63a5\u53e3\u6587\u4ef6\u653e\u5165arch\u6587\u4ef6\u4e2d\u3002 ethernetif.c\u7f51\u5361\u79fb\u690d\u6a21\u677f\u6587\u4ef6 cc.h\u6587\u4ef6\u4e3b\u8981\u5b8c\u6210\u534f\u8bae\u6808\u5185\u90e8\u4f7f\u7528\u7684\u6570\u636e\u7c7b\u578b\u7684\u5b9a\u4e49 lwipopts.h\u6587\u4ef6\u5305\u542b\u4e86\u7528\u6237\u5bf9\u534f\u8bae\u6808\u5185\u6838\u53c2\u6570\u8fdb\u884c\u7684\u914d\u7f6e\uff0c\u82e5\u672a\u5728lwipopts.h\u6587\u4ef6\u4e2d\u8fdb\u884c\u914d\u7f6e\uff0c\u5219LwIP\u4f1a\u4f7f\u7528opt.h\u4e2d\u7684\u9ed8\u8ba4\u53c2\u6570 perf.h\u6587\u4ef6\u662f\u5b9e\u73b0\u4e0e\u7cfb\u901a\u901a\u8ba1\u548c\u6d4b\u91cf\u76f8\u5173\u7684\u529f\u80fd\uff0c\u82e5\u672a\u4f7f\u7528\u8be5\u529f\u80fd\uff0c\u5219\u65e0\u9700\u4fee\u6539 bpstruct.h\u3001epstruct.h\u7531contrib\u6587\u4ef6\u4e0b\u7684ports\u6587\u4ef6\u6240\u63d0\u4f9b\uff0c\u5c5e\u4e8e\u5806\u6808\u7684\u4e00\u90e8\u5206\uff0c\u65e0\u9700\u4fee\u6539 \u56fex LWIP\u79fb\u690d\u6240\u9700\u90e8\u5206\u6587\u4ef6 lwipopts.h\u6587\u4ef6\u4e2d\u9700\u8981\u6839\u636e\u662f\u5426\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u6a21\u62df\u5c42\u3001\u5806\u5185\u5b58\u5927\u5c0f\u3001\u662f\u5426\u4f7f\u7528TCP\u53caTCP\u76f8\u5173\u914d\u7f6e\u7b49\u8fdb\u884c\u5b8f\u5b9a\u4e49\u914d\u7f6e\uff0c\u4f8b\u5982\uff1a\u5b8f\u5b9a\u4e49 NO_SYS \u8868\u793a\u65e0\u64cd\u4f5c\u7cfb\u7edf\u6a21\u62df\u5c42\uff0c\u56e0\u4e3a\u5f53\u524d\u4e3a\u65e0\u64cd\u4f5c\u7cfb\u7edf\u7684\u79fb\u690d\uff0c\u6240\u4ee5\u8bbe\u7f6e\u8be5\u5b8f\u5b9a\u4e49\u4e3a1\u3002 ... /** * NO_SYS==1: Provides VERY minimal functionality. Otherwise, * use LwIPfacilities. */ #define NO_SYS 1 ... cc.h\u6587\u4ef6\u4e2d\u5305\u542b\u5904\u7406\u5668\u76f8\u5173\u7684\u53d8\u91cf\u7c7b\u578b\u3001\u6570\u636e\u7ed3\u6784\u53ca\u5b57\u8282\u5bf9\u9f50\u7684\u76f8\u5173\u5b8f\uff0c\u9700\u6839\u636e\u5904\u7406\u5668\u53ca\u7f16\u8bd1\u5668\u8fdb\u884c\u4fee\u6539\u3002 ... #define LWIP_NO_STDINT_H 1 typedef unsigned char u8_t; typedef signed char s8_t; typedef unsigned short u16_t; typedef signed short s16_t; typedef unsigned long u32_t; typedef signed long s32_t; typedef u32_t mem_ptr_t; typedef int sys_prot_t; #define U16_F \"hu\" #define S16_F \"d\" #define X16_F \"hx\" #define U32_F \"u\" #define S32_F \"d\" #define X32_F \"x\" #define SZT_F \"uz\" ... #elif defined (__GNUC__) #define PACK_STRUCT_BEGIN #define PACK_STRUCT_STRUCT __attribute__ ((__packed__)) #define PACK_STRUCT_END #define PACK_STRUCT_FIELD(x) x ...","title":"\u79fb\u690dLwIP\u534f\u8bae\u6808"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#low_level_init","text":"\u5934\u6587\u4ef6\u914d\u7f6e\u5e76\u4fee\u6539\u5b8c\u6210\u540e\uff0c\u9700\u8981\u5bf9\u79fb\u690d\u6a21\u677f\u6587\u4ef6 ethernetif.c \u8fdb\u884c\u4fee\u6539\u3002 \u5728\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u4e0eLwIP\u521d\u59cb\u5316\u63a5\u53e3\u7684\u8854\u63a5\u4e0a\uff0c\u5bf9low_level_init()\u8fdb\u884c\u4fee\u6539\uff0c\u5728\u5bf9LwIP\u7684netif\u7ed3\u6784\u4f53\u8fdb\u884c\u76f8\u5173\u914d\u7f6e\u4e4b\u524d\uff0c\u9700\u8981\u901a\u8fc7\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u4f7f\u786c\u4ef6\u88ab\u521d\u59cb\u5316\uff1b\u521d\u59cb\u5316\u540e\uff0c\u914d\u7f6e MAC \u786c\u4ef6\u5730\u5740\uff0c\u94fe\u63a5\u53d1\u9001\u63cf\u8ff0\u7b26\u53ca\u63a5\u6536\u63cf\u8ff0\u7b26\u5e76\u8fdb\u884c\u63cf\u8ff0\u7b26\u5185\u5bb9\u914d\u7f6e\uff0c\u914d\u7f6e\u63cf\u8ff0\u7b26\u5730\u5740\uff0c\u914d\u7f6e\u5b8c\u6210\u540e\uff0c\u4f7f\u80fd\u4ee5\u592a\u7f51 DMA \u542f\u52a8\u4f20\u8f93\uff0c\u6b64\u65f6\uff0c\u521d\u59cb\u5316\u5b8c\u6210\u3002 static void low_level_init(struct netif *netif) { struct ethernetif *ethernetif = netif->state; /* set MAC hardware address length */ netif->hwaddr_len = ETHARP_HWADDR_LEN; /* set MAC hardware address */ netif->hwaddr[0] = BOARD_MAC_ADDR0; netif->hwaddr[1] = BOARD_MAC_ADDR1; netif->hwaddr[2] = BOARD_MAC_ADDR2; netif->hwaddr[3] = BOARD_MAC_ADDR3; netif->hwaddr[4] = BOARD_MAC_ADDR4; netif->hwaddr[5] = BOARD_MAC_ADDR5; /* maximum transfer unit */ netif->mtu = 1500; /* device capabilities */ /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */ netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP; #if LWIP_IPV6 && LWIP_IPV6_MLD /* * For hardware/netifs that implement MAC filtering. * All-nodes link-local is handled by default, so we must let the hardware know * to allow multicast packets in. * Should set mld_mac_filter previously. */ if (netif->mld_mac_filter != NULL) { ip6_addr_t ip6_allnodes_ll; ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll); netif->mld_mac_filter(netif, &ip6_allnodes_ll, NETIF_ADD_MAC_FILTER); } #endif /* LWIP_IPV6 && LWIP_IPV6_MLD */ ETH_GPIOInit(); SysTick->CTRL |= ((uint32_t)0x00000004); SysTick_Config(120000000 / 1000); ETH_InitTypeDef ptr; ETH_StructInit(&ptr); ptr.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; ETH_Init(&ptr, ENET_PHY_ADDR); ETH->DMAOMR &= ~ETH_DMAOMR_OSF; /* Enable ETH DMA interrupt. */ ETH_DMAITConfig(ETH_DMA_IT_NIS|ETH_DMA_IT_R, ENABLE); NVIC_InitTypeDef NVIC_InitStruct; NVIC_InitStruct.NVIC_IRQChannel = ENET_IRQn; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&NVIC_InitStruct); /* Config macd filter address. */ ENET_SetupMacAddrFilter(0x1u<<31|0x1u<<5, ENET_ADDR_FILTER_NUM, 0u, netif->hwaddr); /* Set tx dma desp link. */ memset(enet_txdma_desp_tbl, 0, sizeof(enet_txdma_desp_tbl)); for (uint32_t i = 0u; i < ENET_TX_NUM - 1; i++) { enet_txdma_desp_tbl[0].CS |= TXDMA_DES0_TCH; /* TCH = 1u. */ enet_txdma_desp_tbl[0].BUF1ADDR = (uint32_t)(enet_txbuf[i]); enet_txdma_desp_tbl[0].BUF2NDADDR = (uint32_t)(&enet_txdma_desp_tbl[i + 1]); } enet_txdma_desp_tbl[0].CS |= TXDMA_DES0_TCH; /* TCH = 1u. */ enet_txdma_desp_tbl[0].BUF1ADDR = (uint32_t)(enet_txbuf[ENET_TX_NUM - 1]); enet_txdma_desp_tbl[0].BUF2NDADDR = (uint32_t)(&enet_txdma_desp_tbl[0]); /* Set enet tx dma descriptor first address. */ ETH->DMATXDSAR = (uint32_t)(&enet_txdma_desp_tbl[0]); enet_usable_txdma_desp = &enet_txdma_desp_tbl[0]; /* Set rx dma desp link. */ memset(enet_rxdma_desp_tbl, 0, sizeof(enet_rxdma_desp_tbl)); for (uint32_t i = 0; i < ENET_RX_NUM - 1; i++) { enet_rxdma_desp_tbl[i].CS |= RXDMA_DES0_OWN; /* RDES0[OWN] = 1. */ enet_rxdma_desp_tbl[i].BL |= RXDMA_DES1_RCH; /* RDES1[RCH] = 1. */ enet_rxdma_desp_tbl[i].BL &= ~ RXDMA_DES1_RBS1; enet_rxdma_desp_tbl[i].BL |= ENET_RX_BUFLEN; /* RDES1[RBS1] = ENET_RX_BUFLEN. */ enet_rxdma_desp_tbl[i].BUF1ADDR = (uint32_t)enet_rxbuf[i]; enet_rxdma_desp_tbl[i].BUF2NDADDR = (uint32_t)(&enet_rxdma_desp_tbl[i+1]); } enet_rxdma_desp_tbl[ENET_RX_NUM - 1].CS |= RXDMA_DES0_OWN; /* RDES0[OWN] = 1. */ enet_rxdma_desp_tbl[ENET_RX_NUM - 1].BL |= RXDMA_DES1_RCH; /* RDES1[RCH] = 1. */ enet_rxdma_desp_tbl[ENET_RX_NUM - 1].BL &= ~ RXDMA_DES1_RBS1; enet_rxdma_desp_tbl[ENET_RX_NUM - 1].BL |= ENET_RX_BUFLEN; /* RDES1[RBS1] = ENET_RX_BUFLEN. */ enet_rxdma_desp_tbl[ENET_RX_NUM - 1].BUF1ADDR = (uint32_t)enet_rxbuf[ENET_RX_NUM - 1]; enet_rxdma_desp_tbl[ENET_RX_NUM - 1].BUF2NDADDR = (uint32_t)(&enet_rxdma_desp_tbl[0]); ETH->DMARXDSAR = (uint32_t)enet_rxdma_desp_tbl; enet_first_rxdma_desp = &enet_rxdma_desp_tbl[0]; ETH_Start(); }","title":"low_level_init\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#low_level_output","text":"low_level_output()\u51fd\u6570\u4e0e\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u7684\u53d1\u9001\u529f\u80fd\u51fd\u6570\u76f8\u7ed3\u5408\uff0c\u5c06LwIP\u8981\u53d1\u9001\u7684\u6570\u636e\u5b58\u50a8\u5230\u4ee5\u592a\u7f51\u53d1\u9001\u63cf\u8ff0\u7b26\u4e2d\u6240\u6307\u5b9a\u7684\u5b58\u50a8\u533a\u57df\u4e2d\uff0c\u518d\u5bf9\u53d1\u9001\u63cf\u8ff0\u7b26\u8fdb\u884c\u914d\u7f6e\u5e76\u8fdb\u884c\u53d1\u9001\u3002 static err_t low_level_output(struct netif *netif, struct pbuf *p) { struct ethernetif *ethernetif = netif->state; struct pbuf *q; /* Get current destination address. */ ETH_DMADESCTypeDef * txdma_desp = enet_usable_txdma_desp; if (0u != (txdma_desp->CS & TXDMA_DES0_OWN) ){ return ERR_USE; } #if ETH_PAD_SIZE pbuf_remove_header(p, ETH_PAD_SIZE); /* drop the padding word */ #endif uint32_t e_offset = 0; /* record enet module buf offset. */ for (q = p; q != NULL; q = q->next) { /* Send the data from the pbuf to the interface, one pbuf at a time. The size of the data in each pbuf is kept in the ->len variable. */ for (uint32_t i = 0; i < q->len; i++) { ((uint8_t*)(txdma_desp->BUF1ADDR))[e_offset] = ((uint8_t*)(q->payload))[i]; e_offset++; if (e_offset == ENET_TX_BUFLEN) { txdma_desp = (ETH_DMADESCTypeDef*)(txdma_desp->BUF2NDADDR); if ((txdma_desp->CS & TXDMA_DES0_OWN) != 0u) { return ERR_USE; } e_offset = 0; } } } if (p->tot_len <= ENET_TX_BUFLEN) { enet_usable_txdma_desp->CS |= TXDMA_DES0_TFS | TXDMA_DES0_TLS | TXDMA_DES0_OWN; enet_usable_txdma_desp->BL &= ~0x1FFF; enet_usable_txdma_desp->BL |= p->tot_len; /* TBS1!< Transfer buffer size 1. */ enet_usable_txdma_desp = (ETH_DMADESCTypeDef*)enet_usable_txdma_desp->BUF2NDADDR; } else { enet_usable_txdma_desp->CS |= TXDMA_DES0_TFS; /* TFS = 1u. */ enet_usable_txdma_desp->CS &= ~TXDMA_DES0_TLS; /* TLS = 0u. */ enet_usable_txdma_desp->BL &= ~0x1FFF; enet_usable_txdma_desp->BL |= ENET_TX_BUFLEN; /*!< Transfer buffer size 1. */ enet_usable_txdma_desp = (ETH_DMADESCTypeDef*)enet_usable_txdma_desp->BUF2NDADDR; for (uint32_t i = ENET_TX_BUFLEN; i < p->tot_len - ENET_TX_BUFLEN; i+= ENET_TX_BUFLEN) { enet_usable_txdma_desp->CS &= ~TXDMA_DES0_TFS; /* TFS = 0u. */ enet_usable_txdma_desp->CS &= ~TXDMA_DES0_TLS; /* TLS = 0u. */ enet_usable_txdma_desp->BL &= ~0x1FFF; enet_usable_txdma_desp->BL |= ENET_TX_BUFLEN; enet_usable_txdma_desp = (ETH_DMADESCTypeDef*)enet_usable_txdma_desp->BUF2NDADDR; } enet_usable_txdma_desp = (ETH_DMADESCTypeDef*)enet_usable_txdma_desp->BUF2NDADDR; enet_usable_txdma_desp->CS &= ~TXDMA_DES0_TFS; /* TFS = 0u. */ enet_usable_txdma_desp->CS |= TXDMA_DES0_TLS; /* TLS = 1u. */ enet_usable_txdma_desp->BL &= ~0x1FFF; enet_usable_txdma_desp->BL |= (p->tot_len % ENET_TX_BUFLEN); } if (0 != (ETH->DMASR &ETH_DMA_TransmitProcess_Suspended)){ ETH_ResumeDMATransmission(); } MIB2_STATS_NETIF_ADD(netif, ifoutoctets, p->tot_len); if (((u8_t *)p->payload)[0] & 1) { /* broadcast or multicast packet*/ MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts); } else { /* unicast packet */ MIB2_STATS_NETIF_INC(netif, ifoutucastpkts); } /* increase ifoutdiscards or ifouterrors on error */ #if ETH_PAD_SIZE pbuf_add_header(p, ETH_PAD_SIZE); /* reclaim the padding word */ #endif LINK_STATS_INC(link.xmit); return ERR_OK; }","title":"low_level_output\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#low_level_input","text":"low_level_input()\u51fd\u6570\u4e0e\u4ee5\u592a\u7f51\u5e95\u5c42\u9a71\u52a8\u7684\u63a5\u6536\u529f\u80fd\u51fd\u6570\u76f8\u7ed3\u5408\uff0c\u5c06\u63a5\u6536\u5230\u7684\u6570\u636e\u5b58\u5165LwIP\u7684pbuf\u94fe\u4e2d\u3002ethernetif_input()\u51fd\u6570\u8c03\u7528low_level_input()\u51fd\u6570\u3002 static struct pbuf * low_level_input(struct netif *netif) { struct ethernetif *ethernetif = netif->state; struct pbuf *p, *q; u16_t len; ETH_DMADESCTypeDef * rxdma_desp = enet_first_rxdma_desp; for (uint32_t i = 0; i < ENET_RX_NUM; i++) { if ((rxdma_desp->CS & RXDMA_DES0_RLS) != 0) { len = (uint32_t)(rxdma_desp->CS & RXDMA_DES0_FL)>>16; break; } else if ((rxdma_desp->CS & RXDMA_DES0_OWN) != 0) { return NULL; } else { rxdma_desp = (ETH_DMADESCTypeDef*)(rxdma_desp->BUF2NDADDR); } } #if ETH_PAD_SIZE len += ETH_PAD_SIZE; /* allow room for Ethernet padding */ #endif /* We allocate a pbuf chain of pbufs from the pool. */ p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL); if (p != NULL) { #if ETH_PAD_SIZE pbuf_remove_header(p, ETH_PAD_SIZE); /* drop the padding word */ #endif /* We iterate over the pbuf chain until we have read the entire * packet into the pbuf. */ uint32_t e_offset = 0; rxdma_desp = enet_first_rxdma_desp; for (q = p; q != NULL; q = q->next) { /* Read enough bytes to fill this pbuf in the chain. The * available data in the pbuf is given by the q->len * variable. * This does not necessarily have to be a memcpy, you can also preallocate * pbufs for a DMA-enabled MAC and after receiving truncate it to the * actually received size. In this case, ensure the tot_len member of the * pbuf is the sum of the chained pbuf len members. */ for (uint32_t i = 0; i < q->len; i++) { ((uint8_t*)q->payload)[i] = ((uint8_t*)rxdma_desp->BUF1ADDR)[e_offset]; e_offset++; if (e_offset == ENET_RX_BUFLEN) { rxdma_desp = (ETH_DMADESCTypeDef*)(rxdma_desp->BUF2NDADDR); e_offset = 0; } } } MIB2_STATS_NETIF_ADD(netif, ifinoctets, p->tot_len); if (((u8_t *)p->payload)[0] & 1) { /* broadcast or multicast packet*/ MIB2_STATS_NETIF_INC(netif, ifinnucastpkts); } else { /* unicast packet*/ MIB2_STATS_NETIF_INC(netif, ifinucastpkts); } #if ETH_PAD_SIZE pbuf_add_header(p, ETH_PAD_SIZE); /* reclaim the padding word */ #endif LINK_STATS_INC(link.recv); } else { LINK_STATS_INC(link.memerr); LINK_STATS_INC(link.drop); MIB2_STATS_NETIF_INC(netif, ifindiscards); } do { enet_first_rxdma_desp->CS |= RXDMA_DES0_OWN; /* Set OWN bit. */ enet_first_rxdma_desp = (ETH_DMADESCTypeDef*)enet_first_rxdma_desp->BUF2NDADDR; } while ((enet_first_rxdma_desp->CS&RXDMA_DES0_OWN) == 0); if (RESET != (ETH_GetDMAFlagStatus((0x4 << 17)) ) ){ /*!< ENET dma rx fifo not active, need to be weak up. */ ETH_ResumeDMAReception(); /* Wakeup enet dma receive. */ } return p; }","title":"low_level_input\u79fb\u690d\u63a5\u53e3\u5b9e\u73b0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#enet_irqhandler","text":"/* ENET IRQHandler. */ void ENET_IRQHandler() { if (0 != ETH_GetDMAFlagStatus(ETH_DMA_FLAG_R)) { ethernetif_input(gnetif); ETH_DMAClearFlag(ETH_DMA_FLAG_R); } }","title":"ENET_IRQHandler\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u5b9e\u73b0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#platform","text":"platform.h \u6587\u4ef6\u4e2d\u9700\u8981\u6839\u636e\u5b9e\u9645\u9009\u7528\u7684\u5f00\u53d1\u677f\u548c\u8fd0\u884c\u53c2\u6570\u7b49\u8fdb\u884c\u5b8f\u5b9a\u4e49\u914d\u7f6e\uff0c\u5982 IP \u5730\u5740\u3001\u7aef\u53e3\u53f7\u3001MAC\u5730\u5740\u9700\u8981\u6839\u636e\u5b9e\u9645\u7684\u7f51\u7edc\u73af\u5883\u8fdb\u884c\u914d\u7f6e\u3002 /* initialization enet. */ #define ENET_PHY_ADDR 0x00 /* Select PHY address. */ #define ENET_PHY_CONTROLREG 0u /* PHY control register address. */ #define ENET_PHY_STATUSREG 1u /* PHY status register sddress. */ #define ENET_PHY_RESET 0x8000 /* Set PHY reset, use in ENET_PHY_CR registers */ #define ENET_PHY_SPEED100M 0x2000 /* Set PHY speed. */ #define ENET_PHY_FULLDUPLEX 0x0100 /* Set PHY duplex mode about full duplex. */ #define ENET_PHY_LINK 0x0004 /* PHY link-up. */ #define ENET_PHY_UNIDIRECTIONAL 0x0080 /* PHY has the ability to encode and transmit data from PHY through MII interface, regardless of whether PHY has determined that an effective link has been connected and established. */ #define ENET_PHY_AUTONEGOTIATION 0x1000 /* PHY auto negotiation. */ #define ENET_TX_BUFLEN 1518u /* Tx buffer length. */ #define ENET_TX_NUM 5u /* The number of tx. */ #define ENET_RX_BUFLEN 1518u /* Configure the frame length of a received frame. */ #define ENET_RX_NUM 5u /* The configured number of received descriptor that can be used for receiving. */ #define ENET_ADDR_FILTER_NUM 1u /* Select MAC address filter number from 0~5. */ #define BOARD_MAC_ADDR0 2u #define BOARD_MAC_ADDR1 0u #define BOARD_MAC_ADDR2 0u #define BOARD_MAC_ADDR3 0u #define BOARD_MAC_ADDR4 0u #define BOARD_MAC_ADDR5 0u #define BOARD_IP_ADDR0 169u #define BOARD_IP_ADDR1 254u #define BOARD_IP_ADDR2 102u #define BOARD_IP_ADDR3 101u #define BOARD_NETMASK_ADDR0 255u #define BOARD_NETMASK_ADDR1 255u #define BOARD_NETMASK_ADDR2 255u #define BOARD_NETMASK_ADDR3 0u #define BOARD_GW_ADDR0 192u #define BOARD_GW_ADDR1 168u #define BOARD_GW_ADDR2 1u #define BOARD_GW_ADDR3 1u #define BOARD_UDP_OWN_PORT 6800u #define TXDMA_DES0_TCH 0x01u<<20 #define TXDMA_DES0_TFS 0x01u<<28 #define TXDMA_DES0_TLS 0x01u<<29 #define TXDMA_DES0_OWN 0x01u<<31 #define RXDMA_DES0_RLS 0x01u<<8 #define RXDMA_DES0_FL 0x3FFFu<<16 #define RXDMA_DES0_OWN 0x01u<<31 #define RXDMA_DES1_RCH 0x01u<<14 #define RXDMA_DES1_RBS1 0x1FFFu EXTERN volatile uint32_t systime_ms; platform.c\u6587\u4ef6\u4e2d\u9664\u4e86\u5bf9Ethernet\u76f8\u5173\u7684\u65f6\u949f\u5f15\u811a\u8fdb\u884c\u914d\u7f6e\u53ca\u4f7f\u7528\u5230\u7684\u7cfb\u7edf\u65f6\u949f\u5bf9\u5e94\u53c2\u6570\u7533\u660e\u5916\uff0c\u4e5f\u6839\u636eLwIP\u534f\u8bae\u6808\u5b9e\u9645\u7684\u5e94\u7528\u9700\u6c42\uff0c\u5b9e\u73b0\u4e86\u5173\u4e8eMAC\u5730\u5740\u8fc7\u6ee4\u5668\u7684\u51fd\u6570\u3002 void ENET_SetupMacAddrFilter(uint32_t filter, uint32_t addr_id, uint32_t addr_mask, uint8_t * addr) { ETH->MACAFR |= filter; if ( (0u != (filter & ETH_SourceAddrFilter_Normal_Enable)) || (0u != (filter & 0x100)) ) /* Set source address filter. */ { ETH->MACA0HR = ( 0x1u<<31 | 0x1u<<30 | (uint32_t)addr[4u] | ((uint32_t)addr[5u]<<8u) );; ETH->MACA0LR = ( (uint32_t)addr[0u] | ((uint32_t)addr[1u] << 8u) | ((uint32_t)addr[2u] << 16u) | ((uint32_t)addr[3u] << 24u) );; } else if ( (0u != (filter & 0x10)) || (0u != (filter & 0x100)) ) /* Set destination address filter. */ { ETH->MACAFR &= ~(0x1u<<4 | 0x1u<<1); } if (0u != addr_mask) { ETH->MACA0HR|= addr_mask; } } /* Returns the current time in milliseconds, this API from lwip/sys.h */ uint32_t sys_now(void) { return systime_ms; } uint32_t sys_jiffies(void) { return systime_ms * 1000000; }","title":"platform\u53c2\u6570\u53ca\u51fd\u6570\u5b9e\u73b0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#_2","text":"\u57fa\u4e8e\u79fb\u690d\u7684 LwIP\u534f\u8bae\uff0cLibSamples\u8fd8\u63d0\u4f9b\u4e86\u5c55\u793a LwIP\u4e2d\u90e8\u5206\u534f\u8bae\u529f\u80fd\u7684\u6837\u4f8b\u5de5\u7a0b\uff0c\u4ee5 PLUS-F5270 V2.0 \u5f00\u53d1\u677f\u4e3a\u4f8b\uff0c\u5c55\u793a TCP \u534f\u8bae\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u901a\u4fe1\u7684 lwip_tcp_client\u3001lwip_tcp_server\u6837\u4f8b\uff0c\u5c55\u793a UDP \u534f\u8bae\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u901a\u4fe1\u7684 lwip_udp_client\u3001lwip_udp_server\u3002 \u6837\u4f8b\u5b9e\u73b0\u73af\u5883\u642d\u5efa \u672c\u6587\u57fa\u4e8e\u642d\u8f7d\u4e86MM32F5277E9P MCU\u7684\u5f00\u53d1\u677f PLUS-F5270 V2.0\u8fdb\u884c\u5b9e\u73b0\uff0c\u4f7f\u75282\u6839\u7f51\u7ebf\uff0c\u5206\u522b\u8fde\u63a5\u7535\u8111\u4e0e\u8def\u7531\u5668\u3001\u5f00\u53d1\u677f\u4e0e\u8def\u7531\u5668\u3002 \u5728\u5b98\u7f51(http://free.cmsoft.cn/reslink.php?id=205)\u4e0b\u8f7d\u7f51\u7edc\u8c03\u8bd5\u52a9\u624bNetAssist\u5e76\u5b89\u88c5\uff0c\u7528\u4e8e\u540e\u7eed\u7684\u6837\u4f8b\u529f\u80fd\u9a8c\u8bc1\u3002 \u6253\u5f00\u7535\u8111\u7ec8\u7aef(WIN+R\u952e\uff0c\u8f93\u5165CMD)\uff0c\u7136\u540e\u8f93\u5165\u6307\u4ee4 ipconfig/all \uff0c\u67e5\u770b\u672c\u673a\u7684\u4ee5\u592a\u7f51IP\u5730\u5740\u4e3a 192.168.108.85 \uff0c \u5728\u7ec8\u7aef\u4e2d\u8f93\u5165\u547d\u4ee4 netstat -na \u83b7\u53d6\u672c\u5730\u5f00\u653e\u7aef\u53e3\uff0c\u8fd9\u91cc\u6211\u4eec\u83b7\u53d6\u5230\u53ef\u7528\u7aef\u53e3\u53f7\u4e3a 49153 \u3002","title":"\u6837\u4f8b\u8bf4\u660e"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#lwip_tcp_client","text":"lwip_tcp_client \u6837\u4f8b\u7528\u4e8e\u5c55\u793a\u57fa\u4e8e\u4ee5\u592a\u7f51\u53ca LwIP\u4f7f\u7528 TCP \u534f\u8bae\u4f5c\u4e3a\u5ba2\u6237\u7aef\uff0c\u8fdb\u884c\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u3002 \u82e5\u60f3\u4f7f\u7528LWIP\uff0c\u5219\u9700\u8981\u5148\u5c06\u534f\u8bae\u6808\u521d\u59cb\u5316\uff0c\u5e76\u8bbe\u7f6e\u4e3b\u673a\u7684IP\u5730\u5740\u3001\u5b50\u7f51\u63a9\u7801\u3001\u7f51\u5173\u5730\u5740\u7b49\u3002\u9700\u6ce8\u610f\uff0c\u6837\u4f8b\u5de5\u7a0b\u4e2d\u6240\u8bbe\u7f6e\u7684IP\u5730\u5740\u9700\u8981\u4e0e\u8def\u7531\u5668\u5904\u4e8e\u540c\u4e00\u5b50\u7f51\uff0c\u5982\u56fex\u6240\u793a\uff0c\u5728\u547d\u4ee4\u63d0\u793a\u7b26\uff08CMD\uff09\u4e2d\u4f7f\u7528\u547d\u4ee4 ipconfig/all \u53ef\u67e5\u770b\u5404IP\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u4f8b\u5982\u6240\u67e5\u51fa\u7684\u4ee5\u592a\u7f51IPx4\u5730\u5740\u4e3a192.168.108.85\uff0c\u5219\u5728\u6837\u4f8b\u5de5\u7a0b\u4e2d\u53ef\u8bbe\u7f6eIP\u5730\u5740\u4e3a192.168.108.98\uff0c\u7f51\u5173\u5730\u5740\u4e0e\u5b50\u7f51\u63a9\u7801\u7684\u914d\u7f6e\u9700\u4e0e\u6240\u67e5\u51fa\u7684\u4ee5\u592a\u7f51\u9ed8\u8ba4\u7f51\u5173\u53ca\u5b50\u7f51\u63a9\u7801\u76f8\u540c\u3002 void app_lwip_init(void) { ip4_addr_t ipaddr; ip4_addr_t netmask; ip4_addr_t gw; IP4_ADDR(&ipaddr, BOARD_IP_ADDR0, BOARD_IP_ADDR1, BOARD_IP_ADDR2, BOARD_IP_ADDR3); IP4_ADDR(&netmask, BOARD_NETMASK_ADDR0, BOARD_NETMASK_ADDR1, BOARD_NETMASK_ADDR2, BOARD_NETMASK_ADDR3); IP4_ADDR(&gw, BOARD_GW_ADDR0, BOARD_GW_ADDR1, BOARD_GW_ADDR2, BOARD_GW_ADDR3); lwip_init(); ... } \u56fex \u5728CMD\u754c\u9762\u901a\u8fc7\u547d\u4ee4\u67e5\u8be2\u4ee5\u592a\u7f51IP\u4fe1\u606f \u5728\u914d\u7f6e\u5b8cIP\u5730\u5740\u7b49\u5fc5\u8981\u4fe1\u606f\u540e\uff0c\u9700\u6302\u8f7d\u7f51\u5361\uff0c\u5728LWIP\u4e2d\u7f51\u5361\u6302\u8f7d\u51fd\u6570\u4e3a netif_add() \u51fd\u6570\uff0c\u5c06\u6240\u914d\u7f6e\u7684\u6570\u636e\u4f20\u5165\u8be5\u51fd\u6570\u4e2d\u3002 void app_lwip_init(void) { ... netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input); netif_set_default(&gnetif); if (netif_is_link_up(&gnetif)) { netif_set_up(&gnetif); } else { netif_set_down(&gnetif); } } lwip\u534f\u8bae\u6808\u521d\u59cb\u5316\u540e\uff0c\u9700\u8981\u5bf9\u6240\u4f7f\u7528\u7684 TCP Client\uff08TCP\u5ba2\u6237\u7aef\uff09\u8fdb\u884c\u521d\u59cb\u5316\u914d\u7f6e\u3002\u5728 LwIP\u4e2d\u5b58\u5728\u591a\u4e2a\u4e0e TCP \u76f8\u5173\u7684\u51fd\u6570\uff0clwip_tcp_client \u6837\u4f8b\u6240\u4f7f\u7528\u5230\u7684\u51fd\u6570\u5305\u62ec\uff1a tcp_new() \u521b\u5efa\u4e00\u4e2aTCP\u7684PCB\u63a7\u5236\u5757 tcp_connect() \u8fde\u63a5\u8fdc\u7aef\u4e3b\u673a tcp_err() \u63a7\u5236\u5757err\u5b57\u6bb5\u6ce8\u518c\u7684\u56de\u8c03\u51fd\u6570\uff0c\u9047\u5230\u9519\u8bef\u65f6\u88ab\u8c03\u7528 tcp_write() \u6784\u9020\u4e00\u4e2a\u62a5\u6587\u5e76\u653e\u5165\u63a7\u5236\u5757\u7684\u53d1\u9001\u7f13\u51b2\u961f\u5217\u4e2d tcp_recv() \u63a7\u5236\u5757rev\u5b57\u6bb5\u6ce8\u518c\u7684\u56de\u8c03\u51fd\u6570\uff0c\u5f53\u63a5\u6536\u5230\u65b0\u6570\u636e\u662f\u88ab\u8c03\u7528 tcp_recved() \u5f53\u7a0b\u5e8f\u5904\u7406\u5b8c\u6570\u636e\u540e\u8c03\u7528\u8be5\u51fd\u6570\uff0c\u901a\u77e5\u5185\u6838\u66f4\u65b0\u63a5\u6536\u7a97\u53e3 tcp_close() \u5173\u95ed\u4e00\u4e2aTCP\u8fde\u63a5 TCP \u5ba2\u6237\u7aef\u7684\u5de5\u4f5c\u6d41\u7a0b\u5305\u62ec\uff1a\u65b0\u5efa\u63a7\u5236\u5757\u3001\u5efa\u7acb\u8fde\u63a5\u3001\u53d1\u9001\u8bf7\u6c42\u4e0e\u63a5\u6536\u6570\u636e\u5e76\u5904\u7406\u3002TCP\u5ba2\u6237\u7aef\u5de5\u4f5c\u6d41\u7a0b\u5982\u56fex\u6240\u793a\u3002 \u56fex TCP\u5ba2\u6237\u7aef\u6d41\u7a0b\u56fe TCP Client\uff08TCP\u5ba2\u6237\u7aef\uff09\u8fdb\u884c\u521d\u59cb\u5316\u914d\u7f6e\u65f6\uff0c\u901a\u8fc7 IP4_ADDR() \u51fd\u6570\u5c06\u76ee\u6807\u670d\u52a1\u5668\u7684IP\u5199\u5165\u7ed3\u6784\u4f53\uff1b\u518d\u901a\u8fc7 tcp_new() \u51fd\u6570\u4e3aTCP\u5ba2\u6237\u7aef\u5206\u914d\u4e00\u4e2a\u7ed3\u6784\uff0c\u5f53\u8be5\u7ed3\u6784\u4e0d\u4e3a\u7a7a\u65f6\uff0c\u4f7f\u7528 tcp_connect() \u51fd\u6570\u4e0e\u76ee\u6807\u670d\u52a1\u5668\u8fdb\u884c\u8fde\u63a5\uff0c\u8be5\u51fd\u6570\u4e2d\u914d\u7f6e\u76ee\u6807\u7aef\u53e3\u548c\u76ee\u6807IP\u53c2\u6570\u5e76\u8c03\u7528\u8fde\u63a5\u5b8c\u6210\u56de\u8c03\u51fd\u6570\u3002 void app_tcp_client_init(void) { struct tcp_pcb *tcp_client_pcb; ip_addr_t app_server_ip; /* Write the IP of the target server into a structure, which is the local connection IP address of the pc. */ IP4_ADDR(&app_server_ip, BOARD_TCP_SERVER_IPADDR0, BOARD_TCP_SERVER_IPADDR1, BOARD_TCP_SERVER_IPADDR2, BOARD_TCP_SERVER_IPADDR3); /* Assign a structure to the TCP client */ tcp_client_pcb = tcp_new(); if (tcp_client_pcb != NULL) { /* Connect with the target server, and the parameters include the target port and the target IP. */ tcp_connect(tcp_client_pcb, &app_server_ip, BOARD_TCP_SERVER_PORT, app_tcp_client_connected); /* Registered connection error handling callback function. */ tcp_err(tcp_client_pcb, app_tcp_client_connecterror); } } \u5728\u8fde\u63a5\u5b8c\u6210\u56de\u8c03\u51fd\u6570\u4e2d\uff0c\u4f7f\u7528 tcp_write() \u51fd\u6570\u53d1\u9001\u95ee\u5019\u5b57\u7b26\u4e32\u4ee5\u5efa\u7acb\u8fde\u63a5\uff0c\u5e76\u4f7f\u7528 tcp_recv() \u51fd\u6570\u914d\u7f6e\u63a5\u6536\u56de\u8c03\u51fd\u6570\u3002 static err_t app_tcp_client_connected(void *arg, struct tcp_pcb *pcb, err_t err) { /* Send a greeting string to establish a connection */ tcp_write(pcb, clientstring, strlen(clientstring), 1u); /* Configure the receive callback function */ tcp_recv(pcb, app_tcp_client_xfer); return ERR_OK; } \u5728TCP\u5ba2\u6237\u7aef\u63a5\u6536\u6570\u636e\u540e\u7684\u6570\u636e\u5904\u7406\u56de\u8c03\u51fd\u6570\u4e2d\uff0c\u63a5\u6536\u5230\u6709\u6548\u6570\u636e\u540e\uff0c\u901a\u8fc7tcp_recved()\u66f4\u65b0\u63a5\u6536\u7a97\u53e3\uff0c\u4f7f\u7528 tcp_write() \u51fd\u6570\u5c06\u63a5\u6536\u5230\u7684\u670d\u52a1\u5668\u5185\u5bb9\u56de\u663e\u3002 static err_t app_tcp_client_xfer(void *arg, struct tcp_pcb *pcb, struct pbuf *tcp_recv_pbuf, err_t err) { if (tcp_recv_pbuf != NULL) { /* Update the receiving window */ tcp_recved(pcb, tcp_recv_pbuf->tot_len); tcp_write(pcb, tcp_recv_pbuf->payload, tcp_recv_pbuf->len, 1u); pbuf_free(tcp_recv_pbuf); } else if (err == ERR_OK) { tcp_close(pcb); app_tcp_client_init(); return ERR_OK; } return ERR_OK; } lwip_tcp_client \u6837\u4f8b\u7684\u5b9e\u9a8c\u73b0\u8c61\u5982\u56fex\u6240\u793a\uff0c\u901a\u8fc7\u7f51\u7edc\u8c03\u8bd5\u52a9\u624b\u53ef\u67e5\u770b\u5230\u8fde\u63a5\u6210\u529f\u540e\uff0c\u8fdc\u7aef\u670d\u52a1\u5668\u6536\u5230\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u6570\u636e\uff0c\u670d\u52a1\u5668\u5411\u5ba2\u6237\u7aef\u53d1\u9001\u4efb\u610f\u6570\u636e\u5305\u540e\uff0c\u5ba2\u6237\u7aef\u56de\u663e\u76f8\u540c\u6570\u636e\u3002 \u56fex lwip_tcp_client\u6837\u4f8b\u5b9e\u9a8c\u73b0\u8c61","title":"lwip_tcp_client"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#lwip_tcp_server","text":"lwip_tcp_server \u6837\u4f8b\u7528\u4e8e\u5c55\u793a\u57fa\u4e8e\u4ee5\u592a\u7f51\u53ca LwIP\u4f7f\u7528 TCP \u534f\u8bae\u4f5c\u4e3a\u670d\u52a1\u5668\uff0c\u8fdb\u884c\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u3002lwip_tcp_server \u6837\u4f8b\u5728 LwIP\u534f\u8bae\u6808\u521d\u59cb\u5316\u90e8\u5206\u53ca\u8bbe\u7f6eIP\u5730\u5740\u3001\u5b50\u7f51\u63a9\u7801\u3001\u7f51\u5173\u5730\u5740\u7b49\u53c2\u6570\u7684\u914d\u7f6e\uff0c\u4e0elwip_tcp_client \u6837\u4f8b\u76f8\u540c\u3002 TCP\u670d\u52a1\u5668\u7684\u5de5\u4f5c\u6d41\u7a0b\u5305\u62ec\uff1a\u65b0\u5efa\u63a7\u5236\u5757\u3001\u7ed1\u5b9a\u63a7\u5236\u5757\u3001\u63a7\u5236\u5757\u76d1\u542c\u3001\u5efa\u7acb\u8fde\u63a5\u4ee5\u53ca\u63a5\u6536\u5e76\u5904\u7406\u6570\u636e\uff0c\u5982\u56fex\u6240\u793a\u3002 \u56fex TCP \u670d\u52a1\u5668\u5de5\u4f5c\u6d41\u7a0b \u521d\u59cb\u5316 TCP Server\uff08TCP \u670d\u52a1\u5668\uff09\uff0c\u901a\u8fc7 tcp_new() \u51fd\u6570\u4e3aTCP\u670d\u52a1\u5668\u5206\u914d\u4e00\u4e2a\u7ed3\u6784\u4f53\uff0c\u4f7f\u7528 tcp_bind\uff08\uff09 \u51fd\u6570\u7ed1\u5b9a\u672c\u5730\u7aef\u53e3\u53f7\u53caIP\u5730\u5740\uff0c\u8bbe\u5b9a\u7aef\u53e3\u53f7\u4e3a BOARD_TCP_SERVER_PORT \uff0cIP\u5730\u5740\u4e3a IP_ADDR_ANY \uff0c\u4f7f\u7528 tcp_listen() \u51fd\u6570\u76d1\u542c\u4e4b\u524d\u521b\u5efa\u7684\u7ed3\u6784\u4f53\uff0c\u6700\u540e\u901a\u8fc7 tcp_accept() \u51fd\u6570\u521d\u59cb\u5316\u7ed3\u6784\u4f53\u63a5\u6536\u56de\u8c03\u51fd\u6570\u3002 void app_tcp_server_init(void) { struct tcp_pcb *pcb; /* Create new control block. */ pcb = tcp_new(); /* Binding local port and IP address. */ tcp_bind(pcb, IP_ADDR_ANY, BOARD_TCP_SERVER_PORT); /* Start monitoring. */ pcb = tcp_listen(pcb); /* Initialize the structure to receive the callback function. */ tcp_accept(pcb, app_tcp_server_accept); } TCP\u670d\u52a1\u5668\u63a5\u6536\u56de\u8c03\u51fd\u6570\u4e2d\uff0c\u901a\u8fc7 tcp_recv() \u51fd\u6570\u6ce8\u518c\u63a5\u6536\u56de\u8c03\u51fd\u6570\uff0c\u8be5\u56de\u8c03\u51fd\u6570\u4e2d\u5305\u542bTCP\u670d\u52a1\u5668\u63a5\u6536\u6570\u636e\u5904\u7406\uff0c\u5728\u63a5\u6536\u5230\u5ba2\u6237\u7aef\u7684\u6570\u636e\u540e\uff0c\u670d\u52a1\u5668\u5411\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u6bb5\u5b57\u7b26\u6570\u636e\u8868\u793a\u5df2\u63a5\u6536\u5230\u5e76\u5c06\u63a5\u53d7\u7684\u6570\u636e\u53d1\u9001\u56de\u53bb\uff0c\u91ca\u653epbuf\u5e76\u7ed3\u675f\u6b64\u6b21TCP\u8fde\u63a5\u3002 static err_t app_tcp_server_accept(void *arg, struct tcp_pcb *pcb, err_t err) { tcp_recv(pcb, app_tcp_server_receive); return ERR_OK; } /* TCP server receive processing. */ static err_t app_tcp_server_receive(void *arg, struct tcp_pcb *pcb, struct pbuf *tcp_recv_pbuf, err_t err) { if (tcp_recv_pbuf != NULL) { /* Update the receiving window */ tcp_recved(pcb, tcp_recv_pbuf->tot_len); tcp_write(pcb,echostring, strlen(echostring), 1u); /* send the receive data. */ tcp_write(pcb, tcp_recv_pbuf->payload, tcp_recv_pbuf->len, 1u); pbuf_free(tcp_recv_pbuf); tcp_close(pcb); /* close connect. */ } else if(err == ERR_OK) { return tcp_close(pcb); } return ERR_OK; } lwip_tcp_server \u6837\u4f8b\u7684\u5b9e\u9a8c\u73b0\u8c61\u5982\u56fex\u6240\u793a\u3002\u7f51\u7edc\u8c03\u8bd5\u52a9\u624b\u505aTCP\u5ba2\u6237\u7aef\uff0c\u5411\u5f00\u53d1\u677f\u6240\u505a\u7684\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\uff0c\u670d\u52a1\u5668\u63a5\u6536\u6570\u636e\u540e\u53d1\u9001\u4e00\u6bb5\u5b57\u7b26\u5e76\u5c06\u8be5\u6570\u636e\u53d1\u56de\u5ba2\u6237\u7aef\u3002 \u56fex lwip_tcp_server\u5b9e\u9a8c\u73b0\u8c61","title":"lwip_tcp_server"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#lwip_udp_client","text":"lwip_udp_client \u6837\u4f8b\u7528\u4e8e\u5c55\u793a\u57fa\u4e8e\u4ee5\u592a\u7f51\u53ca LwIP\u4f7f\u7528 UDP \u534f\u8bae\u4f5c\u4e3a\u5ba2\u6237\u7aef\uff0c\u8fdb\u884c\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u3002\u5728 LwIP\u4e2d\u5b58\u5728\u591a\u4e2a\u4e0e UDP \u76f8\u5173\u7684\u51fd\u6570\uff0c\u4f8b\u5982\uff1a udp_new \u65b0\u5efa\u4e00\u4e2aUDP\u7684PCB\u5757 udp_remove \u5c06\u4e00\u4e2aPCB\u63a7\u5236\u5757\u4ece\u94fe\u8868\u4e2d\u5220\u9664\uff0c\u5e76\u91ca\u653e\u76f8\u5e94\u7684\u5185\u5b58 udp_bind \u4e3aUDP\u7684PCB\u63a7\u5236\u5757\u7ed1\u5b9a\u4e00\u4e2a\u672c\u5730IP\u5730\u5740\u548c\u7aef\u53e3\u53f7 udp_connect \u8fde\u63a5\u5230\u6307\u5b9aIP\u5730\u5740\u4e3b\u673a\u7684\u6307\u5b9a\u7aef\u53e3\u4e0a udp_disconnect \u65ad\u5f00\u8fde\u63a5\uff0c\u5c06\u63a7\u5236\u5757\u8bbe\u7f6e\u4e3a\u975e\u8fde\u7eed\u72b6\u6001 udp_send \u901a\u8fc7\u4e00\u4e2aPCB\u63a7\u5236\u5757\u53d1\u9001\u6570\u636e udp_recv \u9700\u8981\u521b\u5efa\u7684\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u5f53\u63a5\u6536\u5230\u6570\u636e\u7684\u65f6\u5019\u88ab\u8c03\u7528 lwip_udp_client \u6837\u4f8b\u5728 LwIP\u534f\u8bae\u6808\u521d\u59cb\u5316\u90e8\u5206\u53ca\u8bbe\u7f6eIP\u5730\u5740\u3001\u5b50\u7f51\u63a9\u7801\u3001\u7f51\u5173\u5730\u5740\u7b49\u53c2\u6570\u7684\u914d\u7f6e\uff0c\u4e0elwip_tcp_client \u6837\u4f8b\u76f8\u540c\u3002 LWIP\u534f\u8bae\u6808\u521d\u59cb\u5316\u5b8c\u6210\u540e\uff0c\u8fdb\u884c UDP \u505a\u5ba2\u6237\u7aef\u521d\u59cb\u5316\uff0c\u901a\u8fc7 IP4_ADDR() \u51fd\u6570\u8bbe\u7f6e\u670d\u52a1\u7aef\u7684IP\u5730\u5740\uff0c\u518d\u7531 udp_new() \u51fd\u6570\u521b\u5efa\u4e00\u4e2a\u65b0\u7684UDP\u63a7\u5236\u5757\uff0c\u901a\u8fc7 udp_bind() \u7684 \u51fd\u6570\u4e3aUDP\u7684PCB\u63a7\u5236\u5757\u7ed1\u5b9a\u4e00\u4e2a\u672c\u5730IP\u5730\u5740\u548c\u7aef\u53e3\u53f7\uff0c\u8bbe\u7f6e\u7aef\u53e3\u53f7\u4e3a BOARD_UDP_OWN_PORT \u3002\u7531udp_connect() \u51fd\u6570\u8fde\u63a5\u5230\u6307\u5b9aIP\u5730\u5740\u4e3b\u673a\u7684\u6307\u5b9a\u7aef\u53e3\uff0c\u7aef\u53e3\u4e3a BOARD_UDP_ECHO_PORT \uff0c\u901a\u8fc7 udp_recv() \u51fd\u6570\u6ce8\u518c\u56de\u8c03\u51fd\u6570\u3002 void app_udp_client_init(void) { ip_addr_t udp_server_addr; struct udp_pcb * pcb; IP4_ADDR(&udp_server_addr, BOARD_UDP_SERVER_IPADDR0, BOARD_UDP_SERVER_IPADDR1, BOARD_UDP_SERVER_IPADDR2, BOARD_UDP_SERVER_IPADDR3); pcb = udp_new(); /* Generate a new UDP control block */ if (pcb != NULL) { udp_bind(pcb, IP_ADDR_ANY, BOARD_UDP_OWN_PORT); udp_connect(pcb, &udp_server_addr, BOARD_UDP_ECHO_PORT); udp_recv(pcb, app_udp_server_callback, NULL); /* Receive callback. */ app_udp_client_send(pcb, app_udp_client_data); } } UDP \u505a\u5ba2\u6237\u7aef\u5148\u53d1\u9001\u81ea\u5b9a\u5b57\u7b26\u6570\u636e\uff0c\u7b49\u5f85\u6536\u5230\u6765\u81ea\u670d\u52a1\u5668\u7684\u6570\u636e\u540e\uff0c\u5c06\u6570\u636e\u53d1\u56de\u670d\u52a1\u5668\u3002lwip_udp_client \u6837\u4f8b\u5b9e\u9a8c\u73b0\u8c61\u5982\u56fex\u6240\u793a\u3002 \u56fex lwip_udp_client\u5b9e\u9a8c\u73b0\u8c61","title":"lwip_udp_client"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#lwip_udp_server","text":"lwip_udp_server \u6837\u4f8b\u7528\u4e8e\u5c55\u793a\u57fa\u4e8e\u4ee5\u592a\u7f51\u53ca LwIP\u4f7f\u7528 UDP \u534f\u8bae\u4f5c\u4e3a\u670d\u52a1\u5668\uff0c\u8fdb\u884c\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u3002 lwip_udp_server \u6837\u4f8b\u5728 LwIP\u534f\u8bae\u6808\u521d\u59cb\u5316\u90e8\u5206\u53ca\u8bbe\u7f6eIP\u5730\u5740\u3001\u5b50\u7f51\u63a9\u7801\u3001\u7f51\u5173\u5730\u5740\u7b49\u53c2\u6570\u7684\u914d\u7f6e\uff0c\u4e0elwip_udp_client \u6837\u4f8b\u76f8\u540c\u3002 LWIP\u534f\u8bae\u6808\u521d\u59cb\u5316\u5b8c\u6210\u540e\uff0c\u8fdb\u884c UDP \u505a\u670d\u52a1\u5668\u521d\u59cb\u5316\uff0c\u901a\u8fc7 udp_new() \u51fd\u6570\u751f\u6210\u4e00\u4e2a\u65b0\u7684UDP\u63a7\u5236\u5757\uff0cudp_bind() \u51fd\u6570\u7ed1\u5b9a\u4efb\u610fIP\u5730\u5740 IP_ADDR_ANY \u53ca\u6307\u5b9a\u7aef\u53e3 BOARD_UDP_OWN_PORT \uff0c\u901a\u8fc7 udp_recv() \u51fd\u6570\u6ce8\u518c\u56de\u8c03\u51fd\u6570\u3002 void app_udp_server_init(void) { struct udp_pcb * pcb; pcb = udp_new(); /* Generate a new UDP control block */ udp_bind(pcb, IP_ADDR_ANY, BOARD_UDP_OWN_PORT); /* Bind upcb block to any IP address and specified port */ udp_recv(pcb, app_udp_server_callback, NULL); /* Receive callback. */ } UDP\u670d\u52a1\u5668\u56de\u8c03\u51fd\u6570\u7528\u4e8e\u53d1\u9001\u51fd\u6570\u5230\u5ba2\u6237\u7aef\uff0c\u901a\u8fc7 udp_sendto() \u51fd\u6570\u53d1\u9001\u6570\u636e\u5305\uff0cudp_disconnect() \u51fd\u6570\u65ad\u5f00\u94fe\u63a5\u3002 static void app_udp_server_callback(void *arg,struct udp_pcb *upcb,struct pbuf *p,const ip_addr_t *addr, u16_t port) { udp_sendto(upcb, p, addr, port); /* Send data to destination address. */ udp_disconnect(upcb); /* Remove the remote end of the pcb. */ } lwip_udp_server \u6837\u4f8b\u7684\u5b9e\u9a8c\u73b0\u8c61\u5982\u56fex\u6240\u793a\u3002 \u56fex lwip_udp_server \u5b9e\u9a8c\u73b0\u8c61","title":"lwip_udp_server"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#_3","text":"\u672c\u6587\u5bf9LwIP\u534f\u8bae\u6808\u8fdb\u884c\u4e86\u7b80\u5355\u4ecb\u7ecd\uff0c\u5e76\u5bf9 TCP \u534f\u8bae\u4e0e UDP \u534f\u8bae\u7684\u5ba2\u6237\u7aef\u4e0e\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u901a\u4fe1\u8fdb\u884c\u5206\u6790\uff0c\u6700\u540e\u5bf9 LwIP\u7684\u79fb\u690d\u548c\u6837\u4f8b\u6f14\u793a\u64cd\u4f5c\u8fdb\u884c\u4e86\u8bb2\u89e3\u3002","title":"\u7ed3\u8bed"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/LwIP%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0/#_4","text":"\u5728\u914d\u7f6e IP \u5730\u5740\u548c\u7aef\u53e3\u53f7\u65f6\uff0c\u5f53\u8fde\u63a5\u4e86WIFI\u540e\u9700\u8981\u6ce8\u610f\u6211\u4eec\u9009\u7528\u7684\u662f\u4ee5\u592a\u7f51\u7684IP\u5730\u5740\uff0c\u800c\u975eWLAN\u7684IP\u5730\u5740\u3002 lwip_tcp_server \u6837\u4f8b\u6f14\u793a\u4e2d\uff0c\u5728 \u7f51\u7edc\u8c03\u8bd5\u52a9\u624b \u5de5\u5177\u4e2d\u7684\u5de6\u4fa7 \u8fdc\u7a0b\u4e3b\u673a\u5730\u5740 \u53c2\u6570\u586b\u5199\u8981\u548c\u4fee\u6539\u6837\u4f8b\u4e2d\u7684 BOARD_IP_ADDR0~3 \u7684\u53c2\u6570\u4e00\u81f4\uff0c\u4e14\u8981\u5728\u4e3b\u673a\u4ee5\u592a\u7f51\u6240\u5206\u914d\u7684\u5c40\u57df\u7f51IP\u5730\u5740\u8303\u56f4\u5185\u3002\uff08BOARD_GW_ADDR0~3\u53c2\u6570\u5168\u7a0b\u53ef\u4e0d\u4fee\u6539\uff09 \u5728\u88f8\u673a\u8fd0\u884c\u73af\u5883\u4e2d\uff0c\u4f7f\u7528\u5230\u4e86 Systick \u4f5c\u4e3a\u65f6\u95f4\u57fa\u51c6\uff0c\u9700\u8981\u5728 platform.c/.h \u6587\u4ef6\u4e2d\u8fdb\u884c\u58f0\u660e\u548c\u5b9a\u4e49\uff0c\u4ee5\u53ca\u5728 mm32f5270_it.c \u6587\u4ef6\u4e2d\u8fdb\u884c\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u7684\u5b9e\u73b0\u3002","title":"\u6ce8\u610f\u4e8b\u9879"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/","text":"CANopenNode\u79fb\u690d----\u57fa\u4e8eMM32G5330 \u5f15\u8a00 \u57fa\u672c\u7684CAN\u603b\u7ebf\u5916\u8bbe\u9a71\u52a8\u7a0b\u5e8f\u80fd\u591f\u63d0\u4f9b\u57fa\u672c\u7684\u64cd\u4f5c\u786c\u4ef6\u7535\u8def\u7cfb\u7edf\u7684\u670d\u52a1\uff0c\u4f46\u5728\u5177\u4f53\u7684\u5e94\u7528\u7cfb\u7edf\u4e2d\uff0c\u66f4\u591a\u662f\u57fa\u4e8e\u534f\u8bae\u6808\u5f00\u53d1\u4e0a\u5c42\u5e94\u7528\uff0c\u800c\u4e0d\u662f\u9488\u5bf9\u67d0\u4e2a\u5177\u4f53\u7684\u82af\u7247\u5e73\u53f0\u7f16\u5199\u5b9a\u5236\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\u76ee\u524dCANopen\u662f\u5de5\u4e1a\u81ea\u52a8\u5316\u9886\u57df\u6700\u5e38\u7528\u7684\u534f\u8bae\u6808\u6807\u51c6\u4e4b\u4e00\u3002\u5bf9\u5e94\u5730\uff0c\u6709\u4e00\u4e9b\u5b9e\u73b0CANopen\u534f\u8bae\u7684\u5f00\u6e90\u8f6f\u4ef6\u5305\uff0c\u4f8b\u5982CANopenNode\u3001CAN Festival\u7b49\u3002 CANopen\u6982\u8ff0 CANopen \u7684\u8bde\u751f\u548c\u4f5c\u7528 CANopen \u534f\u8bae\u662f\u572820\u4e16\u7eaa90\u5e74\u4ee3\u672b\uff0c\u7531\u603b\u90e8\u4f4d\u4e8e\u5fb7\u56fd\u7ebd\u4f26\u5821\u7684 CiA(CAN-in-Automation) \u7ec4\u7ec7\u5728CAL(CAN Application Layer)\u7684\u57fa\u7840\u4e0a\u53d1\u5c55\u800c\u6765\u3002\u7531\u4e8eCANopen\u534f\u8bae\u7684\u521b\u59cb\u4eba\u56e2\u961f\u4e5f\u662fCAN-bus\u7684\u521b\u59cb\u4eba\u56e2\u961f\uff0c\u6b64\u534f\u8bae\u5145\u5206\u53d1\u6325\u4e86CAN-bus\u6240\u5177\u5907\u7684\u6240\u6709\u4f18\u52bf\uff0c\u7279\u522b\u662f CiA \u7ec4\u7ec7\u7684\u4e3b\u5e2d\u8521\u8c6a\u683c(Holger Zeltwanger)\u5148\u751f\u5bf9\u4e8eCANopen\u534f\u8bae\u575a\u6301\u5f00\u653e\u3001\u514d\u8d39\u3001\u975e\u76c8\u5229\u7684\u539f\u5219\u3002\u4e00\u7ecf\u63a8\u51fa\u4fbf\u5728\u6b27\u6d32\u5f97\u5230\u4e86\u5e7f\u6cdb\u7684\u8ba4\u53ef\u4e0e\u5e94\u7528\u3002\u867d\u7136CiA\u7ec4\u7ec7\u80cc\u540e\u6ca1\u6709\u5f3a\u5927\u7684\u8d22\u9600\u652f\u6491\uff0c\u4f46\u65f6\u81f3\u4eca\u65e5\u5df2\u7ecf\u6210\u4e3a\u5168\u4e16\u754c\u6700\u4e3a\u6d41\u884c\u7684CAN\u5e94\u7528\u5c42\u534f\u8bae\u3002 CANopen\u4e3b\u8981\u63d0\u4f9b\u4e86\u4e24\u4e2a\u670d\u52a1\uff1a\u7b2c\u4e00\u4e2a\u662f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u57fa\u4e8eCAN\u7684\u901a\u4fe1\u534f\u8bae\uff0c\u53ef\u4ee5\u5c06\u591a\u4e2a\u8bbe\u5907\u8fde\u63a5\u5230\u4e00\u4e2a\u603b\u7ebf\uff1b\u7b2c\u4e8c\u4e2a\u662f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7528\u4e8e\u8bbe\u5907\u7ba1\u7406\u7684\u6807\u51c6\uff0c\u53ef\u4ee5\u5c06\u591a\u4e2a\u8bbe\u5907\u7ec4\u7ec7\u6210\u4e00\u4e2a\u7cfb\u7edf\uff0c\u4ee5\u5b9e\u73b0\u8fdc\u7a0b\u76d1\u63a7\u548c\u63a7\u5236\u3002\u76ee\u524d\uff0cCANopen\u4f5c\u4e3a\u5de5\u4e1a\u81ea\u52a8\u5316\u9886\u57df\u6700\u5e38\u7528\u7684\u6807\u51c6\u4e4b\u4e00\uff0c\u88ab\u5e7f\u6cdb\u5e94\u7528\u4e8e\u6c7d\u8f66\u3001\u822a\u7a7a\u822a\u5929\u3001\u697c\u5b87\u81ea\u52a8\u5316\u7b49\u884c\u4e1a\u3002 \u5982\u56fex\u6240\u793a\uff0cCNAopen\u662f\u4e00\u4e2a\u57fa\u4e8eCAN\u603b\u7ebf\u7684\u4e0a\u5c42\u534f\u8bae\uff0c\u5176\u4e2dCAN\u6db5\u76d6\u4e86OSI\u6a21\u578b\u7684\u524d\u4e24\u5c42\uff1a\u7269\u7406\u5c42\u548c\u6570\u636e\u94fe\u8def\u5c42\uff0cCANopen\u6db5\u76d6\u4e86\u540e\u4e94\u5c42\uff1a\u7f51\u7edc\u5c42\uff08\u5bfb\u5740\u3001\u8def\u7531\uff09\u3001\u4f20\u8f93\u5c42\uff08\u7aef\u5230\u7aef\u53ef\u9760\u6027\uff09\u3001\u4f1a\u8bdd\u5c42\uff08\u540c\u6b65\uff09\u3001\u8868\u73b0\u5c42\uff08\u4ee5\u6807\u51c6\u65b9\u5f0f\u7f16\u7801\u7684\u6570\u636e\u3001\u6570\u636e\u8868\u73b0\uff09\u548c\u5e94\u7528\u5c42\u3002\u5e94\u7528\u5c42\u89c4\u5b9a\u4e86CANopen\u8bbe\u5907\u662f\u5982\u4f55\u914d\u7f6e\u3001\u4f20\u8f93\u548c\u540c\u6b65\u3002 \u56fex CANopen\u4ece\u5e94\u7528\u7aef\u5230CAN\u603b\u7ebf\u7684\u7ed3\u6784\u5982\u4e0b\u56fex\u6240\u793a\uff1a \u5e94\u7528\u5c42(Application) \u7528\u4e8e\u5b9e\u73b0\u5404\u79cd\u5e94\u7528\u5bf9\u8c61 \u5bf9\u8c61\u5b57\u5178(Object dictionary) \u7528\u4e8e\u63cf\u8ff0CANopen\u8282\u70b9\u8bbe\u5907\u7684\u53c2\u6570 \u901a\u4fe1\u63a5\u53e3(Communication interface) \u5b9a\u4e49\u4e86CANopen\u534f\u8bae\u901a\u4fe1\u89c4\u5219\u4ee5\u53caCAN\u63a7\u5236\u5668\u9a71\u52a8\u4e4b\u95f4\u5bf9\u5e94\u5173\u7cfb \u56fe x \u5728CANopen\u7f51\u7edc\u4e2d\uff0c\u901a\u5e38\u9700\u8981\u591a\u4e2a\u8bbe\u5907\u8fdb\u884c\u901a\u4fe1\uff0c\u5728CANopen\u7f51\u7edc\u4e2d\u7528\u5230\u4e86\u5982\u4e0b\u4e09\u79cd\u901a\u4fe1\u6a21\u578b\uff1a \u56fe x \u4e3b\u673a/\u4ece\u673a\u6a21\u578b(Master/Salve) \u4e00\u4e2a\u8282\u70b9(\u4f8b\u5982\u63a7\u5236\u63a5\u53e3)\u5145\u5f53\u5e94\u7528\u7a0b\u5e8f\u4e3b\u673a\u63a7\u5236\u5668\uff0c\u4ece\u673a(\u4f8b\u5982\u4f3a\u670d\u7535\u673a)\u53d1\u9001/\u8bf7\u6c42\u6570\u636e\uff0c\u4e00\u822c\u5728\u8bca\u65ad\u6216\u72b6\u6001\u7ba1\u7406\u4e2d\u4f7f\u7528\u3002 \u901a\u4fe1\u6837\u4f8b\uff1aNMT\u4e3b\u673a\u4e0eNMT\u4ece\u673a\u7684\u901a\u4fe1 \u6240\u6709\u8282\u70b9\u901a\u4fe1\u5730\u4f4d\u5e73\u7b49\uff0c\u8fd0\u884c\u65f6\u5141\u8bb8\u81ea\u884c\u53d1\u9001\u62a5\u6587\uff0c\u4f46CANopen\u7f51\u7edc\u4e3a\u4e86\u7a33\u5b9a\u53ef\u9760\u53ef\u63a7\uff0c\u90fd\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u7f51\u7edc\u7ba1\u7406\u4e3b\u673a NMT-Master\u3002 NMT\u4e3b\u673a\u4e00\u822c\u662fCANopen\u7f51\u7edc\u4e2d\u5177\u5907\u76d1\u63a7\u7684PLC\u6216\u8005PC(\u5f53\u7136\u4e5f\u53ef\u4ee5\u662f\u4e00\u822c\u7684\u529f\u80fd\u8282\u70b9)\uff0c\u6240\u4ee5\u4e5f\u6210\u4e3aCANopen\u4e3b\u7ad9\u3002\u76f8\u5bf9\u5e94\u7684\u5176\u4ed6CANopen\u8282\u70b9\u5c31\u662fNMT\u4ece\u673a(NMT-slaves)\u3002 \u5ba2\u6237\u7aef/\u670d\u52a1\u7aef\u6a21\u578b(Client/Server) \u5ba2\u6237\u673a\u5411\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\u8bf7\u6c42\uff0c\u670d\u52a1\u5668\u8fdb\u884c\u54cd\u5e94\u3002\u4f8b\u5982\uff0c\u5f53\u5e94\u7528\u7a0b\u5e8f\u4e3b\u673a\u9700\u8981\u6765\u81ea\u4ece\u673aOD\u7684\u6570\u636e\u65f6\u4f7f\u7528\u3002 \u901a\u4fe1\u6837\u4f8b\uff1aSDO\u5ba2\u6237\u7aef\u4e0eSDO\u670d\u52a1\u7aef\u7684\u901a\u4fe1 \u53d1\u9001\u8282\u70b9\u9700\u8981\u6307\u5b9a\u63a5\u6536\u8282\u70b9\u7684\u5730\u5740(Node-ID)\u56de\u5e94CAN\u62a5\u6587\u6765\u786e\u8ba4\u5df2\u7ecf\u63a5\u6536\uff0c\u5982\u679c\u8d85\u65f6\u6ca1\u6709\u786e\u8ba4\uff0c\u5219\u53d1\u9001\u8282\u70b9\u5c06\u4f1a\u91cd\u65b0\u53d1\u9001\u539f\u62a5\u6587\u3002 \u751f\u4ea7\u8005/\u6d88\u8d39\u8005\u6a21\u578b(Producer/Consumer) \u751f\u4ea7\u8005\u8282\u70b9\u5411\u7f51\u7edc\u5e7f\u64ad\u6570\u636e\uff0c\u800c\u7f51\u7edc\u7531\u4f7f\u7528\u8005\u8282\u70b9\u4f7f\u7528\u3002\u751f\u4ea7\u8005\u53ef\u4ee5\u6839\u636e\u8bf7\u6c42\u53d1\u9001\u6b64\u6570\u636e\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u53d1\u9001\u7279\u5b9a\u8bf7\u6c42\u3002 \u901a\u4fe1\u6837\u4f8b\uff1a\u5fc3\u8df3\u751f\u4ea7\u8005\u4e0e\u5fc3\u8df3\u6d88\u8d39\u8005\u7684\u901a\u4fe1 \u5355\u5411\u53d1\u9001\u4f20\u8f93\uff0c\u65e0\u9700\u63a5\u6536\u8282\u70b9\u56de\u5e94CAN\u62a5\u6587\u6765\u786e\u8ba4\u3002 CANopen\u7684COB-ID 11\u4f4dCAN ID\u5728CANopen\u4e2d\u88ab\u79f0\u4e3aCOB-ID\uff0c\u8fd911\u4f4dCOB-ID\u88ab\u5206\u4e3a\u4e24\u90e8\u5206\uff1a\u524d4\u4f4d\u662f\u529f\u80fd\u7801\uff0c\u540e7\u4f4d\u662f(\u8282\u70b9ID)\uff0c\u4e147\u4f4d\u7684\u8282\u70b9ID\u9650\u5236\u4e86CANopen\u7f51\u7edc\u4e0a\u7684\u8bbe\u5907\u6570\u91cf\u4e3a127\u4e2a\u8282\u70b9\u3002 \u56fe x CANopen\u76847\u79cd\u62a5\u6587\u7c7b\u578b NMT(Network Management) \u63a7\u5236CANopen\u8bbe\u5907\u72b6\u6001\uff0c\u7528\u4e8e\u7f51\u7edc\u7ba1\u7406\u3002 SYNC(Synchronization) SYNC \u6d88\u606f\u7528\u4e8e\u540c\u6b65\u591a\u4e2a CANopen \u8bbe\u5907\u7684\u8f93\u5165\u611f\u5e94\u548c\u9a71\u52a8\u2014\u2014\u901a\u5e38\u7531\u5e94\u7528\u7a0b\u5e8f Master \u89e6\u53d1\u3002 EMCY(Emergency) \u5728\u8bbe\u5907\u53d1\u751f\u9519\u8bef(\u4f8b\u5982\u4f20\u611f\u5668\u6545\u969c)\u65f6\u4f7f\u7528\u7684\uff0c\u53d1\u9001\u8bbe\u5907\u5185\u90e8\u9519\u8bef\u4ee3\u7801\u3002 TIME \u7528\u4e8e\u5206\u914d\u7f51\u7edc\u65f6\u95f4\uff0c\u8bae\u91c7\u7528\u5e7f\u64ad\u65b9\u5f0f\uff0c\u65e0\u9700\u8282\u70b9\u5e94\u7b54\uff0cCAN-ID \u4e3a 100h\uff0c\u6570\u636e\u957f\u5ea6\u4e3a 6\uff0c\u6570\u636e\u4e3a\u5f53\u524d\u65f6\u523b\u4e0e1984\u5e741\u67081\u65e50\u65f6\u7684\u65f6\u95f4\u5dee\u3002\u8282\u70b9\u5c06\u6b64\u65f6\u95f4\u5b58\u50a8\u5728\u5bf9\u8c61\u5b57\u51781012h\u7684\u7d22\u5f15\u4e2d\u3002 PDO(Process Object) PDO\u670d\u52a1\u7528\u4e8e\u5728\u8bbe\u5907\u4e4b\u95f4\u4f20\u8f93\u5b9e\u65f6\u6570\u636e\uff0c\u4f8b\u5982\u6d4b\u91cf\u6570\u636e(\u5982\u4f4d\u7f6e\u6570\u636e)\u6216\u547d\u4ee4\u6570\u636e(\u5982\u626d\u77e9\u8bf7\u6c42)\u3002 SDO(Sever D Object) \u7528\u4e8e\u8bbf\u95ee/\u66f4\u6539CANopen\u8bbe\u5907\u7684\u5bf9\u8c61\u5b57\u5178\u4e2d\u7684\u503c\u2014\u2014\u4f8b\u5982\uff0c\u5f53\u5e94\u7528\u7a0b\u5e8f\u4e3b\u673a\u9700\u8981\u66f4\u6539CANopen\u8bbe\u5907\u7684\u67d0\u4e9b\u914d\u7f6e\u65f6\u3002 Heartbeat Heartbeat\u670d\u52a1\u6709\u4e24\u4e2a\u7528\u9014: \u63d0\u4f9b\u201c\u6d3b\u52a8\u201d\u6d88\u606f\u548c\u786e\u8ba4NMT\u547d\u4ee4\u3002 OD(Object Dictionary\uff0c\u5bf9\u8c61\u5b57\u5178) \u4ec0\u4e48\u662f\u5bf9\u8c61\u5b57\u5178\uff1f \u5bf9\u8c61\u5b57\u5178\u662f\u4e00\u4e2a\u6807\u51c6\u7684\u6570\u636e\u7ed3\u6784\uff0c\u63cf\u8ff0\u4e86CANopen\u8282\u70b9\u7684\u4e0d\u540c\u7684\u5bf9\u8c61\u53c2\u6570\u7279\u6027\u3002 \u6bcf\u4e2aCANopen\u8282\u70b9\u90fd\u5305\u542b\u4e00\u4e2a\u5bf9\u8c61\u5b57\u5178\uff0c\u4f7f\u7528ESD\u6587\u4ef6\u6765\u8bb0\u5f55\u8282\u70b9\u53c2\u6570\u3002 Master\u8282\u70b9\u53ef\u901a\u8fc7SDO(\u4e14\u53ea\u80fd\u901a\u8fc7SDO)\u6765\u8bbf\u95ee\u548c\u914d\u7f6eSlave\u8282\u70b9\u7684\u5bf9\u8c61\u5b57\u5178\u3002 \u5bf9\u8c61\u5b57\u5178\u4e2d\u6bcf\u4e2a\u5bf9\u8c61\u7684\u6784\u6210 Index (\u7d22\u5f15)\uff1a16\u4f4d\u5bf9\u8c61\u7684\u57fa\u5730\u5740\uff0c\u5176\u8303\u56f4\u57280x0000\u52300xFFFF\u4e4b\u95f4\u3002 Sub Index (\u5b50\u7d22\u5f15)\uff1a\u4e3a\u4e86\u907f\u514d\u6570\u636e\u5927\u91cf\u65f6\u65e0\u7d22\u5f15\u53ef\u5206\u914d\uff0c\u6240\u4ee5\u5728\u67d0\u4e9b\u7d22\u5f15\u4e0b\u4e5f\u5b9a\u4e49\u4e86\u4e00\u4e2a8\u4f4d\u7684\u7d22\u5f15\u503c\uff0c\u5176\u8303\u56f4\u662f0x00\u52300xFF \u4e4b\u95f4\u3002 Object name (\u5bf9\u8c61\u540d\u79f0): \u5982\uff1a\u5236\u9020\u5546\u8bbe\u5907\u540d\u79f0\u3002 Object type(\u76ee\u6807\u7c7b\u578b): \u53d8\u91cf\u3001\u6570\u7ec4\u6216\u8bb0\u5f55\u3002 Data type (\u6570\u636e\u7c7b\u578b): \u4f8b\u5982 \u5b57\u7b26\u4e32\u7c7b\u578b, UNSIGNED32\u7c7b\u578bUNSIGNED16\u7c7b\u578b\u3002 Access (\u8bbf\u95ee\u6743\u9650)\uff1arw (read/write), ro (read-only), wo (write-only)\u3002 Default Value(\u9ed8\u8ba4\u503c): Category (\u7c7b\u578b)\uff1a\u6307\u5b9a\u6b64\u53c2\u6570\u662f\u5426\u4e3a\u5f3a\u5236/\u53ef\u9009(M/O)\u3002 \u56fe x EDS(The Electronic Data Sheet) \u5728\u5b9e\u9645\u4f7f\u7528\u4e2d\uff0c\u914d\u7f6e\u6216\u7ba1\u7406\u590d\u6742\u7684 CANopen \u7f51\u7edc\u5c06\u4f7f\u7528\u8f6f\u4ef6\u5de5\u5177\u6765\u5b8c\u6210\uff0cCiA 306\u6807\u51c6\u5b9a\u4e49\u4e86\u4e00\u4e2a\u4eba\u7c7b\u53ef\u8bfb\u7684\u4e14\u5bf9\u673a\u5668\u53cb\u597d\u7684\u51fa\u5382\u6587\u4ef6\u683c\u5f0f\u5373EDS\u683c\u5f0f\u6587\u4ef6\uff0c\u4f5c\u4e3a\u8bbe\u5907OD\u7684\u201c\u6a21\u677f\u201d\u3002EDS\u6587\u4ef6\u901a\u5e38\u7531\u8bbe\u5907\u4f9b\u5e94\u5546\u63d0\u4f9b\uff0c\u5305\u542b\u6240\u6709\u8bbe\u5907\u5bf9\u8c61(\u4f46\u4e0d\u5305\u542b\u53c2\u6570\u503c)\u7684\u4fe1\u606f\u3002\u7b80\u800c\u8a00\u4e4b\uff0cEDS\u662f\u7531CANopen\u8bbe\u5907\u5382\u5546\u63d0\u4f9b\u7684\u4e0d\u5e26\u53c2\u6570\u7684\u8bbe\u5907OD\u6a21\u677f\u3002 \u5bf9\u8c61\u5b57\u5178\u7f16\u8f91\u5668 \u5bf9\u8c61\u5b57\u5178\u7f16\u8f91\u5668\u662f\u7528\u4e8eCANopen\u5bf9\u8c61\u5b57\u5178\u3001\u8bbe\u5907\u4fe1\u606f\u7b49\u7684GUI\u7f16\u8f91\u5668\uff0c\u53ef\u5c06 EDS \u683c\u5f0f\u6587\u4ef6\u5bfc\u5165\uff0c\u901a\u8fc7\u7f16\u8f91\u5668\u7f16\u8f91\u8d4b\u503c\u540e\u5bfc\u51fa\u6210 CANopen\u5bf9\u8c61\u5b57\u5178\u7684C\u6e90\u4ee3\u7801\u6587\u4ef6\u3002\u5bfc\u51fa\u7684\u5728\u4e24\u4e2a\u6e90\u4ee3\u7801\u6587\u4ef6CO_OD.c\u548cCO_OD.h\u6587\u4ef6\u5c31\u662f\u6211\u4eec\u6700\u7ec8\u5728\u8f6f\u4ef6\u5f00\u53d1\u65f6\u9700\u8981\u7684\u5bf9\u8c61\u5b57\u5178\u6e90\u6587\u4ef6\u3002 CANopen\u4e3b\u7ad9\u548c\u4ece\u7ad9 \u5177\u6709\u7f51\u7edc\u7ba1\u7406\uff08Network Management\uff1a\u7b80\u79f0NMT\uff09\u4e3b\u673a\u529f\u80fd\u7684\u8bbe\u5907\u901a\u5e38\u88ab\u79f0\u4e3aCANopen\u4e3b\u7ad9\u8bbe\u5907\uff0c\u901a\u5e38\u4e5f\u5177\u6709\u670d\u52a1\u6570\u636e\uff08Service Date Object\uff1a\u7b80\u79f0SDO\uff09\u5ba2\u6237\u7aef\u529f\u80fd\u3002\u53cd\u4e4b\u5177\u6709\u7f51\u7edc\u7ba1\u7406\uff08NMT\uff09\u4ece\u673a\u529f\u80fd\u7684\u8bbe\u5907\u901a\u5e38\u88ab\u79f0\u4e3aCANopen\u4ece\u7ad9\u8bbe\u5907\uff0c\u4e14\u5176\u5fc5\u987b\u5177\u5907\u6709\u670d\u52a1\u6570\u636e\u670d\u52a1\u5668\u529f\u80fd\u3002\u8fd9\u6837CANopen\u4e3b\u7ad9\u8bbe\u5907\u5c31\u53ef\u4ee5\u63a7\u5236\u4ece\u7ad9\u4ee5\u53ca\u8bfb\u5199CANopen\u4ece\u7ad9\u8bbe\u5907\u7684\u5bf9\u8c61\u5b57\u5178\u3002 CANopen\u4ece\u7ad9\u7279\u6027 CANopen\u4ece\u7ad9\u5728CANopen\u7f51\u7edc\u4e2d\u62e5\u6709\u552f\u4e00\u7684\u8282\u70b9\u5730\u5740\uff0c\u5e76\u4e14\u80fd\u72ec\u7acb\u5b8c\u6210\u7279\u5b9a\u7684\u529f\u80fd\uff0c\u4f8b\u5982\u6570\u636e\u91c7\u96c6\u3001\u7535\u673a\u63a7\u5236\u7b49\u7b49\u3002\u5bf9\u5b9e\u65f6\u6027\u8981\u6c42\u9ad8\u7684\u6570\u636e\uff0c\u901a\u5e38\u901a\u8fc7\u5b9e\u65f6\u6570\u636e\u8fc7\u7a0b\uff08Process Data Object\uff1a\u7b80\u79f0PDO\uff09\u8fdb\u884c\u4f20\u8f93\uff0c\u56e0\u6b64CANopen\u4ece\u7ad9\u5e94\u5f53\u652f\u6301\u4e00\u5b9a\u6570\u91cf\u7684PDO\u4f20\u8f93\u529f\u80fd\u3002\u6839\u636eCANopen\u534f\u8baeDS301 V4.02\u7684\u5b9a\u4e49\uff0c\u6bcf\u4e2a\u4ece\u7ad9\u90fd\u9884\u5b9a\u4e49\u4e864\u4e2aTPDO\uff08Transmit Process Data Object\uff1a\u7b80\u79f0TPDO\uff09\u548c4\u4e2aRPDO\uff08Receive Process Data Object\uff09\uff0c\u53e6\u5916\u4ece\u7ad9\u4e5f\u5e94\u5177\u6709\u8282\u70b9/\u5bff\u547d\u4fdd\u62a4\u6216\u5fc3\u8df3\u62a5\u6587\u4ee5\u53ca\u751f\u4ea7\u7d27\u6025\u62a5\u6587\u7b49\u529f\u80fd\u3002\u6bcf\u4e2aCANopen\u4ece\u7ad9\u90fd\u5e94\u6709\u4e00\u4e2a\u5bf9\u8c61\u5b57\u5178\uff0c\u63cf\u8ff0\u4e86\u4ece\u7ad9\u6240\u5177\u6709\u7684\u5e94\u7528\u53c2\u6570\u548c\u901a\u4fe1\u53c2\u6570\u3002 CANopen\u4e3b\u7ad9\u7279\u6027 CANopen\u4e3b\u7ad9\u5728\u7f51\u7edc\u6240\u8d77\u7684\u4f5c\u7528\u6709\u522b\u4e8eCANopen\u4ece\u7ad9\uff0c\u901a\u5e38CANopen\u4e3b\u7ad9\u5728\u7f51\u7edc\u4e2d\u8d1f\u8d23\u7f51\u7edc\u7ba1\u7406\u3001\u4ece\u7ad9\u53c2\u6570\u914d\u7f6e\u4ee5\u53ca\u4ece\u7ad9\u6570\u636e\u7684\u5904\u7406\uff0c\u5176\u5e76\u4e0d\u4e00\u5b9a\u5177\u6709\u7279\u5b9a\u7684\u529f\u80fd\uff0c\u4f46\u4e5f\u6709\u81ea\u5df1\u7684\u5bf9\u8c61\u5b57\u5178\u548c\u552f\u4e00\u7684\u8282\u70b9\u5730\u5740\uff0c\u4e00\u822c\u662fCANopen\u7f51\u7edc\u4e2d\u5177\u5907\u76d1\u63a7\u7684PLC\u6216\u8005PC(\u5f53\u7136\u4e5f\u53ef\u4ee5\u662f\u4e00\u822c\u7684\u529f\u80fd\u8282\u70b9)\u3002 CANopen\u7f51\u7edc\u7ec4\u5efa \u7531\u4e8eCANopen\u662f\u57fa\u4e8eCAN\u603b\u7ebf\u7684\u4e00\u79cd\u5e94\u7528\u5c42\u534f\u8bae\uff0c\u56e0\u6b64\u5176\u7f51\u7edc\u7ec4\u5efa\u4e0eCAN\u603b\u7ebf\u4e00\u81f4\uff0c\u5178\u578b\u7684\u603b\u7ebf\u578b\u7ed3\u6784\uff0c\u4ece\u7ad9\u548c\u4e3b\u7ad9\u90fd\u6302\u63a5\u5728\u8be5\u603b\u7ebf\u4e0a\u5373\u53ef\uff0c\u5728\u4e00\u4e2aCANopen\u7f51\u7edc\u4e2d\u53ea\u80fd\u6709\u4e00\u4e2a\u4e3b\u7ad9\u8bbe\u5907\u548c\u82e5\u5e72\u4e2a\u4ece\u7ad9\u8bbe\u5907\u540c\u65f6\u5de5\u4f5c\u3002CANopen\u7f51\u7edc\u5e03\u7ebf\u65f6\u9009\u7528\u5e26\u5c4f\u853d\u53cc\u7ede\u7ebf\uff0c\u63d0\u9ad8\u603b\u7ebf\u6297\u5e72\u6270\u80fd\u529b\u3002\u8868 x \u6240\u793a\u4e3aCAN\u901a\u4fe1\u6bd4\u7279\u7387\u4e0e\u603b\u7ebf\u957f\u5ea6\u7684\u5173\u7cfb\u3002 \u8868 x Bit rate Bus length 1 Mbit/s 25 m 800 kbit/s 50 m 500 kbit/s 100 m 250 kbit/s 250 m 125 kbit/s 500 m 50 kbit/s 1.000 m 20 kbit/s 2.500 m 10 kbit/s 5.000 m \u6ce8\u610f\uff1a \u603b\u7ebf\u957f\u5ea6\u7684\u4f30\u8ba1\u662f\u57fa\u4e8eCANopen CiA 301 \u89c4\u8303\u5efa\u8bae\u7684\u91c7\u6837\u70b9\u4f4d\u7f6e\u3002 \u603b\u7ebf\u957f\u5ea6\u7684\u4f30\u8ba1\u662f\u57fa\u4e8e5 ns/m\u7684\u4f20\u64ad\u5ef6\u8fdf\u3002\u6b64\u5916\uff0c\u8fd8\u9700\u8981\u8003\u8651\u6240\u7528\u7684CAN\u63a7\u5236\u5668\u3001CAN\u6536\u53d1\u5668\u548c\u5149\u8026\u5408\u5668\u7684\u5ef6\u8fdf\u65f6\u95f4\u3002 \u5982\u56fex\u6240\u793a\u4e3aCANopen\u7f51\u7edc\u7684\u57fa\u672c\u7ed3\u6784\uff0c\u5728\u8be5\u7f51\u7edc\u4e2d\u6709\u4e00\u4e2aCANopen\u4e3b\u7ad9\uff0c\u8d1f\u8d23\u7ba1\u7406\u7f51\u7edc\u4e2d\u7684\u6240\u6709\u4ece\u7ad9\uff0c\u6bcf\u4e2a\u8bbe\u5907\u90fd\u6709\u4e00\u4e2a\u72ec\u7acb\u7684\u8282\u70b9\u5730\u5740\uff08NodeID\uff09\u3002\u4ece\u7ad9\u4e0e\u4ece\u7ad9\u4e4b\u95f4\u4e5f\u80fd\u5efa\u7acb\u901a\u4fe1\uff0c\u901a\u5e38\u9700\u8981\u4e8b\u5148\u5bf9\u5404\u4e2a\u4ece\u7ad9\u8fdb\u884c\u914d\u7f6e\uff0c\u4f7f\u5404\u4e2a\u4ece\u7ad9\u4e4b\u95f4\u80fd\u591f\u5efa\u7acb\u8d77\u72ec\u7acb\u7684PDO\u901a\u4fe1\u3002 \u56fex \u56fex\u6240\u793a\u4e3a\u5e26\u6709\u7f51\u5173\u8bbe\u5907\u7684CANopen\u7f51\u7edc\uff0c\u4e0e\u57fa\u672c\u7684CANopen\u7f51\u7edc\u76f8\u6bd4\uff0c\u8be5\u7f51\u7edc\u4e2d\u589e\u52a0\u4e86\u4e00\u4e2aCANopen\u7f51\u5173\u8bbe\u5907\uff0c\u8be5\u7f51\u5173\u8bbe\u5907\u53ef\u4ee5\u662fCANopen\u8f6cDeviceNet\u3001Profibus\u3001Modbus\u6216\u5176\u5b83\u7684\u8bbe\u5907\u3002\u5728CANopen\u7f51\u7edc\u4e2d\uff0c\u6211\u4eec\u4e5f\u53ef\u628a\u8be5\u7f51\u5173\u8bbe\u5907\u4f5c\u4e3a\u4e00\u4e2a\u4ece\u7ad9\u8bbe\u5907\u6216\u8005\u662fCANopen\u4e3b\u7ad9\u8bbe\u5907\u3002 \u56fex NMT\u7f51\u7edc\u7ba1\u7406 \u4e3a\u5b9e\u73b0CANopen\u7f51\u7edc\u7a33\u5b9a\u53ef\u9760\u9ad8\u6548\u8fd0\u884c\uff0c\u9700\u8981\u5bf9CANopen\u7f51\u7edc\u8fdb\u884c\u7f51\u7edc\u7ba1\u7406\uff0cNMT\u4e3b\u673a\u901a\u8fc7\u4e0b\u53d1\u547d\u4ee4\uff0c\u6765\u63a7\u5236NMT\u4ece\u673a\u8fdb\u884c\u6709\u5e8f\u5de5\u4f5c\uff0c\u6545\u6bcf\u4e2aCANopen\u534f\u8bae\u6808\u4e2d\u90fd\u5177\u6709NMT\u7f51\u7edc\u7ba1\u7406\u7684\u529f\u80fd\u3002 CANopen\u8282\u70b9\u8bbe\u5907\u8fd0\u884c\u65f6\u5b58\u5728\u516d\u79cd\u72b6\u6001\uff1a \u521d\u59cb\u5316 \u8282\u70b9\u4e0a\u7535\u540e\u5bf9\u529f\u80fd\u90e8\u4ef6\u5305\u62ecCAN\u63a7\u5236\u5668\u8fdb\u884c\u521d\u59cb\u5316\u3002 \u5e94\u7528\u5c42\u590d\u4f4d \u8282\u70b9\u4e2d\u7684\u5e94\u7528\u7a0b\u5e8f\u590d\u4f4d\uff08\u5f00\u59cb\uff09\uff0c\u6bd4\u5982\u5f00\u5173\u91cf\u8f93\u51fa\u3001\u6a21\u62df\u91cf\u8f93\u51fa\u7684\u521d\u59cb\u503c\u3002 \u4f1a\u8bdd\u5c42\u590d\u4f4d \u8282\u70b9\u4e2d\u7684CANopen\u901a\u8baf\u590d\u4f4d\uff08\u5f00\u59cb\uff09\uff0c\u4ece\u8fd9\u4e2a\u65f6\u523b\u8d77\uff0c\u6b64\u8282\u70b9\u5c31\u53ef\u4ee5\u8fdb\u884cCANopen\u901a\u8baf\u4e86\u3002 \u9884\u64cd\u4f5c\u72b6\u6001 \u8282\u70b9\u7684CANopen\u901a\u8baf\u5904\u4e8e\u64cd\u4f5c\u5c31\u7eea\u72b6\u6001\uff0c\u6b64\u65f6\u6b64\u8282\u70b9\u4e0d\u80fd\u8fdb\u884cPDO\u901a\u4fe1\uff0c\u800c\u53ef\u4ee5\u8fdb\u884cSDO\u8fdb\u884c\u53c2\u6570\u914d\u7f6e\u548cNMT\u7f51\u7edc\u7ba1\u7406\u7684\u64cd\u4f5c\u3002 \u64cd\u4f5c\u72b6\u6001 \u8282\u70b9\u6536\u5230NMT\u4e3b\u673a\u53d1\u6765\u7684\u542f\u52a8\u547d\u4ee4\u540e\uff0cCANopen\u901a\u8baf\u88ab\u6fc0\u6d3b\uff0cPDO\u901a\u4fe1\u542f\u52a8\u540e\uff0c\u6309\u7167\u5bf9\u8c61\u5b57\u5178\u91cc\u9762\u89c4\u5b9a\u7684\u89c4\u5219\u8fdb\u884c\u4f20\u8f93\uff0c\u540c\u6837SDO\u4e5f\u53ef\u4ee5\u5bf9\u8282\u70b9\u8fdb\u884c\u6570\u636e\u4f20\u8f93\u548c\u53c2\u6570\u4fee\u6539\u3002 \u505c\u6b62\u72b6\u6001 \u8282\u70b9\u6536\u5230NMT\u4e3b\u673a\u53d1\u6765\u7684\u505c\u6b62\u547d\u4ee4\u540e\uff0c\u8282\u70b9\u7684PDO\u901a\u4fe1\u88ab\u505c\u6b62\uff0c\u4f46SDO\u548cNMT\u7f51\u7edc\u7ba1\u7406\u4f9d\u7136\u53ef\u4ee5\u5bf9\u8282\u70b9\u8fdb\u884c\u64cd\u4f5c\u3002 \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u4e0a\u8ff0\u516d\u79cd\u72b6\u6001\u4e2d\u9664\u4e86\u521d\u59cb\u5316\u72b6\u6001\u5916\uff0c\u90fd\u53ef\u4ee5\u901a\u8fc7NMT\u4e3b\u673a\u53d1\u9001NMT\u547d\u4ee4\u8ba9CANopen\u7f51\u7edc\u4e2d\u4efb\u610f\u4e00\u4e2a\u8282\u70b9\u8fdb\u884c\u5176\u4ed65\u79cd\u72b6\u6001\u7684\u5207\u6362\u3002 \u56fex CANopenNode\u7b80\u4ecb CANopenNode\u662f\u4e00\u6b3e\u514d\u8d39\u548c\u5f00\u6e90\u7684CANopen\u534f\u8bae\u6808\uff0c\u4f7f\u7528\u7528ANSI C\u8bed\u8a00\u4ee5\u9762\u5411\u5bf9\u8c61\u7684\u65b9\u5f0f\u7f16\u5199\u7684\u3002\u5b83\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u5fae\u63a7\u5236\u5668\u4e0a\u8fd0\u884c\uff0c\u4f5c\u4e3a\u72ec\u7acb\u7684\u5e94\u7528\u7a0b\u5e8f\u6216\u4e0eRTOS\u4e00\u8d77\u8fd0\u884c\u3002 \u53d8\u91cf\uff08\u901a\u4fe1\u3001\u8bbe\u5907\u3001\u81ea\u5b9a\u4e49\uff09\u88ab\u6536\u96c6\u5728CANopen\u5bf9\u8c61\u5b57\u5178\u4e2d\uff0c\u5e76\u4e14\u53ef\u4ee5\u4ee5\u4e24\u79cd\u65b9\u5f0f\u4fee\u6539\uff1aC\u6e90\u4ee3\u7801\u548cCANopen\u7f51\u7edc\u3002 CANopenNode\u7684\u4e3b\u9875\u662f\u4f4d\u4e8e\uff1a https://github.com/CANopenNode/CANopenNode CANopenNode vs CAN Festival \u8868 x Feature CANopenNode CANFestival License Apache v2.0 LGPLv2 NMT master / slave \u2713 / \u2713 \u2713 / \u2713 SDO client / server \u2713 / \u2713 \u2713 / \u2713 PDO \u2713 / \u2713 \u2713 / \u2713 \u7d27\u6025\u62a5\u6587 \u2713 / \u2713 \u2713 / \u2713 LLS \u2713 \u2713 Non-volatile storage support \u00d7 \u2713 CANFestival\u548cCANopenNode\u90fd\u662f\u7528\u4e8e\u5728\u5d4c\u5165\u5f0f\u7cfb\u7edf\u4e0a\u5b9e\u73b0CANopen\u534f\u8bae\u901a\u4fe1\u7684\u5f00\u6e90\u8f6f\u4ef6\u534f\u8bae\u6808\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u5b83\u4eec\u4f7f\u7528\u4e86\u4e0d\u540c\u7684\u5f00\u653e\u7a0b\u5ea6\u7684\u5f00\u6e90\u534f\u8bae\u3002CANFestival\u4f7f\u7528LGPLv2\u5f00\u6e90\u534f\u8bae\u3002\u8fd9\u610f\u5473\u7740CANFestival\u7684\u6e90\u4ee3\u7801\u662f\u514d\u8d39\u63d0\u4f9b\u7684\uff0c\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u4f7f\u7528\u3001\u4fee\u6539\u548c\u5206\u53d1\uff0c\u53ea\u8981\u4efb\u4f55\u884d\u751f\u4f5c\u54c1\u4f7f\u7528\u76f8\u540c\u7684GPL\u8bb8\u53ef\u8bc1\u3002\u5982\u679c\u4e00\u4e2a\u516c\u53f8\u5728\u4ea7\u54c1\u4e2d\u4f7f\u7528CANFestival\uff0c\u4ed6\u4eec\u4e5f\u5fc5\u987b\u6309\u7167\u540c\u6837\u7684LGPLv2\u5f00\u6e90\u534f\u8bae\u63d0\u4f9b\u5176\u4ea7\u54c1\u7684\u6e90\u4ee3\u7801\u3002CANopenNode\u4f7f\u7528 Apache v2.0\u5f00\u6e90\u534f\u8bae\u3002\u8fd9\u662f\u4e00\u4e2a\u81ea\u7531\u5ea6\u6bd4LGPLv2\u66f4\u4e3a\u5f00\u53d1\u7684\u4e00\u4e2a\u5f00\u6e90\u534f\u8bae\uff0c\u5141\u8bb8\u5728\u4f7f\u7528\u8f6f\u4ef6\u65b9\u9762\u6709\u66f4\u5927\u7684\u7075\u6d3b\u6027\u3002\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u4f7f\u7528\u3001\u4fee\u6539\u548c\u53d1\u5e03CANopenNode\uff0c\u751a\u81f3\u7528\u4e8e\u5546\u4e1a\u76ee\u7684\uff0c\u800c\u4e0d\u9700\u8981\u53d1\u5e03\u5176\u884d\u751f\u4f5c\u54c1\u7684\u6e90\u4ee3\u7801\u3002 \u83b7\u53d6CANopenNode\u6e90\u7801 \u9009\u62e9 CANopenNode v1.3\uff0c\u8be5\u7248\u672c\u4e3aCANopenNode\u5b98\u65b9\u9a8c\u8bc1\u53d1\u5e03\u7248\u672c\uff0c\u83b7\u53d6\u6e90\u7801\u94fe\u63a5\u5982\u4e0b\uff1a https://github.com/CANopenNode/CANopenNode/releases/tag/v1.3 CANopenNode \u529f\u80fd\u7279\u6027 \u652f\u6301\u542f\u52a8\u3001\u505c\u6b62\u3001\u91cd\u542f\u8bbe\u5907\u7684NMT\u4ece\u673a\u548c\u7b80\u5355\u7684NMT\u4e3b\u673a\u3002 \u652f\u6301\u57fa\u4e8e\u751f\u4ea7\u8005\u6d88\u8d39\u8005\u6a21\u578b\u7684\u5fc3\u8df3\u673a\u5236\u7528\u4e8e\u9519\u8bef\u63a7\u5236\u3002 \u652f\u6301\u7528\u4e8e\u5feb\u901f\u4ea4\u6362\u8fc7\u7a0b\u53d8\u91cf\u7684PDO\u94fe\u63a5\u548c\u52a8\u6001\u6620\u5c04\u3002 \u652f\u6301SDO\u52a0\u901f\u3001\u5206\u6bb5\u548c\u5757\u72b6\u4f20\u8f93\uff0c\u7528\u4e8e\u5bf9\u6240\u6709\u53c2\u6570\u7684\u670d\u52a1\u8bbf\u95ee\u4ee5\u53caSDO\u4e3b\u673a\u3002 \u652f\u6301\u7d27\u6025\u62a5\u6587\u3002 \u652f\u6301\u57fa\u4e8e\u751f\u4ea7\u8005\u6d88\u8d39\u8005\u6a21\u578b\u7684\u540c\u6b65\u673a\u5236\u3002 \u652f\u6301\u65f6\u95f4\u534f\u8bae(\u751f\u4ea7\u8005\u6d88\u8d39\u8005\u6a21\u5f0f)\u3002 \u652f\u6301\u975e\u6613\u5931\u6027\u5b58\u50a8\uff08\u6389\u7535\u4fdd\u5b58\uff09\u3002 \u652f\u6301LSS\u4e3b\u673a\u548c\u4ece\u673a, LSS \u5feb\u901f\u626b\u63cf\u3002 \u5982CANopenNode\u5b98\u65b9README\u6587\u6863\u7ed9\u51fa\u7684\u90a3\u6837\uff0cCANopenNode\u5206\u4e3a\u4e09\u4e2a\u7ebf\u7a0b\u8fdb\u884c\u8fd0\u884c\uff0c\u5206\u522b\u4e3a\uff1a \u4e3b\u7ebf\u7a0b \u8d1f\u8d23\u5904\u7406\u5927\u90e8\u5206\u534f\u8bae\u6808\u76f8\u5173\u51fd\u6570\u3002 \u5b9a\u65f6\u4e2d\u65ad\u7ebf\u7a0b 1ms\u6267\u884c\u4e00\u6b21\uff0c\u8d1f\u8d23\u5904\u7406\u548c\u65f6\u95f4\u76f8\u5173\u7684\u4efb\u52a1\u3002 CAN\u63a5\u6536\u7ebf\u7a0b \u5f53\u63a5\u6536\u5230CAN\u5e27\u65f6\u8fdb\u5165\u5230\u8fd9\u91cc\u5e76\u5904\u7406\u3002 ----------------------- | Program start | ----------------------- | ----------------------- | CANopen init | ----------------------- | ----------------------- | Start threads | ----------------------- | | | -------------------- | -------------------- | | | ----------------------- ----------------------- ----------------------- | CAN receive thread | | Timer interval thread | | Mainline thread | | | | | | | | - Fast response. | | - Realtime thread with| | - Processing of time | | - Detect CAN ID. | | constant interval, | | consuming tasks | | - Partially process | | typically 1ms. | | in CANopen objects: | | messages and copy | | - Network synchronized| | - SDO server, | | data to target | | - Copy inputs (RPDOs, | | - Emergency, | | CANopen objects. | | HW) to Object Dict. | | - Network state, | | | | - May call application| | - Heartbeat. | | | | for some processing.| | - May cyclically call | | | | - Copy variables from | | application code. | | | | Object Dictionary to| | | | | | outputs (TPDOs, HW).| | | ----------------------- ----------------------- ----------------------- ----------------------- | SDO client (optional) | | | | - Can be called by | | external application| | - Can read or write | | any variable from | | Object Dictionary | | from any node in the| | CANopen network. | ----------------------- ----------------------- | LSS client (optional) | | | | - Can be called by | | external application| | - Can do LSS requests | | - Can request node | | enumeration | ----------------------- CANopenNode Basic API List initialize CANopen CO_ReturnError_t CO_init(void *CANdriverState, uint8_t nodeId, uint16_t bitRate) Initialize CANopen stack. Function must be called in the communication reset section. Start CAN void CO_CANsetNormalMode(CO_CANmodule_t *CANmodule) Request CAN normal (opearational) mode CANopen process CO_NMT_reset_cmd_t CO_process(CO_t co, uint16_t timeDifference_ms, uint16_t timerNext_ms) Process CANopen objects. Function must be called cyclically. It processes all \"asynchronous\" CANopen objects. Process Sync bool_t CO_process_SYNC( CO_t *co, uint32_t timeDifference_us) Process CANopen SYNC objects. Function must be called cyclically from real time thread with constant interval (1ms typically). It processes SYNC CANopen objects. Read inputs void CO_process_RPDO(CO_t *co, bool_t syncWas) Process CANopen RPDO objects. Function must be called cyclically from real time thread with constant. interval (1ms typically). It processes receive PDO CANopen objects. Write outputs void CO_process_TPDO(CO_t *co, bool_t syncWas, uint32_t timeDifference_us) Process CANopen TPDO objects. Function must be called cyclically from real time thread with constant. interval (1ms typically). It processes transmit PDO CANopen objects. CAN interrupt function void CO_CANinterrupt(CO_CANmodule_t *CANmodule) Receives and transmits CAN messages. Function must be called directly from high priority CAN interrupt. \u57fa\u4e8eMM32G5330\u79fb\u690dCANopenNode CANopenNode\u8f6f\u4ef6\u5305\u7684\u6e90\u6587\u4ef6 CANopenNode-1.3: \u2502 .clang-format \u2502 .gitignore \u2502 CANopen.c \u2502 CANopen.h \u2502 codingStyle \u2502 CO_driver.h \u2502 CO_types.h \u2502 Doxyfile \u2502 LICENSE \u2502 LICENSE.old \u2502 Makefile \u2502 README.md \u2502 \u251c\u2500example \u2502 \u2502 application.c \u2502 \u2502 application.h \u2502 \u2502 CO_OD.c \u2502 \u2502 CO_OD.h \u2502 \u2502 IO.eds \u2502 \u2502 IO.html \u2502 \u2502 main.c \u2502 \u2502 _project.html \u2502 \u2502 _project.xml \u2502 \u2502 \u2502 \u2514\u2500CO_OD_with_trace \u2502 CO_OD.c \u2502 CO_OD.h \u2502 \u2514\u2500stack \u2502 CO_Emergency.c \u2502 CO_Emergency.h \u2502 CO_HBconsumer.c \u2502 CO_HBconsumer.h \u2502 CO_LSS.h \u2502 CO_LSSmaster.c \u2502 CO_LSSmaster.h \u2502 CO_LSSslave.c \u2502 CO_LSSslave.h \u2502 CO_NMT_Heartbeat.c \u2502 CO_NMT_Heartbeat.h \u2502 CO_PDO.c \u2502 CO_PDO.h \u2502 CO_SDO.c \u2502 CO_SDO.h \u2502 CO_SDOmaster.c \u2502 CO_SDOmaster.h \u2502 CO_SYNC.c \u2502 CO_SYNC.h \u2502 CO_TIME.c \u2502 CO_TIME.h \u2502 CO_trace.c \u2502 CO_trace.h \u2502 crc16-ccitt.c \u2502 crc16-ccitt.h \u2502 \u251c\u2500drvTemplate \u2502 CO_driver.c \u2502 CO_driver_target.h \u2502 eeprom.c \u2502 eeprom.h \u6ce8\uff1a\u4e0a\u8ff0\u4ec5\u5305\u542b\u79fb\u690d\u7528\u5230\u7684\u6587\u4ef6\u3002 CANopenNode\u7684\u79fb\u690d\u65b9\u6cd5 CANopenNode\u79fb\u690d\u4e2d\u6d89\u53ca\u5230\u4e09\u4e2a\u6587\u4ef6\u9700\u8981\u4fee\u6539\uff1a CANopenNode-1.3/example/main.c \u6587\u4ef6\u3002 CANopenNode-1.3/stack/drvTemplate/CO_driver.c \u6587\u4ef6\u3002 CANopenNode-1.3/stack//drvTemplate/CO_driver_target.h \u6587\u4ef6\u3002 \u5176\u4e2d\uff1a \u5728 mian.c \u6587\u4ef6\u4e2d\u5b9e\u73b0 tmrTask_thread() \u51fd\u6570 \u901a\u52a0\u8f7d\u8fdb\u51651ms \u5b9a\u65f6\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u8fdb\u884c 1ms \u5b9a\u65f6\u7684\u4fe1\u606f\u540c\u6b65\u3002 \u5728 CO_driver.c \u6587\u4ef6\u4e2d\u5b9e\u73b0 CO_CANmodule_init() \u51fd\u6570 \u7528\u4e8e\u5bf9 MCU \u4e2d\u7684 CAN \u6a21\u5757\u8fdb\u884c\u521d\u59cb\uff0c\u5e76\u914d\u7f6eCAN\u62a5\u6587\u7684\u6536\u53d1\u53c2\u6570\u4ee5\u53ca\u5f00\u542f flexcan \u4e2d\u65ad\u3002 \u5728 CO_driver.C \u6587\u4ef6\u4e2d\u5b9e\u73b0 CO_CANinterrupt() \u51fd\u6570 \u7528\u4e8e\u5b9e\u73b0\u63a5\u6536\u548c\u53d1\u9001CAN\u4fe1\u606f\u3002\u8be5\u529f\u80fd\u4ece\u9ad8\u4f18\u5148\u7ea7\u7684CAN\u4e2d\u65ad\u4e2d\u76f4\u63a5\u8c03\u7528\u3002 \u5728 CO_driver.C \u6587\u4ef6\u4e2d\u5b9e\u73b0 CO_CANverifyErrorst() \u51fd\u6570 \u7528\u4e8e\u5bf9 CAN \u603b\u7ebf\u8fdb\u884c\u9519\u8bef\u68c0\u6d4b\u548c\u4e0a\u62a5\u3002 \u57fa\u4e8eFlexCAN\u5916\u8bbe\u79fb\u690dCANopenNode \u4e0b\u9762\u6211\u4eec\u5c06\u4ee5MM32G5330\u5fae\u63a7\u5236\u5668\u4e0a\u96c6\u6210\u7684FlexCAN\u4e3a\u4f8b\uff0c\u5b9e\u73b0\u5bf9CANopenNode v1.3\u7684\u79fb\u690d\u8fc7\u7a0b\u3002 \u9996\u5148\u5728\u7075\u52a8\u5b98\u7f51\u4e0b\u8f7d\u57fa\u4e8eMini-G5330\u5f00\u53d1\u677f\u7684FlexCAN_Interrupt\u6837\u4f8b\u5de5\u7a0b\uff0c\u5e76\u5728MM32G5330\u7684\u6839\u76ee\u5f55\u6587\u4ef6\u5939\u4e0b\u521b\u5efaCANopenNode\u6587\u4ef6\u5939\u3002\u5c06CANopenNode v1.3\u8f6f\u4ef6\u5305\u4e2d\u5305\u542b\u7684\u4e0b\u5217\u6587\u4ef6\u65e0\u9700\u4fee\u6539\uff0c\u539f\u5c01\u4e0d\u52a8\u5730\u590d\u5236\u5230\u65b0\u5efa\u7684 CANopenNode \u6587\u4ef6\u5939\u4e2d\u3002 ./CANopen.c&h ./CO_types.h ./stack/CO_Emergency.c&h ./stack/CO_HBconsumer.c&h ./stack/CO_LSS.h ./stack/CO_LSSmaster.c&h ./stack/CO_LSSslave.c&h ./stack/CO_NMT_Heartbeat.c&h ./stack/CO_PDO.c&h ./stack/CO_SDO.c&h ./stack/CO_SDOmaster.c&h ./stack/CO_SYNC.c&h ./stack/CO_TIME.c&h ./stack/CO_trace.c&h ./stack/crc16-ccitt.c&h \u5982\u4e0b\u56fex\u6240\u793a\uff1a \u56fe x \u63a5\u7740\u5c06CANopenNode\u6e90\u7801\u4e2d\u63d0\u4f9b\u7684example\u6587\u4ef6\u5939\u7684\u7ed3\u6784\u5982\u4e0b\u56fex\u6240\u793a\uff0c\u5176\u4e2dCO_OD.c/h\u662f CANopen\u4e2d\u4f7f\u7528\u5230\u7684\u5bf9\u8c61\u5b57\u5178\uff0c \u6211\u4eec\u5c06\u8fd9\u4e24\u4e2a\u6587\u4ef6\u590d\u5236\u5230 MM32G5330\u6837\u4f8b\u5de5\u7a0b\u7684board\u6587\u4ef6\u5939\u4e0b\u3002main.c\u662f CANopenNode\u7684\u4e3b\u7a0b\u5e8f\u6587\u4ef6\uff0c\u6211\u4eec\u5c06\u5c06\u539f\u6709\u7684main.c\u6587\u4ef6\u8fdb\u884c\u66ff\u6362\u3002 \u56fe x \u6700\u540e\u5c06\u5982\u56fex\u6240\u793a\u7684\u4f4d\u4e8eCANopenNode-1.3/stack/drvTemplate\u6587\u4ef6\u5939\u4e0b\u7684CO_driver.c\u53caCO_driver_target.h\u8fd9\u4e24\u4e2a\u6587\u4ef6\u590d\u5236\u5230\u6837\u4f8b\u5de5\u7a0b\u7684\u6587\u4ef6\u5939\u4e0b\u3002 \u56fe x \u7531\u4e8e\u672c\u6b21\u79fb\u690d\u662f\u57fa\u4e8e\u88f8\u673a\u79fb\u690d\uff0c\u6545\u6309\u7167CANopenNode\u7684\u8bbe\u8ba1\u5c06Mainline\u7ebf\u7a0b\u653e\u5165while(1)\u4e2d\uff0cCAN\u63a5\u6536\u7ebf\u7a0b\u653e\u5165flexcan\u7684\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\u4e2d\uff0c\u5b9a\u65f6\u7ebf\u7a0b\u653e\u5728\u4e00\u4e2a1ms\u7684\u5b9a\u65f6\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\u4e2d\u3002 \u5728 main.c \u6587\u4ef6\u4e2d\u914d\u7f6e\u5b9a\u65f6\u5668 /* Setup the timer. */ void app_tim_init(void) { NVIC_InitTypeDef NVIC_InitStruct; TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct; RCC_ClocksTypeDef RCC_Clocks; RCC_GetClocksFreq(&RCC_Clocks); RCC_APB2PeriphClockCmd(RCC_APB2ENR_TIM1, ENABLE); TIM_TimeBaseStructInit(&TIM_TimeBaseInitStruct); TIM_TimeBaseInitStruct.TIM_Prescaler = (RCC_Clocks.PCLK2_Frequency / APP_TIM_UPDATE_STEP - 1); TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_COUNTERMODE_UP; TIM_TimeBaseInitStruct.TIM_Period = (APP_TIM_UPDATE_PERIOD - 1); TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStruct.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM1, &TIM_TimeBaseInitStruct); TIM_ClearFlag(TIM1, TIM_IT_UPDATE); TIM_ITConfig(TIM1, TIM_IT_UPDATE, ENABLE); NVIC_InitStruct.NVIC_IRQChannel = TIM1_UP_IRQn; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&NVIC_InitStruct); } void TIM1_UP_IRQHandler(void) { TIM_ClearITPendingBit(TIM1, TIM_IT_UPDATE); tmrTask_thread(); } \u5728 main.c \u6587\u4ef6\u4e2d\u5b9e\u73b0\u5b9a\u65f6\u7ebf\u7a0b\u4efb\u52a1\u5904\u7406 /* timer thread executes in constant intervals ********************************/ void tmrTask_thread(void){ INCREMENT_1MS(CO_timer1ms); if (CO->CANmodule[0]->CANnormal) { bool_t syncWas; /* Process Sync */ syncWas = CO_process_SYNC(CO, TMR_TASK_INTERVAL); /* Read inputs */ CO_process_RPDO(CO, syncWas); /* Further I/O or nonblocking application code may go here. */ /* Write outputs */ CO_process_TPDO(CO, syncWas, TMR_TASK_INTERVAL); /* verify timer overflow */ if((TIM_GetITStatus(TIM1, TIM_IT_UPDATE) & TIM_IT_UPDATE) != 0u) { CO_errorReport(CO->em, CO_EM_ISR_TIMER_OVERFLOW, CO_EMC_SOFTWARE_INTERNAL, 0u); TIM_ClearITPendingBit(TIM1, TIM_IT_UPDATE); } } } \u5728 main.c \u6587\u4ef6\u4e2d\u5b9e\u73b0 FlexCAN \u7684\u4e2d\u65ad\u670d\u52a1\u51fd\u6570 /* CAN interrupt function *****************************************************/ void FLEXCAN_IRQHandler(void) { FLEXCAN_TransferHandleIRQ(FLEXCAN, &FlexCAN_Handle); CO_CANinterrupt(CO->CANmodule[0]); __DSB(); } \u5728 CO_driver.c \u6587\u4ef6\u4e2d\u5b9e\u73b0FlexCAN\u6a21\u5757\u521d\u59cb\u5316 void FlexCAN_Configure(uint32_t can_bitrate) { GPIO_InitTypeDef GPIO_InitStruct; NVIC_InitTypeDef NVIC_InitStruct; RCC_ClocksTypeDef RCC_Clocks; flexcan_config_t FlexCAN_ConfigStruct; flexcan_rx_mb_config_t FlexCAN_RxMB_ConfigStruct; RCC_GetClocksFreq(&RCC_Clocks); RCC_APB1PeriphClockCmd(RCC_APB1PERIPH_FLEXCAN, ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBENR_GPIOA, ENABLE); GPIO_PinAFConfig(GPIOA, GPIO_PINSOURCE11, GPIO_AF_9); GPIO_PinAFConfig(GPIOA, GPIO_PINSOURCE12, GPIO_AF_9); GPIO_StructInit(&GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = GPIO_PIN_11; GPIO_InitStruct.GPIO_Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.GPIO_Mode = GPIO_MODE_FLOATING; GPIO_Init(GPIOA, &GPIO_InitStruct); GPIO_StructInit(&GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = GPIO_PIN_12; GPIO_InitStruct.GPIO_Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.GPIO_Mode = GPIO_MODE_AF_PP; GPIO_Init(GPIOA, &GPIO_InitStruct); NVIC_InitStruct.NVIC_IRQChannel = FLEXCAN_IRQn; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&NVIC_InitStruct); FLEXCAN_GetDefaultConfig(&FlexCAN_ConfigStruct); FlexCAN_ConfigStruct.baudRate = can_bitrate*1000; FlexCAN_ConfigStruct.clkSrc = Enum_Flexcan_ClkSrc1; FlexCAN_ConfigStruct.enableLoopBack = false; FlexCAN_ConfigStruct.disableSelfReception = true; FlexCAN_ConfigStruct.enableIndividMask = true; #if 1 /* Baudrate calculate by automatically */ FLEXCAN_CalculateImprovedTimingValues(FlexCAN_ConfigStruct.baudRate, RCC_Clocks.PCLK1_Frequency, &FlexCAN_ConfigStruct.timingConfig); #else /* You can modify the parameters yourself */ FlexCAN_ConfigStruct.timingConfig.preDivider = 23; FlexCAN_ConfigStruct.timingConfig.propSeg = 6; FlexCAN_ConfigStruct.timingConfig.phaseSeg1 = 3; FlexCAN_ConfigStruct.timingConfig.phaseSeg2 = 3; FlexCAN_ConfigStruct.timingConfig.rJumpwidth = 3; #endif FLEXCAN_Init(FLEXCAN, &FlexCAN_ConfigStruct); /* Set Tx MB_2. */ FLEXCAN_TxMbConfig(FLEXCAN, BOARD_FLEXCAN_TX_MB_CH, ENABLE); FLEXCAN_TransferCreateHandle(FLEXCAN, &FlexCAN_Handle, FlexCAN_Transfer_Callback, NULL); /* Set Rx MB_0. */ FlexCAN_RxMB_ConfigStruct.id = FLEXCAN_ID_STD(0x222); FlexCAN_RxMB_ConfigStruct.format = Enum_Flexcan_FrameFormatStandard; FlexCAN_RxMB_ConfigStruct.type = Enum_Flexcan_FrameTypeData; FLEXCAN_RxMbConfig(FLEXCAN, BOARD_FLEXCAN_RX_MB_CH, &FlexCAN_RxMB_ConfigStruct, ENABLE); /* Set Rx Individual Mask. */ FLEXCAN_SetRxIndividualMask(FLEXCAN, BOARD_FLEXCAN_RX_MB_CH, FLEXCAN_RX_MB_STD_MASK(0x000, 0, 0)); FlexCAN_MB0_FrameStruct.length = (uint8_t)(8); FlexCAN_MB0_FrameStruct.type = (uint8_t)Enum_Flexcan_FrameTypeData; FlexCAN_MB0_FrameStruct.format = (uint8_t)Enum_Flexcan_FrameFormatStandard; FlexCAN_MB0_FrameStruct.id = FLEXCAN_ID_STD(0x222); FlexCAN_MB0_TransferStruct.mbIdx = BOARD_FLEXCAN_RX_MB_CH; FlexCAN_MB0_TransferStruct.frame = &FlexCAN_MB0_FrameStruct; FLEXCAN_TransferReceiveNonBlocking(FLEXCAN, &FlexCAN_Handle, &FlexCAN_MB0_TransferStruct); } /******************************************************************************/ CO_ReturnError_t CO_CANmodule_init( CO_CANmodule_t *CANmodule, void *CANdriverState, CO_CANrx_t rxArray[], uint16_t rxSize, CO_CANtx_t txArray[], uint16_t txSize, uint16_t CANbitRate) { uint16_t i; /* verify arguments */ if(CANmodule==NULL || rxArray==NULL || txArray==NULL){ return CO_ERROR_ILLEGAL_ARGUMENT; } /* Configure object variables */ CANmodule->CANdriverState = CANdriverState; CANmodule->rxArray = rxArray; CANmodule->rxSize = rxSize; CANmodule->txArray = txArray; CANmodule->txSize = txSize; CANmodule->CANnormal = false; CANmodule->useCANrxFilters = false;/* microcontroller dependent */ CANmodule->bufferInhibitFlag = false; CANmodule->firstCANtxMessage = true; CANmodule->CANtxCount = 0U; CANmodule->errOld = 0U; CANmodule->em = NULL; for(i=0U; i<rxSize; i++){ rxArray[i].ident = 0U; rxArray[i].mask = 0xFFFFU; rxArray[i].object = NULL; rxArray[i].pFunct = NULL; } for(i=0U; i<txSize; i++){ txArray[i].bufferFull = false; } FlexCAN_Configure(CANbitRate); return CO_ERROR_NO; } \u5728 CO_driver.c \u6587\u4ef6\u4e2d\u5b9e\u73b0FlexCAN\u7684\u62a5\u6587\u6536\u53d1 /* Send a message frame. */ bool flexcan_tx(CO_CANtx_t *buffer) { bool status = false; flexcan_frame_t FlexCAN_FrameStruct; flexcan_mb_transfer_t FlexCAN_MB_TransferStruct; if (!buffer->rtr) { FlexCAN_FrameStruct.type = (uint8_t)Enum_Flexcan_FrameTypeData; /* Data frame type. */ } else { FlexCAN_FrameStruct.type = (uint8_t)Enum_Flexcan_FrameTypeRemote; /* Remote frame type. */ } FlexCAN_FrameStruct.length = (uint8_t)buffer->DLC; FlexCAN_FrameStruct.format = (uint8_t)Enum_Flexcan_FrameFormatStandard; FlexCAN_FrameStruct.id = FLEXCAN_ID_STD(buffer->ident); /* Indicated ID number. */ FlexCAN_FrameStruct.dataByte0 = buffer->data[0]; FlexCAN_FrameStruct.dataByte1 = buffer->data[1]; FlexCAN_FrameStruct.dataByte2 = buffer->data[2]; FlexCAN_FrameStruct.dataByte3 = buffer->data[3]; FlexCAN_FrameStruct.dataByte4 = buffer->data[4]; FlexCAN_FrameStruct.dataByte5 = buffer->data[5]; FlexCAN_FrameStruct.dataByte6 = buffer->data[6]; FlexCAN_FrameStruct.dataByte7 = buffer->data[7]; FlexCAN_MB_TransferStruct.mbIdx = 2; FlexCAN_MB_TransferStruct.frame = &FlexCAN_FrameStruct; if (Status_Flexcan_Success == FLEXCAN_TransferSendNonBlocking(FLEXCAN, &FlexCAN_Handle, &FlexCAN_MB_TransferStruct)) { status = true; } return status; } /******************************************************************************/ CO_ReturnError_t CO_CANsend(CO_CANmodule_t *CANmodule, CO_CANtx_t *buffer){ CO_ReturnError_t err = CO_ERROR_NO; /* Verify overflow */ if(buffer->bufferFull){ if(!CANmodule->firstCANtxMessage){ /* don't set error, if bootup message is still on buffers */ CO_errorReport((CO_EM_t*)CANmodule->em, CO_EM_CAN_TX_OVERFLOW, CO_EMC_CAN_OVERRUN, buffer->ident); } err = CO_ERROR_TX_OVERFLOW; } CO_LOCK_CAN_SEND(); bool tx_mb_status = flexcan_tx(buffer); if(tx_mb_status == true){ CANmodule->bufferInhibitFlag = buffer->syncFlag; } /* if no buffer is free, message will be sent by interrupt */ else{ buffer->bufferFull = true; CANmodule->CANtxCount++; } CO_UNLOCK_CAN_SEND(); return err; } void CO_CANinterrupt(CO_CANmodule_t *CANmodule){ uint32_t status = FLEXCAN->IFLAG1; if (0 != (status & (BOARD_FLEXCAN_RX_MB_STATUS)) || (FlexCAN_MB0_RxCompleteFlag)) { /* receive interrupt */ CO_CANrxMsg_t *rcvMsg; /* pointer to received message in CAN module */ CO_CANrxMsg_t rcvMsgBuff; uint16_t index; /* index of received message */ uint32_t rcvMsgIdent; /* identifier of the received message */ CO_CANrx_t *buffer = NULL; /* receive message buffer from CO_CANmodule_t object. */ bool_t msgMatched = false; /* get message from module here */ rcvMsg = &rcvMsgBuff; rcvMsg->ident = (FlexCAN_MBTemp_FrameStruct.id>> CAN_ID_STD_SHIFT)&0x7FF; rcvMsg->DLC = FlexCAN_MBTemp_FrameStruct.length; rcvMsg->data[0] = FlexCAN_MBTemp_FrameStruct.dataByte0; rcvMsg->data[1] = FlexCAN_MBTemp_FrameStruct.dataByte1; rcvMsg->data[2] = FlexCAN_MBTemp_FrameStruct.dataByte2; rcvMsg->data[3] = FlexCAN_MBTemp_FrameStruct.dataByte3; rcvMsg->data[4] = FlexCAN_MBTemp_FrameStruct.dataByte4; rcvMsg->data[5] = FlexCAN_MBTemp_FrameStruct.dataByte5; rcvMsg->data[6] = FlexCAN_MBTemp_FrameStruct.dataByte6; rcvMsg->data[7] = FlexCAN_MBTemp_FrameStruct.dataByte7; rcvMsgIdent = rcvMsg->ident; FlexCAN_MB0_RxCompleteFlag = 0; /* CAN module filters are not used, message with any standard 11-bit identifier */ /* has been received. Search rxArray form CANmodule for the same CAN-ID. */ buffer = &CANmodule->rxArray[0]; for(index = CANmodule->rxSize; index > 0U; index--){ if(((rcvMsgIdent ^ buffer->ident) & buffer->mask) == 0U){ msgMatched = true; break; } buffer++; } /* Call specific function, which will process the message */ if(msgMatched && (buffer != NULL) && (buffer->pFunct != NULL)){ buffer->pFunct(buffer->object, rcvMsg); } /* Clear interrupt flag */ FLEXCAN_ClearMbStatusFlags(FLEXCAN, BOARD_FLEXCAN_RX_MB_STATUS); } else if (0 != (status & BOARD_FLEXCAN_TX_MB_STATUS)) { /* Clear interrupt flag */ FLEXCAN_ClearMbStatusFlags(FLEXCAN, BOARD_FLEXCAN_TX_MB_STATUS); /* First CAN message (bootup) was sent successfully */ CANmodule->firstCANtxMessage = false; /* clear flag from previous message */ CANmodule->bufferInhibitFlag = false; /* Are there any new messages waiting to be send */ if(CANmodule->CANtxCount > 0U){ uint16_t i; /* index of transmitting message */ /* first buffer */ CO_CANtx_t *buffer = &CANmodule->txArray[0]; /* search through whole array of pointers to transmit message buffers. */ for(i = CANmodule->txSize; i > 0U; i--){ /* if message buffer is full, send it. */ if(buffer->bufferFull){ buffer->bufferFull = false; CANmodule->CANtxCount--; /* Copy message to CAN buffer */ CANmodule->bufferInhibitFlag = buffer->syncFlag; CO_CANsend(CANmodule, buffer); break; /* exit for loop */ } buffer++; }/* end of for loop */ /* Clear counter if no more messages */ if(i == 0U){ CANmodule->CANtxCount = 0U; } } } else{ /* some other interrupt reason */ } } \u5728 CO_driver.c \u6587\u4ef6\u4e2d\u5b9e\u73b0CAN\u603b\u7ebf\u9519\u8bef\u68c0\u6d4b void CO_CANverifyErrors(CO_CANmodule_t *CANmodule){ uint16_t rxErrors, txErrors, overflow; CO_EM_t* em = (CO_EM_t*)CANmodule->em; uint32_t err; /* get error counters from module. Id possible, function may use different way to * determine errors. */ rxErrors = (uint16_t) ((FLEXCAN->ECR & CAN_ECR_RXERRCNT_MASK) >> CAN_ECR_RXERRCNT_SHIFT); txErrors = (uint16_t) ((FLEXCAN->ECR & CAN_ECR_TXERRCNT_MASK) >> CAN_ECR_TXERRCNT_SHIFT); overflow = (uint16_t) ((FLEXCAN->ESR1 & CAN_ESR1_ERROVR_MASK) >> CAN_ESR1_ERROVR_SHIFT); err = ((uint32_t)txErrors << 16) | ((uint32_t)rxErrors << 8) | overflow; if(CANmodule->errOld != err){ CANmodule->errOld = err; if(txErrors >= 256U){ /* bus off */ CO_errorReport(em, CO_EM_CAN_TX_BUS_OFF, CO_EMC_BUS_OFF_RECOVERED, err); } else{ /* not bus off */ CO_errorReset(em, CO_EM_CAN_TX_BUS_OFF, err); if((rxErrors >= 96U) || (txErrors >= 96U)){ /* bus warning */ CO_errorReport(em, CO_EM_CAN_BUS_WARNING, CO_EMC_NO_ERROR, err); } if(rxErrors >= 128U){ /* RX bus passive */ CO_errorReport(em, CO_EM_CAN_RX_BUS_PASSIVE, CO_EMC_CAN_PASSIVE, err); } else{ CO_errorReset(em, CO_EM_CAN_RX_BUS_PASSIVE, err); } if(txErrors >= 128U){ /* TX bus passive */ if(!CANmodule->firstCANtxMessage){ CO_errorReport(em, CO_EM_CAN_TX_BUS_PASSIVE, CO_EMC_CAN_PASSIVE, err); } } else{ bool_t isError = CO_isError(em, CO_EM_CAN_TX_BUS_PASSIVE); if(isError){ CO_errorReset(em, CO_EM_CAN_TX_BUS_PASSIVE, err); CO_errorReset(em, CO_EM_CAN_TX_OVERFLOW, err); } } if((rxErrors < 96U) && (txErrors < 96U)){ /* no error */ CO_errorReset(em, CO_EM_CAN_BUS_WARNING, err); } } if(overflow != 0U){ /* CAN RX bus overflow */ CO_errorReport(em, CO_EM_CAN_RXB_OVERFLOW, CO_EMC_CAN_OVERRUN, err); } } } \u5c06\u4e0a\u8ff0\u6587\u4ef6\u590d\u5236\u5230\u5bf9\u5e94\u7684\u5de5\u7a0b\u6837\u4f8b\u6587\u4ef6\u8def\u5f84\u4e0b\uff0c\u5e76\u5c06\u8fd9\u4e9b\u6587\u4ef6\u6dfb\u52a0\u8fdb\u5de5\u7a0b\u7f16\u8bd1\u6587\u4ef6\u5217\u8868\u4e2d\u540e\uff0c\u7f16\u8bd1\u4e0b\u8f7d\u7a0b\u5e8f\uff0cCANopen\u8282\u70b9\u4e0a\u7ebf\u5411CAN\u7f51\u7edc\u53d1\u9001CANopen\u8282\u70b9\u4e0a\u7ebf\u62a5\u6587\uff0c\u4e0a\u4f4d\u673a\u6536\u5230\u4e00\u6761\u5982\u4e0b\u62a5\u6587\uff1a \u8868x: CAN-ID(hex) Length Data(hex) 70A 1 00 \u4e4b\u540e\u8be5CANopen\u8282\u70b9\u4ee5 1000ms \u7684\u65f6\u95f4\u95f4\u9694\u5411CAN\u7f51\u7edc\u53d1\u9001\u8282\u70b9\u5fc3\u8df3\u62a5\u6587\uff0c\u4e0a\u4f4d\u673a\u4ee51000ms\u7684\u65f6\u95f4\u95f4\u9694\u6536\u5230\u5982\u4e0b\u62a5\u6587\uff1a \u8868x: CAN-ID(hex) Length Data(hex) 70A 1 05 \u5982\u56fex\u6240\u793a\u3002 \u56fex \u81f3\u6b64\uff0c\u53ef\u9a8c\u8bc1\u8be5CANopen\u8282\u70b9\u8bbe\u5907\u6210\u529f\u542f\u52a8\u5e76\u5f00\u59cb\u6b63\u5e38\u8fd0\u884c\u3002 \u540c\u65f6\u5728\u7075\u52a8\u63d0\u4f9b\u7684\u6837\u4f8b\u4e2d\uff0c\u4e5f\u63d0\u4f9b\u4e86\u4e00\u4e9b\u79fb\u690d\u597d\u7684CANopenNode\u6837\u4f8b\u5de5\u7a0b\uff0c\u4f9b\u5927\u5bb6\u9a8c\u8bc1\u6d4b\u8bd5\uff1a CANopen_Basic\u6837\u4f8b \u6f14\u793a\u4e86CANopenNode\u7684\u57fa\u672c\u6837\u4f8b\u529f\u80fd\u3002 CANopen_PDO_TPDO&CANopen_PDO_RPDO\u6837\u4f8b \u6f14\u793a\u4e86CANopen\u7684TPDO\u4e0eRPDO\u4e4b\u95f4\u901a\u4fe1\u7684\u6837\u4f8b\u3002 CANopen_SDO_Server&CANopen_SDO_Client\u6837\u4f8b \u6f14\u793a\u4e86CANopen\u7684SDO Server\u4e0eSDO Client\u4e4b\u95f4\u901a\u4fe1\u7684\u6837\u4f8b\u3002 \u8c03\u8bd5\u4e0e\u5f00\u53d1 \u73af\u5883\u642d\u5efa \u4f7f\u7528\u642d\u8f7d\u4e86MM32G5330 MCU\u7684\u5f00\u53d1\u677fMini-G5330 \uff0c\u4ee5CANopen_Basic\u6837\u4f8b\u5de5\u7a0b\u4e3a\u4f8b\uff0c\u5c06\u5f00\u53d1\u677f\u4e0a\u7684CAN\u6536\u53d1\u5668\u4e0ePCAN\u76f8\u8fde\u63a5\uff0c\u5e76\u5c06PCAN\u4e0ePC\u673a\u901a\u8fc7USB\u76f8\u8fde\u63a5\uff0c\u5728PC\u7aef\uff08\u57fa\u4e8eWin10\u64cd\u4f5c\u7cfb\u7edf\uff09\u4f7f\u7528PCAN-View\u4e0a\u4f4d\u673a\u8fdb\u884cCAN\u901a\u4fe1\uff0c\u5982\u56fex\u6240\u793a\u3002 \u56fex MCU\u4e0ePC\u673a\u4ea4\u4e92\u793a\u610f\u56fe \u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u4e86PCAN-USB\uff0c\u5e76\u4f7f\u7528\u4e86\u5176\u5b98\u65b9\u7684\u914d\u5957\u4e0a\u4f4d\u673aPCAN-View\u3002\u5176PCAN-USB\u9a71\u52a8\u4e0b\u8f7d\u94fe\u63a5\u4e3a\uff1a https://peak-system.com.cn/driver/ \uff1bPCAN-View \u5b89\u88c5\u5305\u4e0b\u8f7d\u94fe\u63a5\u4e3a: https://peak-system.com.cn/wp-content/uploads/2022/06/pcanview.zip \uff1bPCAN-View\u4f7f\u7528\u8bf4\u660e\u89c1\u5982\u4e0b\u94fe\u63a5: https://peak-system.com.cn/software/apsoftware/pcan-view/ \u4e0a\u7535\u8c03\u8bd5 \u5c06\u4e0a\u8ff0\u73af\u5883\u642d\u5efa\u597d\u540e\uff0c\u5c06MCU\u4e0a\u7535\u5e76\u590d\u4f4d\uff0c\u5e76\u901a\u8fc7PC\u7aef\u4e0a\u4f4d\u673aPCAN-View\u6d4b\u8bd5\u5982\u4e0b\u6307\u4ee4\uff0c\u89c2\u5bdfCANopen\u8282\u70b9\u5176\u5bf9\u6307\u4ee4\u7684\u54cd\u5e94\uff0c\u6765\u5224\u65ad\u8be5CANopen\u8282\u70b9\u662f\u5426\u5904\u4e8e\u6b63\u5e38\u8fd0\u884c\u72b6\u6001\u3002 \u5c06NODE-ID\u4e3a0x0A\u7684\u8282\u70b9\u8bbe\u7f6e\u4e3a Stop \u6a21\u5f0f\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 000 2 02 0A \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u53ef\u63a5\u6536\u5230\u5982\u4e0b\u62a5\u6587\uff1a \u56fe x \u5c06NODE-ID\u4e3a0x0A\u7684\u8282\u70b9\u8bbe\u7f6e\u4e3a Start \u6a21\u5f0f\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 000 2 01 0A \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u53ef\u63a5\u6536\u5230\u5982\u4e0b\u62a5\u6587\uff1a \u56fex \u5c06NODE-ID\u4e3a0x0A\u7684\u8282\u70b9\u8bbe\u7f6e\u4e3aPre-operation\u6a21\u5f0f\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 70A 2 80 0A \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u8be5\u8282\u70b9\u8fdb\u5165Pre-operation\u6a21\u5f0f\uff0c\u53ef\u63a5\u6536\u5230\u5982\u4e0b\u62a5\u6587\uff1a \u56fe x \u5c06NODE-ID\u4e3a0x0A\u8282\u70b9\u590d\u4f4d\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 70A 2 81 0A \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u8be5\u8282\u70b9\u88ab\u590d\u4f4d\uff1a \u56fe x \u5c06NODE-ID\u4e3a0x0A\u8282\u70b9\u7684\u901a\u4fe1\u5c42\u590d\u4f4d\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 70A 2 82 0A \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u8be5\u8282\u70b9\u901a\u4fe1\u5c42\u88ab\u590d\u4f4d\uff0c\u91cd\u65b0\u4e0a\u7ebf\uff1a \u56fe x \u83b7\u53d6NODE-ID\u4e3a0x0A\u8282\u70b9\u7684\u5fc3\u8df3\u53d1\u9001\u95f4\u9694\u65f6\u95f4\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 60A 8 40 17 10 00 00 00 00 00 \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u8fd4\u56de\u8be5\u8282\u70b9\u5f53\u524d\u5fc3\u8df3\u53d1\u9001\u95f4\u9694\u65f6\u95f4\u4e3a1000(0x03E8)ms\uff1a \u56fe x \u8bbe\u7f6eNODE-ID\u4e3a0x0A\u8282\u70b9\u7684\u5fc3\u8df3\u53d1\u9001\u95f4\u9694\u65f6\u95f4\u4e3a500(0x01F4)ms\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 60A 8 2B 17 10 00 F4 01 00 00 \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u8be5\u8282\u70b9\u5f53\u524d\u5fc3\u8df3\u53d1\u9001\u95f4\u9694\u65f6\u95f4\u53d8\u4e3a500ms\uff1a \u56fe x \u603b\u7ed3 \u672c\u7ae0\u8282\u8bb2\u89e3\u4e86CANopen\u7684\u57fa\u672c\u6982\u5ff5\uff0c\u5e76\u5bf9CANopenNode\u5f00\u6e90\u534f\u8bae\u6808\u8fdb\u884c\u4e86\u4ecb\u7ecd\uff0c\u8bb2\u89e3\u4e86\u5982\u4f55\u57fa\u4e8eMM32G5330 MCU\u5bf9CANopenNode\u534f\u8bae\u6808\u8fdb\u884c\u79fb\u690d\uff0c\u4ee5\u53ca\u5bf9\u79fb\u690d\u540e\u7684CANopen_Basic\u6837\u4f8b\u8fdb\u884c\u57fa\u672c\u6307\u4ee4\u54cd\u5e94\u529f\u80fd\u7684\u9a8c\u8bc1\u3002 \u53c2\u8003\u6587\u732e [CiA - CANopen] https://www.can-cia.org/canopen/ [CANopenNode] https://github.com/CANopenNode/CANopenNode [CANopen_easy_begin] https://www.zlg.cn/data/upload/software/Can/CANopen_easy_begin.pdf [CANopen Explained - A Simple Intro] https://www.csselectronics.com/pages/canopen-tutorial-simple-intro [CANopen: The Ultimate Guide (2023) (autopi.io)] https://www.autopi.io/blog/canopen-simple-introduction-explained/","title":"CANopenNode\u79fb\u690d"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopennode-mm32g5330","text":"","title":"CANopenNode\u79fb\u690d----\u57fa\u4e8eMM32G5330"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#_1","text":"\u57fa\u672c\u7684CAN\u603b\u7ebf\u5916\u8bbe\u9a71\u52a8\u7a0b\u5e8f\u80fd\u591f\u63d0\u4f9b\u57fa\u672c\u7684\u64cd\u4f5c\u786c\u4ef6\u7535\u8def\u7cfb\u7edf\u7684\u670d\u52a1\uff0c\u4f46\u5728\u5177\u4f53\u7684\u5e94\u7528\u7cfb\u7edf\u4e2d\uff0c\u66f4\u591a\u662f\u57fa\u4e8e\u534f\u8bae\u6808\u5f00\u53d1\u4e0a\u5c42\u5e94\u7528\uff0c\u800c\u4e0d\u662f\u9488\u5bf9\u67d0\u4e2a\u5177\u4f53\u7684\u82af\u7247\u5e73\u53f0\u7f16\u5199\u5b9a\u5236\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\u76ee\u524dCANopen\u662f\u5de5\u4e1a\u81ea\u52a8\u5316\u9886\u57df\u6700\u5e38\u7528\u7684\u534f\u8bae\u6808\u6807\u51c6\u4e4b\u4e00\u3002\u5bf9\u5e94\u5730\uff0c\u6709\u4e00\u4e9b\u5b9e\u73b0CANopen\u534f\u8bae\u7684\u5f00\u6e90\u8f6f\u4ef6\u5305\uff0c\u4f8b\u5982CANopenNode\u3001CAN Festival\u7b49\u3002","title":"\u5f15\u8a00"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopen","text":"","title":"CANopen\u6982\u8ff0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopen_1","text":"CANopen \u534f\u8bae\u662f\u572820\u4e16\u7eaa90\u5e74\u4ee3\u672b\uff0c\u7531\u603b\u90e8\u4f4d\u4e8e\u5fb7\u56fd\u7ebd\u4f26\u5821\u7684 CiA(CAN-in-Automation) \u7ec4\u7ec7\u5728CAL(CAN Application Layer)\u7684\u57fa\u7840\u4e0a\u53d1\u5c55\u800c\u6765\u3002\u7531\u4e8eCANopen\u534f\u8bae\u7684\u521b\u59cb\u4eba\u56e2\u961f\u4e5f\u662fCAN-bus\u7684\u521b\u59cb\u4eba\u56e2\u961f\uff0c\u6b64\u534f\u8bae\u5145\u5206\u53d1\u6325\u4e86CAN-bus\u6240\u5177\u5907\u7684\u6240\u6709\u4f18\u52bf\uff0c\u7279\u522b\u662f CiA \u7ec4\u7ec7\u7684\u4e3b\u5e2d\u8521\u8c6a\u683c(Holger Zeltwanger)\u5148\u751f\u5bf9\u4e8eCANopen\u534f\u8bae\u575a\u6301\u5f00\u653e\u3001\u514d\u8d39\u3001\u975e\u76c8\u5229\u7684\u539f\u5219\u3002\u4e00\u7ecf\u63a8\u51fa\u4fbf\u5728\u6b27\u6d32\u5f97\u5230\u4e86\u5e7f\u6cdb\u7684\u8ba4\u53ef\u4e0e\u5e94\u7528\u3002\u867d\u7136CiA\u7ec4\u7ec7\u80cc\u540e\u6ca1\u6709\u5f3a\u5927\u7684\u8d22\u9600\u652f\u6491\uff0c\u4f46\u65f6\u81f3\u4eca\u65e5\u5df2\u7ecf\u6210\u4e3a\u5168\u4e16\u754c\u6700\u4e3a\u6d41\u884c\u7684CAN\u5e94\u7528\u5c42\u534f\u8bae\u3002 CANopen\u4e3b\u8981\u63d0\u4f9b\u4e86\u4e24\u4e2a\u670d\u52a1\uff1a\u7b2c\u4e00\u4e2a\u662f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u57fa\u4e8eCAN\u7684\u901a\u4fe1\u534f\u8bae\uff0c\u53ef\u4ee5\u5c06\u591a\u4e2a\u8bbe\u5907\u8fde\u63a5\u5230\u4e00\u4e2a\u603b\u7ebf\uff1b\u7b2c\u4e8c\u4e2a\u662f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7528\u4e8e\u8bbe\u5907\u7ba1\u7406\u7684\u6807\u51c6\uff0c\u53ef\u4ee5\u5c06\u591a\u4e2a\u8bbe\u5907\u7ec4\u7ec7\u6210\u4e00\u4e2a\u7cfb\u7edf\uff0c\u4ee5\u5b9e\u73b0\u8fdc\u7a0b\u76d1\u63a7\u548c\u63a7\u5236\u3002\u76ee\u524d\uff0cCANopen\u4f5c\u4e3a\u5de5\u4e1a\u81ea\u52a8\u5316\u9886\u57df\u6700\u5e38\u7528\u7684\u6807\u51c6\u4e4b\u4e00\uff0c\u88ab\u5e7f\u6cdb\u5e94\u7528\u4e8e\u6c7d\u8f66\u3001\u822a\u7a7a\u822a\u5929\u3001\u697c\u5b87\u81ea\u52a8\u5316\u7b49\u884c\u4e1a\u3002 \u5982\u56fex\u6240\u793a\uff0cCNAopen\u662f\u4e00\u4e2a\u57fa\u4e8eCAN\u603b\u7ebf\u7684\u4e0a\u5c42\u534f\u8bae\uff0c\u5176\u4e2dCAN\u6db5\u76d6\u4e86OSI\u6a21\u578b\u7684\u524d\u4e24\u5c42\uff1a\u7269\u7406\u5c42\u548c\u6570\u636e\u94fe\u8def\u5c42\uff0cCANopen\u6db5\u76d6\u4e86\u540e\u4e94\u5c42\uff1a\u7f51\u7edc\u5c42\uff08\u5bfb\u5740\u3001\u8def\u7531\uff09\u3001\u4f20\u8f93\u5c42\uff08\u7aef\u5230\u7aef\u53ef\u9760\u6027\uff09\u3001\u4f1a\u8bdd\u5c42\uff08\u540c\u6b65\uff09\u3001\u8868\u73b0\u5c42\uff08\u4ee5\u6807\u51c6\u65b9\u5f0f\u7f16\u7801\u7684\u6570\u636e\u3001\u6570\u636e\u8868\u73b0\uff09\u548c\u5e94\u7528\u5c42\u3002\u5e94\u7528\u5c42\u89c4\u5b9a\u4e86CANopen\u8bbe\u5907\u662f\u5982\u4f55\u914d\u7f6e\u3001\u4f20\u8f93\u548c\u540c\u6b65\u3002 \u56fex CANopen\u4ece\u5e94\u7528\u7aef\u5230CAN\u603b\u7ebf\u7684\u7ed3\u6784\u5982\u4e0b\u56fex\u6240\u793a\uff1a \u5e94\u7528\u5c42(Application) \u7528\u4e8e\u5b9e\u73b0\u5404\u79cd\u5e94\u7528\u5bf9\u8c61 \u5bf9\u8c61\u5b57\u5178(Object dictionary) \u7528\u4e8e\u63cf\u8ff0CANopen\u8282\u70b9\u8bbe\u5907\u7684\u53c2\u6570 \u901a\u4fe1\u63a5\u53e3(Communication interface) \u5b9a\u4e49\u4e86CANopen\u534f\u8bae\u901a\u4fe1\u89c4\u5219\u4ee5\u53caCAN\u63a7\u5236\u5668\u9a71\u52a8\u4e4b\u95f4\u5bf9\u5e94\u5173\u7cfb \u56fe x \u5728CANopen\u7f51\u7edc\u4e2d\uff0c\u901a\u5e38\u9700\u8981\u591a\u4e2a\u8bbe\u5907\u8fdb\u884c\u901a\u4fe1\uff0c\u5728CANopen\u7f51\u7edc\u4e2d\u7528\u5230\u4e86\u5982\u4e0b\u4e09\u79cd\u901a\u4fe1\u6a21\u578b\uff1a \u56fe x \u4e3b\u673a/\u4ece\u673a\u6a21\u578b(Master/Salve) \u4e00\u4e2a\u8282\u70b9(\u4f8b\u5982\u63a7\u5236\u63a5\u53e3)\u5145\u5f53\u5e94\u7528\u7a0b\u5e8f\u4e3b\u673a\u63a7\u5236\u5668\uff0c\u4ece\u673a(\u4f8b\u5982\u4f3a\u670d\u7535\u673a)\u53d1\u9001/\u8bf7\u6c42\u6570\u636e\uff0c\u4e00\u822c\u5728\u8bca\u65ad\u6216\u72b6\u6001\u7ba1\u7406\u4e2d\u4f7f\u7528\u3002 \u901a\u4fe1\u6837\u4f8b\uff1aNMT\u4e3b\u673a\u4e0eNMT\u4ece\u673a\u7684\u901a\u4fe1 \u6240\u6709\u8282\u70b9\u901a\u4fe1\u5730\u4f4d\u5e73\u7b49\uff0c\u8fd0\u884c\u65f6\u5141\u8bb8\u81ea\u884c\u53d1\u9001\u62a5\u6587\uff0c\u4f46CANopen\u7f51\u7edc\u4e3a\u4e86\u7a33\u5b9a\u53ef\u9760\u53ef\u63a7\uff0c\u90fd\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u7f51\u7edc\u7ba1\u7406\u4e3b\u673a NMT-Master\u3002 NMT\u4e3b\u673a\u4e00\u822c\u662fCANopen\u7f51\u7edc\u4e2d\u5177\u5907\u76d1\u63a7\u7684PLC\u6216\u8005PC(\u5f53\u7136\u4e5f\u53ef\u4ee5\u662f\u4e00\u822c\u7684\u529f\u80fd\u8282\u70b9)\uff0c\u6240\u4ee5\u4e5f\u6210\u4e3aCANopen\u4e3b\u7ad9\u3002\u76f8\u5bf9\u5e94\u7684\u5176\u4ed6CANopen\u8282\u70b9\u5c31\u662fNMT\u4ece\u673a(NMT-slaves)\u3002 \u5ba2\u6237\u7aef/\u670d\u52a1\u7aef\u6a21\u578b(Client/Server) \u5ba2\u6237\u673a\u5411\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\u8bf7\u6c42\uff0c\u670d\u52a1\u5668\u8fdb\u884c\u54cd\u5e94\u3002\u4f8b\u5982\uff0c\u5f53\u5e94\u7528\u7a0b\u5e8f\u4e3b\u673a\u9700\u8981\u6765\u81ea\u4ece\u673aOD\u7684\u6570\u636e\u65f6\u4f7f\u7528\u3002 \u901a\u4fe1\u6837\u4f8b\uff1aSDO\u5ba2\u6237\u7aef\u4e0eSDO\u670d\u52a1\u7aef\u7684\u901a\u4fe1 \u53d1\u9001\u8282\u70b9\u9700\u8981\u6307\u5b9a\u63a5\u6536\u8282\u70b9\u7684\u5730\u5740(Node-ID)\u56de\u5e94CAN\u62a5\u6587\u6765\u786e\u8ba4\u5df2\u7ecf\u63a5\u6536\uff0c\u5982\u679c\u8d85\u65f6\u6ca1\u6709\u786e\u8ba4\uff0c\u5219\u53d1\u9001\u8282\u70b9\u5c06\u4f1a\u91cd\u65b0\u53d1\u9001\u539f\u62a5\u6587\u3002 \u751f\u4ea7\u8005/\u6d88\u8d39\u8005\u6a21\u578b(Producer/Consumer) \u751f\u4ea7\u8005\u8282\u70b9\u5411\u7f51\u7edc\u5e7f\u64ad\u6570\u636e\uff0c\u800c\u7f51\u7edc\u7531\u4f7f\u7528\u8005\u8282\u70b9\u4f7f\u7528\u3002\u751f\u4ea7\u8005\u53ef\u4ee5\u6839\u636e\u8bf7\u6c42\u53d1\u9001\u6b64\u6570\u636e\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u53d1\u9001\u7279\u5b9a\u8bf7\u6c42\u3002 \u901a\u4fe1\u6837\u4f8b\uff1a\u5fc3\u8df3\u751f\u4ea7\u8005\u4e0e\u5fc3\u8df3\u6d88\u8d39\u8005\u7684\u901a\u4fe1 \u5355\u5411\u53d1\u9001\u4f20\u8f93\uff0c\u65e0\u9700\u63a5\u6536\u8282\u70b9\u56de\u5e94CAN\u62a5\u6587\u6765\u786e\u8ba4\u3002","title":"CANopen \u7684\u8bde\u751f\u548c\u4f5c\u7528"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopencob-id","text":"11\u4f4dCAN ID\u5728CANopen\u4e2d\u88ab\u79f0\u4e3aCOB-ID\uff0c\u8fd911\u4f4dCOB-ID\u88ab\u5206\u4e3a\u4e24\u90e8\u5206\uff1a\u524d4\u4f4d\u662f\u529f\u80fd\u7801\uff0c\u540e7\u4f4d\u662f(\u8282\u70b9ID)\uff0c\u4e147\u4f4d\u7684\u8282\u70b9ID\u9650\u5236\u4e86CANopen\u7f51\u7edc\u4e0a\u7684\u8bbe\u5907\u6570\u91cf\u4e3a127\u4e2a\u8282\u70b9\u3002 \u56fe x","title":"CANopen\u7684COB-ID"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopen7","text":"NMT(Network Management) \u63a7\u5236CANopen\u8bbe\u5907\u72b6\u6001\uff0c\u7528\u4e8e\u7f51\u7edc\u7ba1\u7406\u3002 SYNC(Synchronization) SYNC \u6d88\u606f\u7528\u4e8e\u540c\u6b65\u591a\u4e2a CANopen \u8bbe\u5907\u7684\u8f93\u5165\u611f\u5e94\u548c\u9a71\u52a8\u2014\u2014\u901a\u5e38\u7531\u5e94\u7528\u7a0b\u5e8f Master \u89e6\u53d1\u3002 EMCY(Emergency) \u5728\u8bbe\u5907\u53d1\u751f\u9519\u8bef(\u4f8b\u5982\u4f20\u611f\u5668\u6545\u969c)\u65f6\u4f7f\u7528\u7684\uff0c\u53d1\u9001\u8bbe\u5907\u5185\u90e8\u9519\u8bef\u4ee3\u7801\u3002 TIME \u7528\u4e8e\u5206\u914d\u7f51\u7edc\u65f6\u95f4\uff0c\u8bae\u91c7\u7528\u5e7f\u64ad\u65b9\u5f0f\uff0c\u65e0\u9700\u8282\u70b9\u5e94\u7b54\uff0cCAN-ID \u4e3a 100h\uff0c\u6570\u636e\u957f\u5ea6\u4e3a 6\uff0c\u6570\u636e\u4e3a\u5f53\u524d\u65f6\u523b\u4e0e1984\u5e741\u67081\u65e50\u65f6\u7684\u65f6\u95f4\u5dee\u3002\u8282\u70b9\u5c06\u6b64\u65f6\u95f4\u5b58\u50a8\u5728\u5bf9\u8c61\u5b57\u51781012h\u7684\u7d22\u5f15\u4e2d\u3002 PDO(Process Object) PDO\u670d\u52a1\u7528\u4e8e\u5728\u8bbe\u5907\u4e4b\u95f4\u4f20\u8f93\u5b9e\u65f6\u6570\u636e\uff0c\u4f8b\u5982\u6d4b\u91cf\u6570\u636e(\u5982\u4f4d\u7f6e\u6570\u636e)\u6216\u547d\u4ee4\u6570\u636e(\u5982\u626d\u77e9\u8bf7\u6c42)\u3002 SDO(Sever D Object) \u7528\u4e8e\u8bbf\u95ee/\u66f4\u6539CANopen\u8bbe\u5907\u7684\u5bf9\u8c61\u5b57\u5178\u4e2d\u7684\u503c\u2014\u2014\u4f8b\u5982\uff0c\u5f53\u5e94\u7528\u7a0b\u5e8f\u4e3b\u673a\u9700\u8981\u66f4\u6539CANopen\u8bbe\u5907\u7684\u67d0\u4e9b\u914d\u7f6e\u65f6\u3002 Heartbeat Heartbeat\u670d\u52a1\u6709\u4e24\u4e2a\u7528\u9014: \u63d0\u4f9b\u201c\u6d3b\u52a8\u201d\u6d88\u606f\u548c\u786e\u8ba4NMT\u547d\u4ee4\u3002","title":"CANopen\u76847\u79cd\u62a5\u6587\u7c7b\u578b"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#odobject-dictionary","text":"\u4ec0\u4e48\u662f\u5bf9\u8c61\u5b57\u5178\uff1f \u5bf9\u8c61\u5b57\u5178\u662f\u4e00\u4e2a\u6807\u51c6\u7684\u6570\u636e\u7ed3\u6784\uff0c\u63cf\u8ff0\u4e86CANopen\u8282\u70b9\u7684\u4e0d\u540c\u7684\u5bf9\u8c61\u53c2\u6570\u7279\u6027\u3002 \u6bcf\u4e2aCANopen\u8282\u70b9\u90fd\u5305\u542b\u4e00\u4e2a\u5bf9\u8c61\u5b57\u5178\uff0c\u4f7f\u7528ESD\u6587\u4ef6\u6765\u8bb0\u5f55\u8282\u70b9\u53c2\u6570\u3002 Master\u8282\u70b9\u53ef\u901a\u8fc7SDO(\u4e14\u53ea\u80fd\u901a\u8fc7SDO)\u6765\u8bbf\u95ee\u548c\u914d\u7f6eSlave\u8282\u70b9\u7684\u5bf9\u8c61\u5b57\u5178\u3002 \u5bf9\u8c61\u5b57\u5178\u4e2d\u6bcf\u4e2a\u5bf9\u8c61\u7684\u6784\u6210 Index (\u7d22\u5f15)\uff1a16\u4f4d\u5bf9\u8c61\u7684\u57fa\u5730\u5740\uff0c\u5176\u8303\u56f4\u57280x0000\u52300xFFFF\u4e4b\u95f4\u3002 Sub Index (\u5b50\u7d22\u5f15)\uff1a\u4e3a\u4e86\u907f\u514d\u6570\u636e\u5927\u91cf\u65f6\u65e0\u7d22\u5f15\u53ef\u5206\u914d\uff0c\u6240\u4ee5\u5728\u67d0\u4e9b\u7d22\u5f15\u4e0b\u4e5f\u5b9a\u4e49\u4e86\u4e00\u4e2a8\u4f4d\u7684\u7d22\u5f15\u503c\uff0c\u5176\u8303\u56f4\u662f0x00\u52300xFF \u4e4b\u95f4\u3002 Object name (\u5bf9\u8c61\u540d\u79f0): \u5982\uff1a\u5236\u9020\u5546\u8bbe\u5907\u540d\u79f0\u3002 Object type(\u76ee\u6807\u7c7b\u578b): \u53d8\u91cf\u3001\u6570\u7ec4\u6216\u8bb0\u5f55\u3002 Data type (\u6570\u636e\u7c7b\u578b): \u4f8b\u5982 \u5b57\u7b26\u4e32\u7c7b\u578b, UNSIGNED32\u7c7b\u578bUNSIGNED16\u7c7b\u578b\u3002 Access (\u8bbf\u95ee\u6743\u9650)\uff1arw (read/write), ro (read-only), wo (write-only)\u3002 Default Value(\u9ed8\u8ba4\u503c): Category (\u7c7b\u578b)\uff1a\u6307\u5b9a\u6b64\u53c2\u6570\u662f\u5426\u4e3a\u5f3a\u5236/\u53ef\u9009(M/O)\u3002 \u56fe x EDS(The Electronic Data Sheet) \u5728\u5b9e\u9645\u4f7f\u7528\u4e2d\uff0c\u914d\u7f6e\u6216\u7ba1\u7406\u590d\u6742\u7684 CANopen \u7f51\u7edc\u5c06\u4f7f\u7528\u8f6f\u4ef6\u5de5\u5177\u6765\u5b8c\u6210\uff0cCiA 306\u6807\u51c6\u5b9a\u4e49\u4e86\u4e00\u4e2a\u4eba\u7c7b\u53ef\u8bfb\u7684\u4e14\u5bf9\u673a\u5668\u53cb\u597d\u7684\u51fa\u5382\u6587\u4ef6\u683c\u5f0f\u5373EDS\u683c\u5f0f\u6587\u4ef6\uff0c\u4f5c\u4e3a\u8bbe\u5907OD\u7684\u201c\u6a21\u677f\u201d\u3002EDS\u6587\u4ef6\u901a\u5e38\u7531\u8bbe\u5907\u4f9b\u5e94\u5546\u63d0\u4f9b\uff0c\u5305\u542b\u6240\u6709\u8bbe\u5907\u5bf9\u8c61(\u4f46\u4e0d\u5305\u542b\u53c2\u6570\u503c)\u7684\u4fe1\u606f\u3002\u7b80\u800c\u8a00\u4e4b\uff0cEDS\u662f\u7531CANopen\u8bbe\u5907\u5382\u5546\u63d0\u4f9b\u7684\u4e0d\u5e26\u53c2\u6570\u7684\u8bbe\u5907OD\u6a21\u677f\u3002 \u5bf9\u8c61\u5b57\u5178\u7f16\u8f91\u5668 \u5bf9\u8c61\u5b57\u5178\u7f16\u8f91\u5668\u662f\u7528\u4e8eCANopen\u5bf9\u8c61\u5b57\u5178\u3001\u8bbe\u5907\u4fe1\u606f\u7b49\u7684GUI\u7f16\u8f91\u5668\uff0c\u53ef\u5c06 EDS \u683c\u5f0f\u6587\u4ef6\u5bfc\u5165\uff0c\u901a\u8fc7\u7f16\u8f91\u5668\u7f16\u8f91\u8d4b\u503c\u540e\u5bfc\u51fa\u6210 CANopen\u5bf9\u8c61\u5b57\u5178\u7684C\u6e90\u4ee3\u7801\u6587\u4ef6\u3002\u5bfc\u51fa\u7684\u5728\u4e24\u4e2a\u6e90\u4ee3\u7801\u6587\u4ef6CO_OD.c\u548cCO_OD.h\u6587\u4ef6\u5c31\u662f\u6211\u4eec\u6700\u7ec8\u5728\u8f6f\u4ef6\u5f00\u53d1\u65f6\u9700\u8981\u7684\u5bf9\u8c61\u5b57\u5178\u6e90\u6587\u4ef6\u3002","title":"OD(Object Dictionary\uff0c\u5bf9\u8c61\u5b57\u5178)"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopen_2","text":"\u5177\u6709\u7f51\u7edc\u7ba1\u7406\uff08Network Management\uff1a\u7b80\u79f0NMT\uff09\u4e3b\u673a\u529f\u80fd\u7684\u8bbe\u5907\u901a\u5e38\u88ab\u79f0\u4e3aCANopen\u4e3b\u7ad9\u8bbe\u5907\uff0c\u901a\u5e38\u4e5f\u5177\u6709\u670d\u52a1\u6570\u636e\uff08Service Date Object\uff1a\u7b80\u79f0SDO\uff09\u5ba2\u6237\u7aef\u529f\u80fd\u3002\u53cd\u4e4b\u5177\u6709\u7f51\u7edc\u7ba1\u7406\uff08NMT\uff09\u4ece\u673a\u529f\u80fd\u7684\u8bbe\u5907\u901a\u5e38\u88ab\u79f0\u4e3aCANopen\u4ece\u7ad9\u8bbe\u5907\uff0c\u4e14\u5176\u5fc5\u987b\u5177\u5907\u6709\u670d\u52a1\u6570\u636e\u670d\u52a1\u5668\u529f\u80fd\u3002\u8fd9\u6837CANopen\u4e3b\u7ad9\u8bbe\u5907\u5c31\u53ef\u4ee5\u63a7\u5236\u4ece\u7ad9\u4ee5\u53ca\u8bfb\u5199CANopen\u4ece\u7ad9\u8bbe\u5907\u7684\u5bf9\u8c61\u5b57\u5178\u3002 CANopen\u4ece\u7ad9\u7279\u6027 CANopen\u4ece\u7ad9\u5728CANopen\u7f51\u7edc\u4e2d\u62e5\u6709\u552f\u4e00\u7684\u8282\u70b9\u5730\u5740\uff0c\u5e76\u4e14\u80fd\u72ec\u7acb\u5b8c\u6210\u7279\u5b9a\u7684\u529f\u80fd\uff0c\u4f8b\u5982\u6570\u636e\u91c7\u96c6\u3001\u7535\u673a\u63a7\u5236\u7b49\u7b49\u3002\u5bf9\u5b9e\u65f6\u6027\u8981\u6c42\u9ad8\u7684\u6570\u636e\uff0c\u901a\u5e38\u901a\u8fc7\u5b9e\u65f6\u6570\u636e\u8fc7\u7a0b\uff08Process Data Object\uff1a\u7b80\u79f0PDO\uff09\u8fdb\u884c\u4f20\u8f93\uff0c\u56e0\u6b64CANopen\u4ece\u7ad9\u5e94\u5f53\u652f\u6301\u4e00\u5b9a\u6570\u91cf\u7684PDO\u4f20\u8f93\u529f\u80fd\u3002\u6839\u636eCANopen\u534f\u8baeDS301 V4.02\u7684\u5b9a\u4e49\uff0c\u6bcf\u4e2a\u4ece\u7ad9\u90fd\u9884\u5b9a\u4e49\u4e864\u4e2aTPDO\uff08Transmit Process Data Object\uff1a\u7b80\u79f0TPDO\uff09\u548c4\u4e2aRPDO\uff08Receive Process Data Object\uff09\uff0c\u53e6\u5916\u4ece\u7ad9\u4e5f\u5e94\u5177\u6709\u8282\u70b9/\u5bff\u547d\u4fdd\u62a4\u6216\u5fc3\u8df3\u62a5\u6587\u4ee5\u53ca\u751f\u4ea7\u7d27\u6025\u62a5\u6587\u7b49\u529f\u80fd\u3002\u6bcf\u4e2aCANopen\u4ece\u7ad9\u90fd\u5e94\u6709\u4e00\u4e2a\u5bf9\u8c61\u5b57\u5178\uff0c\u63cf\u8ff0\u4e86\u4ece\u7ad9\u6240\u5177\u6709\u7684\u5e94\u7528\u53c2\u6570\u548c\u901a\u4fe1\u53c2\u6570\u3002 CANopen\u4e3b\u7ad9\u7279\u6027 CANopen\u4e3b\u7ad9\u5728\u7f51\u7edc\u6240\u8d77\u7684\u4f5c\u7528\u6709\u522b\u4e8eCANopen\u4ece\u7ad9\uff0c\u901a\u5e38CANopen\u4e3b\u7ad9\u5728\u7f51\u7edc\u4e2d\u8d1f\u8d23\u7f51\u7edc\u7ba1\u7406\u3001\u4ece\u7ad9\u53c2\u6570\u914d\u7f6e\u4ee5\u53ca\u4ece\u7ad9\u6570\u636e\u7684\u5904\u7406\uff0c\u5176\u5e76\u4e0d\u4e00\u5b9a\u5177\u6709\u7279\u5b9a\u7684\u529f\u80fd\uff0c\u4f46\u4e5f\u6709\u81ea\u5df1\u7684\u5bf9\u8c61\u5b57\u5178\u548c\u552f\u4e00\u7684\u8282\u70b9\u5730\u5740\uff0c\u4e00\u822c\u662fCANopen\u7f51\u7edc\u4e2d\u5177\u5907\u76d1\u63a7\u7684PLC\u6216\u8005PC(\u5f53\u7136\u4e5f\u53ef\u4ee5\u662f\u4e00\u822c\u7684\u529f\u80fd\u8282\u70b9)\u3002","title":"CANopen\u4e3b\u7ad9\u548c\u4ece\u7ad9"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopen_3","text":"\u7531\u4e8eCANopen\u662f\u57fa\u4e8eCAN\u603b\u7ebf\u7684\u4e00\u79cd\u5e94\u7528\u5c42\u534f\u8bae\uff0c\u56e0\u6b64\u5176\u7f51\u7edc\u7ec4\u5efa\u4e0eCAN\u603b\u7ebf\u4e00\u81f4\uff0c\u5178\u578b\u7684\u603b\u7ebf\u578b\u7ed3\u6784\uff0c\u4ece\u7ad9\u548c\u4e3b\u7ad9\u90fd\u6302\u63a5\u5728\u8be5\u603b\u7ebf\u4e0a\u5373\u53ef\uff0c\u5728\u4e00\u4e2aCANopen\u7f51\u7edc\u4e2d\u53ea\u80fd\u6709\u4e00\u4e2a\u4e3b\u7ad9\u8bbe\u5907\u548c\u82e5\u5e72\u4e2a\u4ece\u7ad9\u8bbe\u5907\u540c\u65f6\u5de5\u4f5c\u3002CANopen\u7f51\u7edc\u5e03\u7ebf\u65f6\u9009\u7528\u5e26\u5c4f\u853d\u53cc\u7ede\u7ebf\uff0c\u63d0\u9ad8\u603b\u7ebf\u6297\u5e72\u6270\u80fd\u529b\u3002\u8868 x \u6240\u793a\u4e3aCAN\u901a\u4fe1\u6bd4\u7279\u7387\u4e0e\u603b\u7ebf\u957f\u5ea6\u7684\u5173\u7cfb\u3002 \u8868 x Bit rate Bus length 1 Mbit/s 25 m 800 kbit/s 50 m 500 kbit/s 100 m 250 kbit/s 250 m 125 kbit/s 500 m 50 kbit/s 1.000 m 20 kbit/s 2.500 m 10 kbit/s 5.000 m \u6ce8\u610f\uff1a \u603b\u7ebf\u957f\u5ea6\u7684\u4f30\u8ba1\u662f\u57fa\u4e8eCANopen CiA 301 \u89c4\u8303\u5efa\u8bae\u7684\u91c7\u6837\u70b9\u4f4d\u7f6e\u3002 \u603b\u7ebf\u957f\u5ea6\u7684\u4f30\u8ba1\u662f\u57fa\u4e8e5 ns/m\u7684\u4f20\u64ad\u5ef6\u8fdf\u3002\u6b64\u5916\uff0c\u8fd8\u9700\u8981\u8003\u8651\u6240\u7528\u7684CAN\u63a7\u5236\u5668\u3001CAN\u6536\u53d1\u5668\u548c\u5149\u8026\u5408\u5668\u7684\u5ef6\u8fdf\u65f6\u95f4\u3002 \u5982\u56fex\u6240\u793a\u4e3aCANopen\u7f51\u7edc\u7684\u57fa\u672c\u7ed3\u6784\uff0c\u5728\u8be5\u7f51\u7edc\u4e2d\u6709\u4e00\u4e2aCANopen\u4e3b\u7ad9\uff0c\u8d1f\u8d23\u7ba1\u7406\u7f51\u7edc\u4e2d\u7684\u6240\u6709\u4ece\u7ad9\uff0c\u6bcf\u4e2a\u8bbe\u5907\u90fd\u6709\u4e00\u4e2a\u72ec\u7acb\u7684\u8282\u70b9\u5730\u5740\uff08NodeID\uff09\u3002\u4ece\u7ad9\u4e0e\u4ece\u7ad9\u4e4b\u95f4\u4e5f\u80fd\u5efa\u7acb\u901a\u4fe1\uff0c\u901a\u5e38\u9700\u8981\u4e8b\u5148\u5bf9\u5404\u4e2a\u4ece\u7ad9\u8fdb\u884c\u914d\u7f6e\uff0c\u4f7f\u5404\u4e2a\u4ece\u7ad9\u4e4b\u95f4\u80fd\u591f\u5efa\u7acb\u8d77\u72ec\u7acb\u7684PDO\u901a\u4fe1\u3002 \u56fex \u56fex\u6240\u793a\u4e3a\u5e26\u6709\u7f51\u5173\u8bbe\u5907\u7684CANopen\u7f51\u7edc\uff0c\u4e0e\u57fa\u672c\u7684CANopen\u7f51\u7edc\u76f8\u6bd4\uff0c\u8be5\u7f51\u7edc\u4e2d\u589e\u52a0\u4e86\u4e00\u4e2aCANopen\u7f51\u5173\u8bbe\u5907\uff0c\u8be5\u7f51\u5173\u8bbe\u5907\u53ef\u4ee5\u662fCANopen\u8f6cDeviceNet\u3001Profibus\u3001Modbus\u6216\u5176\u5b83\u7684\u8bbe\u5907\u3002\u5728CANopen\u7f51\u7edc\u4e2d\uff0c\u6211\u4eec\u4e5f\u53ef\u628a\u8be5\u7f51\u5173\u8bbe\u5907\u4f5c\u4e3a\u4e00\u4e2a\u4ece\u7ad9\u8bbe\u5907\u6216\u8005\u662fCANopen\u4e3b\u7ad9\u8bbe\u5907\u3002 \u56fex","title":"CANopen\u7f51\u7edc\u7ec4\u5efa"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#nmt","text":"\u4e3a\u5b9e\u73b0CANopen\u7f51\u7edc\u7a33\u5b9a\u53ef\u9760\u9ad8\u6548\u8fd0\u884c\uff0c\u9700\u8981\u5bf9CANopen\u7f51\u7edc\u8fdb\u884c\u7f51\u7edc\u7ba1\u7406\uff0cNMT\u4e3b\u673a\u901a\u8fc7\u4e0b\u53d1\u547d\u4ee4\uff0c\u6765\u63a7\u5236NMT\u4ece\u673a\u8fdb\u884c\u6709\u5e8f\u5de5\u4f5c\uff0c\u6545\u6bcf\u4e2aCANopen\u534f\u8bae\u6808\u4e2d\u90fd\u5177\u6709NMT\u7f51\u7edc\u7ba1\u7406\u7684\u529f\u80fd\u3002 CANopen\u8282\u70b9\u8bbe\u5907\u8fd0\u884c\u65f6\u5b58\u5728\u516d\u79cd\u72b6\u6001\uff1a \u521d\u59cb\u5316 \u8282\u70b9\u4e0a\u7535\u540e\u5bf9\u529f\u80fd\u90e8\u4ef6\u5305\u62ecCAN\u63a7\u5236\u5668\u8fdb\u884c\u521d\u59cb\u5316\u3002 \u5e94\u7528\u5c42\u590d\u4f4d \u8282\u70b9\u4e2d\u7684\u5e94\u7528\u7a0b\u5e8f\u590d\u4f4d\uff08\u5f00\u59cb\uff09\uff0c\u6bd4\u5982\u5f00\u5173\u91cf\u8f93\u51fa\u3001\u6a21\u62df\u91cf\u8f93\u51fa\u7684\u521d\u59cb\u503c\u3002 \u4f1a\u8bdd\u5c42\u590d\u4f4d \u8282\u70b9\u4e2d\u7684CANopen\u901a\u8baf\u590d\u4f4d\uff08\u5f00\u59cb\uff09\uff0c\u4ece\u8fd9\u4e2a\u65f6\u523b\u8d77\uff0c\u6b64\u8282\u70b9\u5c31\u53ef\u4ee5\u8fdb\u884cCANopen\u901a\u8baf\u4e86\u3002 \u9884\u64cd\u4f5c\u72b6\u6001 \u8282\u70b9\u7684CANopen\u901a\u8baf\u5904\u4e8e\u64cd\u4f5c\u5c31\u7eea\u72b6\u6001\uff0c\u6b64\u65f6\u6b64\u8282\u70b9\u4e0d\u80fd\u8fdb\u884cPDO\u901a\u4fe1\uff0c\u800c\u53ef\u4ee5\u8fdb\u884cSDO\u8fdb\u884c\u53c2\u6570\u914d\u7f6e\u548cNMT\u7f51\u7edc\u7ba1\u7406\u7684\u64cd\u4f5c\u3002 \u64cd\u4f5c\u72b6\u6001 \u8282\u70b9\u6536\u5230NMT\u4e3b\u673a\u53d1\u6765\u7684\u542f\u52a8\u547d\u4ee4\u540e\uff0cCANopen\u901a\u8baf\u88ab\u6fc0\u6d3b\uff0cPDO\u901a\u4fe1\u542f\u52a8\u540e\uff0c\u6309\u7167\u5bf9\u8c61\u5b57\u5178\u91cc\u9762\u89c4\u5b9a\u7684\u89c4\u5219\u8fdb\u884c\u4f20\u8f93\uff0c\u540c\u6837SDO\u4e5f\u53ef\u4ee5\u5bf9\u8282\u70b9\u8fdb\u884c\u6570\u636e\u4f20\u8f93\u548c\u53c2\u6570\u4fee\u6539\u3002 \u505c\u6b62\u72b6\u6001 \u8282\u70b9\u6536\u5230NMT\u4e3b\u673a\u53d1\u6765\u7684\u505c\u6b62\u547d\u4ee4\u540e\uff0c\u8282\u70b9\u7684PDO\u901a\u4fe1\u88ab\u505c\u6b62\uff0c\u4f46SDO\u548cNMT\u7f51\u7edc\u7ba1\u7406\u4f9d\u7136\u53ef\u4ee5\u5bf9\u8282\u70b9\u8fdb\u884c\u64cd\u4f5c\u3002 \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u4e0a\u8ff0\u516d\u79cd\u72b6\u6001\u4e2d\u9664\u4e86\u521d\u59cb\u5316\u72b6\u6001\u5916\uff0c\u90fd\u53ef\u4ee5\u901a\u8fc7NMT\u4e3b\u673a\u53d1\u9001NMT\u547d\u4ee4\u8ba9CANopen\u7f51\u7edc\u4e2d\u4efb\u610f\u4e00\u4e2a\u8282\u70b9\u8fdb\u884c\u5176\u4ed65\u79cd\u72b6\u6001\u7684\u5207\u6362\u3002 \u56fex","title":"NMT\u7f51\u7edc\u7ba1\u7406"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopennode","text":"CANopenNode\u662f\u4e00\u6b3e\u514d\u8d39\u548c\u5f00\u6e90\u7684CANopen\u534f\u8bae\u6808\uff0c\u4f7f\u7528\u7528ANSI C\u8bed\u8a00\u4ee5\u9762\u5411\u5bf9\u8c61\u7684\u65b9\u5f0f\u7f16\u5199\u7684\u3002\u5b83\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u5fae\u63a7\u5236\u5668\u4e0a\u8fd0\u884c\uff0c\u4f5c\u4e3a\u72ec\u7acb\u7684\u5e94\u7528\u7a0b\u5e8f\u6216\u4e0eRTOS\u4e00\u8d77\u8fd0\u884c\u3002 \u53d8\u91cf\uff08\u901a\u4fe1\u3001\u8bbe\u5907\u3001\u81ea\u5b9a\u4e49\uff09\u88ab\u6536\u96c6\u5728CANopen\u5bf9\u8c61\u5b57\u5178\u4e2d\uff0c\u5e76\u4e14\u53ef\u4ee5\u4ee5\u4e24\u79cd\u65b9\u5f0f\u4fee\u6539\uff1aC\u6e90\u4ee3\u7801\u548cCANopen\u7f51\u7edc\u3002 CANopenNode\u7684\u4e3b\u9875\u662f\u4f4d\u4e8e\uff1a https://github.com/CANopenNode/CANopenNode","title":"CANopenNode\u7b80\u4ecb"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopennode-vs-can-festival","text":"\u8868 x Feature CANopenNode CANFestival License Apache v2.0 LGPLv2 NMT master / slave \u2713 / \u2713 \u2713 / \u2713 SDO client / server \u2713 / \u2713 \u2713 / \u2713 PDO \u2713 / \u2713 \u2713 / \u2713 \u7d27\u6025\u62a5\u6587 \u2713 / \u2713 \u2713 / \u2713 LLS \u2713 \u2713 Non-volatile storage support \u00d7 \u2713 CANFestival\u548cCANopenNode\u90fd\u662f\u7528\u4e8e\u5728\u5d4c\u5165\u5f0f\u7cfb\u7edf\u4e0a\u5b9e\u73b0CANopen\u534f\u8bae\u901a\u4fe1\u7684\u5f00\u6e90\u8f6f\u4ef6\u534f\u8bae\u6808\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u5b83\u4eec\u4f7f\u7528\u4e86\u4e0d\u540c\u7684\u5f00\u653e\u7a0b\u5ea6\u7684\u5f00\u6e90\u534f\u8bae\u3002CANFestival\u4f7f\u7528LGPLv2\u5f00\u6e90\u534f\u8bae\u3002\u8fd9\u610f\u5473\u7740CANFestival\u7684\u6e90\u4ee3\u7801\u662f\u514d\u8d39\u63d0\u4f9b\u7684\uff0c\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u4f7f\u7528\u3001\u4fee\u6539\u548c\u5206\u53d1\uff0c\u53ea\u8981\u4efb\u4f55\u884d\u751f\u4f5c\u54c1\u4f7f\u7528\u76f8\u540c\u7684GPL\u8bb8\u53ef\u8bc1\u3002\u5982\u679c\u4e00\u4e2a\u516c\u53f8\u5728\u4ea7\u54c1\u4e2d\u4f7f\u7528CANFestival\uff0c\u4ed6\u4eec\u4e5f\u5fc5\u987b\u6309\u7167\u540c\u6837\u7684LGPLv2\u5f00\u6e90\u534f\u8bae\u63d0\u4f9b\u5176\u4ea7\u54c1\u7684\u6e90\u4ee3\u7801\u3002CANopenNode\u4f7f\u7528 Apache v2.0\u5f00\u6e90\u534f\u8bae\u3002\u8fd9\u662f\u4e00\u4e2a\u81ea\u7531\u5ea6\u6bd4LGPLv2\u66f4\u4e3a\u5f00\u53d1\u7684\u4e00\u4e2a\u5f00\u6e90\u534f\u8bae\uff0c\u5141\u8bb8\u5728\u4f7f\u7528\u8f6f\u4ef6\u65b9\u9762\u6709\u66f4\u5927\u7684\u7075\u6d3b\u6027\u3002\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u4f7f\u7528\u3001\u4fee\u6539\u548c\u53d1\u5e03CANopenNode\uff0c\u751a\u81f3\u7528\u4e8e\u5546\u4e1a\u76ee\u7684\uff0c\u800c\u4e0d\u9700\u8981\u53d1\u5e03\u5176\u884d\u751f\u4f5c\u54c1\u7684\u6e90\u4ee3\u7801\u3002","title":"CANopenNode vs CAN Festival"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopennode_1","text":"\u9009\u62e9 CANopenNode v1.3\uff0c\u8be5\u7248\u672c\u4e3aCANopenNode\u5b98\u65b9\u9a8c\u8bc1\u53d1\u5e03\u7248\u672c\uff0c\u83b7\u53d6\u6e90\u7801\u94fe\u63a5\u5982\u4e0b\uff1a https://github.com/CANopenNode/CANopenNode/releases/tag/v1.3","title":"\u83b7\u53d6CANopenNode\u6e90\u7801"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopennode_2","text":"\u652f\u6301\u542f\u52a8\u3001\u505c\u6b62\u3001\u91cd\u542f\u8bbe\u5907\u7684NMT\u4ece\u673a\u548c\u7b80\u5355\u7684NMT\u4e3b\u673a\u3002 \u652f\u6301\u57fa\u4e8e\u751f\u4ea7\u8005\u6d88\u8d39\u8005\u6a21\u578b\u7684\u5fc3\u8df3\u673a\u5236\u7528\u4e8e\u9519\u8bef\u63a7\u5236\u3002 \u652f\u6301\u7528\u4e8e\u5feb\u901f\u4ea4\u6362\u8fc7\u7a0b\u53d8\u91cf\u7684PDO\u94fe\u63a5\u548c\u52a8\u6001\u6620\u5c04\u3002 \u652f\u6301SDO\u52a0\u901f\u3001\u5206\u6bb5\u548c\u5757\u72b6\u4f20\u8f93\uff0c\u7528\u4e8e\u5bf9\u6240\u6709\u53c2\u6570\u7684\u670d\u52a1\u8bbf\u95ee\u4ee5\u53caSDO\u4e3b\u673a\u3002 \u652f\u6301\u7d27\u6025\u62a5\u6587\u3002 \u652f\u6301\u57fa\u4e8e\u751f\u4ea7\u8005\u6d88\u8d39\u8005\u6a21\u578b\u7684\u540c\u6b65\u673a\u5236\u3002 \u652f\u6301\u65f6\u95f4\u534f\u8bae(\u751f\u4ea7\u8005\u6d88\u8d39\u8005\u6a21\u5f0f)\u3002 \u652f\u6301\u975e\u6613\u5931\u6027\u5b58\u50a8\uff08\u6389\u7535\u4fdd\u5b58\uff09\u3002 \u652f\u6301LSS\u4e3b\u673a\u548c\u4ece\u673a, LSS \u5feb\u901f\u626b\u63cf\u3002 \u5982CANopenNode\u5b98\u65b9README\u6587\u6863\u7ed9\u51fa\u7684\u90a3\u6837\uff0cCANopenNode\u5206\u4e3a\u4e09\u4e2a\u7ebf\u7a0b\u8fdb\u884c\u8fd0\u884c\uff0c\u5206\u522b\u4e3a\uff1a \u4e3b\u7ebf\u7a0b \u8d1f\u8d23\u5904\u7406\u5927\u90e8\u5206\u534f\u8bae\u6808\u76f8\u5173\u51fd\u6570\u3002 \u5b9a\u65f6\u4e2d\u65ad\u7ebf\u7a0b 1ms\u6267\u884c\u4e00\u6b21\uff0c\u8d1f\u8d23\u5904\u7406\u548c\u65f6\u95f4\u76f8\u5173\u7684\u4efb\u52a1\u3002 CAN\u63a5\u6536\u7ebf\u7a0b \u5f53\u63a5\u6536\u5230CAN\u5e27\u65f6\u8fdb\u5165\u5230\u8fd9\u91cc\u5e76\u5904\u7406\u3002 ----------------------- | Program start | ----------------------- | ----------------------- | CANopen init | ----------------------- | ----------------------- | Start threads | ----------------------- | | | -------------------- | -------------------- | | | ----------------------- ----------------------- ----------------------- | CAN receive thread | | Timer interval thread | | Mainline thread | | | | | | | | - Fast response. | | - Realtime thread with| | - Processing of time | | - Detect CAN ID. | | constant interval, | | consuming tasks | | - Partially process | | typically 1ms. | | in CANopen objects: | | messages and copy | | - Network synchronized| | - SDO server, | | data to target | | - Copy inputs (RPDOs, | | - Emergency, | | CANopen objects. | | HW) to Object Dict. | | - Network state, | | | | - May call application| | - Heartbeat. | | | | for some processing.| | - May cyclically call | | | | - Copy variables from | | application code. | | | | Object Dictionary to| | | | | | outputs (TPDOs, HW).| | | ----------------------- ----------------------- ----------------------- ----------------------- | SDO client (optional) | | | | - Can be called by | | external application| | - Can read or write | | any variable from | | Object Dictionary | | from any node in the| | CANopen network. | ----------------------- ----------------------- | LSS client (optional) | | | | - Can be called by | | external application| | - Can do LSS requests | | - Can request node | | enumeration | -----------------------","title":"CANopenNode \u529f\u80fd\u7279\u6027"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopennode-basic-api-list","text":"initialize CANopen CO_ReturnError_t CO_init(void *CANdriverState, uint8_t nodeId, uint16_t bitRate) Initialize CANopen stack. Function must be called in the communication reset section. Start CAN void CO_CANsetNormalMode(CO_CANmodule_t *CANmodule) Request CAN normal (opearational) mode CANopen process CO_NMT_reset_cmd_t CO_process(CO_t co, uint16_t timeDifference_ms, uint16_t timerNext_ms) Process CANopen objects. Function must be called cyclically. It processes all \"asynchronous\" CANopen objects. Process Sync bool_t CO_process_SYNC( CO_t *co, uint32_t timeDifference_us) Process CANopen SYNC objects. Function must be called cyclically from real time thread with constant interval (1ms typically). It processes SYNC CANopen objects. Read inputs void CO_process_RPDO(CO_t *co, bool_t syncWas) Process CANopen RPDO objects. Function must be called cyclically from real time thread with constant. interval (1ms typically). It processes receive PDO CANopen objects. Write outputs void CO_process_TPDO(CO_t *co, bool_t syncWas, uint32_t timeDifference_us) Process CANopen TPDO objects. Function must be called cyclically from real time thread with constant. interval (1ms typically). It processes transmit PDO CANopen objects. CAN interrupt function void CO_CANinterrupt(CO_CANmodule_t *CANmodule) Receives and transmits CAN messages. Function must be called directly from high priority CAN interrupt.","title":"CANopenNode  Basic  API  List"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#mm32g5330canopennode","text":"","title":"\u57fa\u4e8eMM32G5330\u79fb\u690dCANopenNode"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopennode_3","text":"CANopenNode-1.3: \u2502 .clang-format \u2502 .gitignore \u2502 CANopen.c \u2502 CANopen.h \u2502 codingStyle \u2502 CO_driver.h \u2502 CO_types.h \u2502 Doxyfile \u2502 LICENSE \u2502 LICENSE.old \u2502 Makefile \u2502 README.md \u2502 \u251c\u2500example \u2502 \u2502 application.c \u2502 \u2502 application.h \u2502 \u2502 CO_OD.c \u2502 \u2502 CO_OD.h \u2502 \u2502 IO.eds \u2502 \u2502 IO.html \u2502 \u2502 main.c \u2502 \u2502 _project.html \u2502 \u2502 _project.xml \u2502 \u2502 \u2502 \u2514\u2500CO_OD_with_trace \u2502 CO_OD.c \u2502 CO_OD.h \u2502 \u2514\u2500stack \u2502 CO_Emergency.c \u2502 CO_Emergency.h \u2502 CO_HBconsumer.c \u2502 CO_HBconsumer.h \u2502 CO_LSS.h \u2502 CO_LSSmaster.c \u2502 CO_LSSmaster.h \u2502 CO_LSSslave.c \u2502 CO_LSSslave.h \u2502 CO_NMT_Heartbeat.c \u2502 CO_NMT_Heartbeat.h \u2502 CO_PDO.c \u2502 CO_PDO.h \u2502 CO_SDO.c \u2502 CO_SDO.h \u2502 CO_SDOmaster.c \u2502 CO_SDOmaster.h \u2502 CO_SYNC.c \u2502 CO_SYNC.h \u2502 CO_TIME.c \u2502 CO_TIME.h \u2502 CO_trace.c \u2502 CO_trace.h \u2502 crc16-ccitt.c \u2502 crc16-ccitt.h \u2502 \u251c\u2500drvTemplate \u2502 CO_driver.c \u2502 CO_driver_target.h \u2502 eeprom.c \u2502 eeprom.h \u6ce8\uff1a\u4e0a\u8ff0\u4ec5\u5305\u542b\u79fb\u690d\u7528\u5230\u7684\u6587\u4ef6\u3002","title":"CANopenNode\u8f6f\u4ef6\u5305\u7684\u6e90\u6587\u4ef6"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#canopennode_4","text":"CANopenNode\u79fb\u690d\u4e2d\u6d89\u53ca\u5230\u4e09\u4e2a\u6587\u4ef6\u9700\u8981\u4fee\u6539\uff1a CANopenNode-1.3/example/main.c \u6587\u4ef6\u3002 CANopenNode-1.3/stack/drvTemplate/CO_driver.c \u6587\u4ef6\u3002 CANopenNode-1.3/stack//drvTemplate/CO_driver_target.h \u6587\u4ef6\u3002 \u5176\u4e2d\uff1a \u5728 mian.c \u6587\u4ef6\u4e2d\u5b9e\u73b0 tmrTask_thread() \u51fd\u6570 \u901a\u52a0\u8f7d\u8fdb\u51651ms \u5b9a\u65f6\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u8fdb\u884c 1ms \u5b9a\u65f6\u7684\u4fe1\u606f\u540c\u6b65\u3002 \u5728 CO_driver.c \u6587\u4ef6\u4e2d\u5b9e\u73b0 CO_CANmodule_init() \u51fd\u6570 \u7528\u4e8e\u5bf9 MCU \u4e2d\u7684 CAN \u6a21\u5757\u8fdb\u884c\u521d\u59cb\uff0c\u5e76\u914d\u7f6eCAN\u62a5\u6587\u7684\u6536\u53d1\u53c2\u6570\u4ee5\u53ca\u5f00\u542f flexcan \u4e2d\u65ad\u3002 \u5728 CO_driver.C \u6587\u4ef6\u4e2d\u5b9e\u73b0 CO_CANinterrupt() \u51fd\u6570 \u7528\u4e8e\u5b9e\u73b0\u63a5\u6536\u548c\u53d1\u9001CAN\u4fe1\u606f\u3002\u8be5\u529f\u80fd\u4ece\u9ad8\u4f18\u5148\u7ea7\u7684CAN\u4e2d\u65ad\u4e2d\u76f4\u63a5\u8c03\u7528\u3002 \u5728 CO_driver.C \u6587\u4ef6\u4e2d\u5b9e\u73b0 CO_CANverifyErrorst() \u51fd\u6570 \u7528\u4e8e\u5bf9 CAN \u603b\u7ebf\u8fdb\u884c\u9519\u8bef\u68c0\u6d4b\u548c\u4e0a\u62a5\u3002","title":"CANopenNode\u7684\u79fb\u690d\u65b9\u6cd5"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#flexcancanopennode","text":"\u4e0b\u9762\u6211\u4eec\u5c06\u4ee5MM32G5330\u5fae\u63a7\u5236\u5668\u4e0a\u96c6\u6210\u7684FlexCAN\u4e3a\u4f8b\uff0c\u5b9e\u73b0\u5bf9CANopenNode v1.3\u7684\u79fb\u690d\u8fc7\u7a0b\u3002 \u9996\u5148\u5728\u7075\u52a8\u5b98\u7f51\u4e0b\u8f7d\u57fa\u4e8eMini-G5330\u5f00\u53d1\u677f\u7684FlexCAN_Interrupt\u6837\u4f8b\u5de5\u7a0b\uff0c\u5e76\u5728MM32G5330\u7684\u6839\u76ee\u5f55\u6587\u4ef6\u5939\u4e0b\u521b\u5efaCANopenNode\u6587\u4ef6\u5939\u3002\u5c06CANopenNode v1.3\u8f6f\u4ef6\u5305\u4e2d\u5305\u542b\u7684\u4e0b\u5217\u6587\u4ef6\u65e0\u9700\u4fee\u6539\uff0c\u539f\u5c01\u4e0d\u52a8\u5730\u590d\u5236\u5230\u65b0\u5efa\u7684 CANopenNode \u6587\u4ef6\u5939\u4e2d\u3002 ./CANopen.c&h ./CO_types.h ./stack/CO_Emergency.c&h ./stack/CO_HBconsumer.c&h ./stack/CO_LSS.h ./stack/CO_LSSmaster.c&h ./stack/CO_LSSslave.c&h ./stack/CO_NMT_Heartbeat.c&h ./stack/CO_PDO.c&h ./stack/CO_SDO.c&h ./stack/CO_SDOmaster.c&h ./stack/CO_SYNC.c&h ./stack/CO_TIME.c&h ./stack/CO_trace.c&h ./stack/crc16-ccitt.c&h \u5982\u4e0b\u56fex\u6240\u793a\uff1a \u56fe x \u63a5\u7740\u5c06CANopenNode\u6e90\u7801\u4e2d\u63d0\u4f9b\u7684example\u6587\u4ef6\u5939\u7684\u7ed3\u6784\u5982\u4e0b\u56fex\u6240\u793a\uff0c\u5176\u4e2dCO_OD.c/h\u662f CANopen\u4e2d\u4f7f\u7528\u5230\u7684\u5bf9\u8c61\u5b57\u5178\uff0c \u6211\u4eec\u5c06\u8fd9\u4e24\u4e2a\u6587\u4ef6\u590d\u5236\u5230 MM32G5330\u6837\u4f8b\u5de5\u7a0b\u7684board\u6587\u4ef6\u5939\u4e0b\u3002main.c\u662f CANopenNode\u7684\u4e3b\u7a0b\u5e8f\u6587\u4ef6\uff0c\u6211\u4eec\u5c06\u5c06\u539f\u6709\u7684main.c\u6587\u4ef6\u8fdb\u884c\u66ff\u6362\u3002 \u56fe x \u6700\u540e\u5c06\u5982\u56fex\u6240\u793a\u7684\u4f4d\u4e8eCANopenNode-1.3/stack/drvTemplate\u6587\u4ef6\u5939\u4e0b\u7684CO_driver.c\u53caCO_driver_target.h\u8fd9\u4e24\u4e2a\u6587\u4ef6\u590d\u5236\u5230\u6837\u4f8b\u5de5\u7a0b\u7684\u6587\u4ef6\u5939\u4e0b\u3002 \u56fe x \u7531\u4e8e\u672c\u6b21\u79fb\u690d\u662f\u57fa\u4e8e\u88f8\u673a\u79fb\u690d\uff0c\u6545\u6309\u7167CANopenNode\u7684\u8bbe\u8ba1\u5c06Mainline\u7ebf\u7a0b\u653e\u5165while(1)\u4e2d\uff0cCAN\u63a5\u6536\u7ebf\u7a0b\u653e\u5165flexcan\u7684\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\u4e2d\uff0c\u5b9a\u65f6\u7ebf\u7a0b\u653e\u5728\u4e00\u4e2a1ms\u7684\u5b9a\u65f6\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\u4e2d\u3002 \u5728 main.c \u6587\u4ef6\u4e2d\u914d\u7f6e\u5b9a\u65f6\u5668 /* Setup the timer. */ void app_tim_init(void) { NVIC_InitTypeDef NVIC_InitStruct; TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct; RCC_ClocksTypeDef RCC_Clocks; RCC_GetClocksFreq(&RCC_Clocks); RCC_APB2PeriphClockCmd(RCC_APB2ENR_TIM1, ENABLE); TIM_TimeBaseStructInit(&TIM_TimeBaseInitStruct); TIM_TimeBaseInitStruct.TIM_Prescaler = (RCC_Clocks.PCLK2_Frequency / APP_TIM_UPDATE_STEP - 1); TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_COUNTERMODE_UP; TIM_TimeBaseInitStruct.TIM_Period = (APP_TIM_UPDATE_PERIOD - 1); TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStruct.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM1, &TIM_TimeBaseInitStruct); TIM_ClearFlag(TIM1, TIM_IT_UPDATE); TIM_ITConfig(TIM1, TIM_IT_UPDATE, ENABLE); NVIC_InitStruct.NVIC_IRQChannel = TIM1_UP_IRQn; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&NVIC_InitStruct); } void TIM1_UP_IRQHandler(void) { TIM_ClearITPendingBit(TIM1, TIM_IT_UPDATE); tmrTask_thread(); } \u5728 main.c \u6587\u4ef6\u4e2d\u5b9e\u73b0\u5b9a\u65f6\u7ebf\u7a0b\u4efb\u52a1\u5904\u7406 /* timer thread executes in constant intervals ********************************/ void tmrTask_thread(void){ INCREMENT_1MS(CO_timer1ms); if (CO->CANmodule[0]->CANnormal) { bool_t syncWas; /* Process Sync */ syncWas = CO_process_SYNC(CO, TMR_TASK_INTERVAL); /* Read inputs */ CO_process_RPDO(CO, syncWas); /* Further I/O or nonblocking application code may go here. */ /* Write outputs */ CO_process_TPDO(CO, syncWas, TMR_TASK_INTERVAL); /* verify timer overflow */ if((TIM_GetITStatus(TIM1, TIM_IT_UPDATE) & TIM_IT_UPDATE) != 0u) { CO_errorReport(CO->em, CO_EM_ISR_TIMER_OVERFLOW, CO_EMC_SOFTWARE_INTERNAL, 0u); TIM_ClearITPendingBit(TIM1, TIM_IT_UPDATE); } } } \u5728 main.c \u6587\u4ef6\u4e2d\u5b9e\u73b0 FlexCAN \u7684\u4e2d\u65ad\u670d\u52a1\u51fd\u6570 /* CAN interrupt function *****************************************************/ void FLEXCAN_IRQHandler(void) { FLEXCAN_TransferHandleIRQ(FLEXCAN, &FlexCAN_Handle); CO_CANinterrupt(CO->CANmodule[0]); __DSB(); } \u5728 CO_driver.c \u6587\u4ef6\u4e2d\u5b9e\u73b0FlexCAN\u6a21\u5757\u521d\u59cb\u5316 void FlexCAN_Configure(uint32_t can_bitrate) { GPIO_InitTypeDef GPIO_InitStruct; NVIC_InitTypeDef NVIC_InitStruct; RCC_ClocksTypeDef RCC_Clocks; flexcan_config_t FlexCAN_ConfigStruct; flexcan_rx_mb_config_t FlexCAN_RxMB_ConfigStruct; RCC_GetClocksFreq(&RCC_Clocks); RCC_APB1PeriphClockCmd(RCC_APB1PERIPH_FLEXCAN, ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBENR_GPIOA, ENABLE); GPIO_PinAFConfig(GPIOA, GPIO_PINSOURCE11, GPIO_AF_9); GPIO_PinAFConfig(GPIOA, GPIO_PINSOURCE12, GPIO_AF_9); GPIO_StructInit(&GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = GPIO_PIN_11; GPIO_InitStruct.GPIO_Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.GPIO_Mode = GPIO_MODE_FLOATING; GPIO_Init(GPIOA, &GPIO_InitStruct); GPIO_StructInit(&GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = GPIO_PIN_12; GPIO_InitStruct.GPIO_Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.GPIO_Mode = GPIO_MODE_AF_PP; GPIO_Init(GPIOA, &GPIO_InitStruct); NVIC_InitStruct.NVIC_IRQChannel = FLEXCAN_IRQn; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&NVIC_InitStruct); FLEXCAN_GetDefaultConfig(&FlexCAN_ConfigStruct); FlexCAN_ConfigStruct.baudRate = can_bitrate*1000; FlexCAN_ConfigStruct.clkSrc = Enum_Flexcan_ClkSrc1; FlexCAN_ConfigStruct.enableLoopBack = false; FlexCAN_ConfigStruct.disableSelfReception = true; FlexCAN_ConfigStruct.enableIndividMask = true; #if 1 /* Baudrate calculate by automatically */ FLEXCAN_CalculateImprovedTimingValues(FlexCAN_ConfigStruct.baudRate, RCC_Clocks.PCLK1_Frequency, &FlexCAN_ConfigStruct.timingConfig); #else /* You can modify the parameters yourself */ FlexCAN_ConfigStruct.timingConfig.preDivider = 23; FlexCAN_ConfigStruct.timingConfig.propSeg = 6; FlexCAN_ConfigStruct.timingConfig.phaseSeg1 = 3; FlexCAN_ConfigStruct.timingConfig.phaseSeg2 = 3; FlexCAN_ConfigStruct.timingConfig.rJumpwidth = 3; #endif FLEXCAN_Init(FLEXCAN, &FlexCAN_ConfigStruct); /* Set Tx MB_2. */ FLEXCAN_TxMbConfig(FLEXCAN, BOARD_FLEXCAN_TX_MB_CH, ENABLE); FLEXCAN_TransferCreateHandle(FLEXCAN, &FlexCAN_Handle, FlexCAN_Transfer_Callback, NULL); /* Set Rx MB_0. */ FlexCAN_RxMB_ConfigStruct.id = FLEXCAN_ID_STD(0x222); FlexCAN_RxMB_ConfigStruct.format = Enum_Flexcan_FrameFormatStandard; FlexCAN_RxMB_ConfigStruct.type = Enum_Flexcan_FrameTypeData; FLEXCAN_RxMbConfig(FLEXCAN, BOARD_FLEXCAN_RX_MB_CH, &FlexCAN_RxMB_ConfigStruct, ENABLE); /* Set Rx Individual Mask. */ FLEXCAN_SetRxIndividualMask(FLEXCAN, BOARD_FLEXCAN_RX_MB_CH, FLEXCAN_RX_MB_STD_MASK(0x000, 0, 0)); FlexCAN_MB0_FrameStruct.length = (uint8_t)(8); FlexCAN_MB0_FrameStruct.type = (uint8_t)Enum_Flexcan_FrameTypeData; FlexCAN_MB0_FrameStruct.format = (uint8_t)Enum_Flexcan_FrameFormatStandard; FlexCAN_MB0_FrameStruct.id = FLEXCAN_ID_STD(0x222); FlexCAN_MB0_TransferStruct.mbIdx = BOARD_FLEXCAN_RX_MB_CH; FlexCAN_MB0_TransferStruct.frame = &FlexCAN_MB0_FrameStruct; FLEXCAN_TransferReceiveNonBlocking(FLEXCAN, &FlexCAN_Handle, &FlexCAN_MB0_TransferStruct); } /******************************************************************************/ CO_ReturnError_t CO_CANmodule_init( CO_CANmodule_t *CANmodule, void *CANdriverState, CO_CANrx_t rxArray[], uint16_t rxSize, CO_CANtx_t txArray[], uint16_t txSize, uint16_t CANbitRate) { uint16_t i; /* verify arguments */ if(CANmodule==NULL || rxArray==NULL || txArray==NULL){ return CO_ERROR_ILLEGAL_ARGUMENT; } /* Configure object variables */ CANmodule->CANdriverState = CANdriverState; CANmodule->rxArray = rxArray; CANmodule->rxSize = rxSize; CANmodule->txArray = txArray; CANmodule->txSize = txSize; CANmodule->CANnormal = false; CANmodule->useCANrxFilters = false;/* microcontroller dependent */ CANmodule->bufferInhibitFlag = false; CANmodule->firstCANtxMessage = true; CANmodule->CANtxCount = 0U; CANmodule->errOld = 0U; CANmodule->em = NULL; for(i=0U; i<rxSize; i++){ rxArray[i].ident = 0U; rxArray[i].mask = 0xFFFFU; rxArray[i].object = NULL; rxArray[i].pFunct = NULL; } for(i=0U; i<txSize; i++){ txArray[i].bufferFull = false; } FlexCAN_Configure(CANbitRate); return CO_ERROR_NO; } \u5728 CO_driver.c \u6587\u4ef6\u4e2d\u5b9e\u73b0FlexCAN\u7684\u62a5\u6587\u6536\u53d1 /* Send a message frame. */ bool flexcan_tx(CO_CANtx_t *buffer) { bool status = false; flexcan_frame_t FlexCAN_FrameStruct; flexcan_mb_transfer_t FlexCAN_MB_TransferStruct; if (!buffer->rtr) { FlexCAN_FrameStruct.type = (uint8_t)Enum_Flexcan_FrameTypeData; /* Data frame type. */ } else { FlexCAN_FrameStruct.type = (uint8_t)Enum_Flexcan_FrameTypeRemote; /* Remote frame type. */ } FlexCAN_FrameStruct.length = (uint8_t)buffer->DLC; FlexCAN_FrameStruct.format = (uint8_t)Enum_Flexcan_FrameFormatStandard; FlexCAN_FrameStruct.id = FLEXCAN_ID_STD(buffer->ident); /* Indicated ID number. */ FlexCAN_FrameStruct.dataByte0 = buffer->data[0]; FlexCAN_FrameStruct.dataByte1 = buffer->data[1]; FlexCAN_FrameStruct.dataByte2 = buffer->data[2]; FlexCAN_FrameStruct.dataByte3 = buffer->data[3]; FlexCAN_FrameStruct.dataByte4 = buffer->data[4]; FlexCAN_FrameStruct.dataByte5 = buffer->data[5]; FlexCAN_FrameStruct.dataByte6 = buffer->data[6]; FlexCAN_FrameStruct.dataByte7 = buffer->data[7]; FlexCAN_MB_TransferStruct.mbIdx = 2; FlexCAN_MB_TransferStruct.frame = &FlexCAN_FrameStruct; if (Status_Flexcan_Success == FLEXCAN_TransferSendNonBlocking(FLEXCAN, &FlexCAN_Handle, &FlexCAN_MB_TransferStruct)) { status = true; } return status; } /******************************************************************************/ CO_ReturnError_t CO_CANsend(CO_CANmodule_t *CANmodule, CO_CANtx_t *buffer){ CO_ReturnError_t err = CO_ERROR_NO; /* Verify overflow */ if(buffer->bufferFull){ if(!CANmodule->firstCANtxMessage){ /* don't set error, if bootup message is still on buffers */ CO_errorReport((CO_EM_t*)CANmodule->em, CO_EM_CAN_TX_OVERFLOW, CO_EMC_CAN_OVERRUN, buffer->ident); } err = CO_ERROR_TX_OVERFLOW; } CO_LOCK_CAN_SEND(); bool tx_mb_status = flexcan_tx(buffer); if(tx_mb_status == true){ CANmodule->bufferInhibitFlag = buffer->syncFlag; } /* if no buffer is free, message will be sent by interrupt */ else{ buffer->bufferFull = true; CANmodule->CANtxCount++; } CO_UNLOCK_CAN_SEND(); return err; } void CO_CANinterrupt(CO_CANmodule_t *CANmodule){ uint32_t status = FLEXCAN->IFLAG1; if (0 != (status & (BOARD_FLEXCAN_RX_MB_STATUS)) || (FlexCAN_MB0_RxCompleteFlag)) { /* receive interrupt */ CO_CANrxMsg_t *rcvMsg; /* pointer to received message in CAN module */ CO_CANrxMsg_t rcvMsgBuff; uint16_t index; /* index of received message */ uint32_t rcvMsgIdent; /* identifier of the received message */ CO_CANrx_t *buffer = NULL; /* receive message buffer from CO_CANmodule_t object. */ bool_t msgMatched = false; /* get message from module here */ rcvMsg = &rcvMsgBuff; rcvMsg->ident = (FlexCAN_MBTemp_FrameStruct.id>> CAN_ID_STD_SHIFT)&0x7FF; rcvMsg->DLC = FlexCAN_MBTemp_FrameStruct.length; rcvMsg->data[0] = FlexCAN_MBTemp_FrameStruct.dataByte0; rcvMsg->data[1] = FlexCAN_MBTemp_FrameStruct.dataByte1; rcvMsg->data[2] = FlexCAN_MBTemp_FrameStruct.dataByte2; rcvMsg->data[3] = FlexCAN_MBTemp_FrameStruct.dataByte3; rcvMsg->data[4] = FlexCAN_MBTemp_FrameStruct.dataByte4; rcvMsg->data[5] = FlexCAN_MBTemp_FrameStruct.dataByte5; rcvMsg->data[6] = FlexCAN_MBTemp_FrameStruct.dataByte6; rcvMsg->data[7] = FlexCAN_MBTemp_FrameStruct.dataByte7; rcvMsgIdent = rcvMsg->ident; FlexCAN_MB0_RxCompleteFlag = 0; /* CAN module filters are not used, message with any standard 11-bit identifier */ /* has been received. Search rxArray form CANmodule for the same CAN-ID. */ buffer = &CANmodule->rxArray[0]; for(index = CANmodule->rxSize; index > 0U; index--){ if(((rcvMsgIdent ^ buffer->ident) & buffer->mask) == 0U){ msgMatched = true; break; } buffer++; } /* Call specific function, which will process the message */ if(msgMatched && (buffer != NULL) && (buffer->pFunct != NULL)){ buffer->pFunct(buffer->object, rcvMsg); } /* Clear interrupt flag */ FLEXCAN_ClearMbStatusFlags(FLEXCAN, BOARD_FLEXCAN_RX_MB_STATUS); } else if (0 != (status & BOARD_FLEXCAN_TX_MB_STATUS)) { /* Clear interrupt flag */ FLEXCAN_ClearMbStatusFlags(FLEXCAN, BOARD_FLEXCAN_TX_MB_STATUS); /* First CAN message (bootup) was sent successfully */ CANmodule->firstCANtxMessage = false; /* clear flag from previous message */ CANmodule->bufferInhibitFlag = false; /* Are there any new messages waiting to be send */ if(CANmodule->CANtxCount > 0U){ uint16_t i; /* index of transmitting message */ /* first buffer */ CO_CANtx_t *buffer = &CANmodule->txArray[0]; /* search through whole array of pointers to transmit message buffers. */ for(i = CANmodule->txSize; i > 0U; i--){ /* if message buffer is full, send it. */ if(buffer->bufferFull){ buffer->bufferFull = false; CANmodule->CANtxCount--; /* Copy message to CAN buffer */ CANmodule->bufferInhibitFlag = buffer->syncFlag; CO_CANsend(CANmodule, buffer); break; /* exit for loop */ } buffer++; }/* end of for loop */ /* Clear counter if no more messages */ if(i == 0U){ CANmodule->CANtxCount = 0U; } } } else{ /* some other interrupt reason */ } } \u5728 CO_driver.c \u6587\u4ef6\u4e2d\u5b9e\u73b0CAN\u603b\u7ebf\u9519\u8bef\u68c0\u6d4b void CO_CANverifyErrors(CO_CANmodule_t *CANmodule){ uint16_t rxErrors, txErrors, overflow; CO_EM_t* em = (CO_EM_t*)CANmodule->em; uint32_t err; /* get error counters from module. Id possible, function may use different way to * determine errors. */ rxErrors = (uint16_t) ((FLEXCAN->ECR & CAN_ECR_RXERRCNT_MASK) >> CAN_ECR_RXERRCNT_SHIFT); txErrors = (uint16_t) ((FLEXCAN->ECR & CAN_ECR_TXERRCNT_MASK) >> CAN_ECR_TXERRCNT_SHIFT); overflow = (uint16_t) ((FLEXCAN->ESR1 & CAN_ESR1_ERROVR_MASK) >> CAN_ESR1_ERROVR_SHIFT); err = ((uint32_t)txErrors << 16) | ((uint32_t)rxErrors << 8) | overflow; if(CANmodule->errOld != err){ CANmodule->errOld = err; if(txErrors >= 256U){ /* bus off */ CO_errorReport(em, CO_EM_CAN_TX_BUS_OFF, CO_EMC_BUS_OFF_RECOVERED, err); } else{ /* not bus off */ CO_errorReset(em, CO_EM_CAN_TX_BUS_OFF, err); if((rxErrors >= 96U) || (txErrors >= 96U)){ /* bus warning */ CO_errorReport(em, CO_EM_CAN_BUS_WARNING, CO_EMC_NO_ERROR, err); } if(rxErrors >= 128U){ /* RX bus passive */ CO_errorReport(em, CO_EM_CAN_RX_BUS_PASSIVE, CO_EMC_CAN_PASSIVE, err); } else{ CO_errorReset(em, CO_EM_CAN_RX_BUS_PASSIVE, err); } if(txErrors >= 128U){ /* TX bus passive */ if(!CANmodule->firstCANtxMessage){ CO_errorReport(em, CO_EM_CAN_TX_BUS_PASSIVE, CO_EMC_CAN_PASSIVE, err); } } else{ bool_t isError = CO_isError(em, CO_EM_CAN_TX_BUS_PASSIVE); if(isError){ CO_errorReset(em, CO_EM_CAN_TX_BUS_PASSIVE, err); CO_errorReset(em, CO_EM_CAN_TX_OVERFLOW, err); } } if((rxErrors < 96U) && (txErrors < 96U)){ /* no error */ CO_errorReset(em, CO_EM_CAN_BUS_WARNING, err); } } if(overflow != 0U){ /* CAN RX bus overflow */ CO_errorReport(em, CO_EM_CAN_RXB_OVERFLOW, CO_EMC_CAN_OVERRUN, err); } } } \u5c06\u4e0a\u8ff0\u6587\u4ef6\u590d\u5236\u5230\u5bf9\u5e94\u7684\u5de5\u7a0b\u6837\u4f8b\u6587\u4ef6\u8def\u5f84\u4e0b\uff0c\u5e76\u5c06\u8fd9\u4e9b\u6587\u4ef6\u6dfb\u52a0\u8fdb\u5de5\u7a0b\u7f16\u8bd1\u6587\u4ef6\u5217\u8868\u4e2d\u540e\uff0c\u7f16\u8bd1\u4e0b\u8f7d\u7a0b\u5e8f\uff0cCANopen\u8282\u70b9\u4e0a\u7ebf\u5411CAN\u7f51\u7edc\u53d1\u9001CANopen\u8282\u70b9\u4e0a\u7ebf\u62a5\u6587\uff0c\u4e0a\u4f4d\u673a\u6536\u5230\u4e00\u6761\u5982\u4e0b\u62a5\u6587\uff1a \u8868x: CAN-ID(hex) Length Data(hex) 70A 1 00 \u4e4b\u540e\u8be5CANopen\u8282\u70b9\u4ee5 1000ms \u7684\u65f6\u95f4\u95f4\u9694\u5411CAN\u7f51\u7edc\u53d1\u9001\u8282\u70b9\u5fc3\u8df3\u62a5\u6587\uff0c\u4e0a\u4f4d\u673a\u4ee51000ms\u7684\u65f6\u95f4\u95f4\u9694\u6536\u5230\u5982\u4e0b\u62a5\u6587\uff1a \u8868x: CAN-ID(hex) Length Data(hex) 70A 1 05 \u5982\u56fex\u6240\u793a\u3002 \u56fex \u81f3\u6b64\uff0c\u53ef\u9a8c\u8bc1\u8be5CANopen\u8282\u70b9\u8bbe\u5907\u6210\u529f\u542f\u52a8\u5e76\u5f00\u59cb\u6b63\u5e38\u8fd0\u884c\u3002 \u540c\u65f6\u5728\u7075\u52a8\u63d0\u4f9b\u7684\u6837\u4f8b\u4e2d\uff0c\u4e5f\u63d0\u4f9b\u4e86\u4e00\u4e9b\u79fb\u690d\u597d\u7684CANopenNode\u6837\u4f8b\u5de5\u7a0b\uff0c\u4f9b\u5927\u5bb6\u9a8c\u8bc1\u6d4b\u8bd5\uff1a CANopen_Basic\u6837\u4f8b \u6f14\u793a\u4e86CANopenNode\u7684\u57fa\u672c\u6837\u4f8b\u529f\u80fd\u3002 CANopen_PDO_TPDO&CANopen_PDO_RPDO\u6837\u4f8b \u6f14\u793a\u4e86CANopen\u7684TPDO\u4e0eRPDO\u4e4b\u95f4\u901a\u4fe1\u7684\u6837\u4f8b\u3002 CANopen_SDO_Server&CANopen_SDO_Client\u6837\u4f8b \u6f14\u793a\u4e86CANopen\u7684SDO Server\u4e0eSDO Client\u4e4b\u95f4\u901a\u4fe1\u7684\u6837\u4f8b\u3002","title":"\u57fa\u4e8eFlexCAN\u5916\u8bbe\u79fb\u690dCANopenNode"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#_2","text":"","title":"\u8c03\u8bd5\u4e0e\u5f00\u53d1"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#_3","text":"\u4f7f\u7528\u642d\u8f7d\u4e86MM32G5330 MCU\u7684\u5f00\u53d1\u677fMini-G5330 \uff0c\u4ee5CANopen_Basic\u6837\u4f8b\u5de5\u7a0b\u4e3a\u4f8b\uff0c\u5c06\u5f00\u53d1\u677f\u4e0a\u7684CAN\u6536\u53d1\u5668\u4e0ePCAN\u76f8\u8fde\u63a5\uff0c\u5e76\u5c06PCAN\u4e0ePC\u673a\u901a\u8fc7USB\u76f8\u8fde\u63a5\uff0c\u5728PC\u7aef\uff08\u57fa\u4e8eWin10\u64cd\u4f5c\u7cfb\u7edf\uff09\u4f7f\u7528PCAN-View\u4e0a\u4f4d\u673a\u8fdb\u884cCAN\u901a\u4fe1\uff0c\u5982\u56fex\u6240\u793a\u3002 \u56fex MCU\u4e0ePC\u673a\u4ea4\u4e92\u793a\u610f\u56fe \u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u4e86PCAN-USB\uff0c\u5e76\u4f7f\u7528\u4e86\u5176\u5b98\u65b9\u7684\u914d\u5957\u4e0a\u4f4d\u673aPCAN-View\u3002\u5176PCAN-USB\u9a71\u52a8\u4e0b\u8f7d\u94fe\u63a5\u4e3a\uff1a https://peak-system.com.cn/driver/ \uff1bPCAN-View \u5b89\u88c5\u5305\u4e0b\u8f7d\u94fe\u63a5\u4e3a: https://peak-system.com.cn/wp-content/uploads/2022/06/pcanview.zip \uff1bPCAN-View\u4f7f\u7528\u8bf4\u660e\u89c1\u5982\u4e0b\u94fe\u63a5: https://peak-system.com.cn/software/apsoftware/pcan-view/","title":"\u73af\u5883\u642d\u5efa"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#_4","text":"\u5c06\u4e0a\u8ff0\u73af\u5883\u642d\u5efa\u597d\u540e\uff0c\u5c06MCU\u4e0a\u7535\u5e76\u590d\u4f4d\uff0c\u5e76\u901a\u8fc7PC\u7aef\u4e0a\u4f4d\u673aPCAN-View\u6d4b\u8bd5\u5982\u4e0b\u6307\u4ee4\uff0c\u89c2\u5bdfCANopen\u8282\u70b9\u5176\u5bf9\u6307\u4ee4\u7684\u54cd\u5e94\uff0c\u6765\u5224\u65ad\u8be5CANopen\u8282\u70b9\u662f\u5426\u5904\u4e8e\u6b63\u5e38\u8fd0\u884c\u72b6\u6001\u3002 \u5c06NODE-ID\u4e3a0x0A\u7684\u8282\u70b9\u8bbe\u7f6e\u4e3a Stop \u6a21\u5f0f\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 000 2 02 0A \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u53ef\u63a5\u6536\u5230\u5982\u4e0b\u62a5\u6587\uff1a \u56fe x \u5c06NODE-ID\u4e3a0x0A\u7684\u8282\u70b9\u8bbe\u7f6e\u4e3a Start \u6a21\u5f0f\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 000 2 01 0A \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u53ef\u63a5\u6536\u5230\u5982\u4e0b\u62a5\u6587\uff1a \u56fex \u5c06NODE-ID\u4e3a0x0A\u7684\u8282\u70b9\u8bbe\u7f6e\u4e3aPre-operation\u6a21\u5f0f\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 70A 2 80 0A \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u8be5\u8282\u70b9\u8fdb\u5165Pre-operation\u6a21\u5f0f\uff0c\u53ef\u63a5\u6536\u5230\u5982\u4e0b\u62a5\u6587\uff1a \u56fe x \u5c06NODE-ID\u4e3a0x0A\u8282\u70b9\u590d\u4f4d\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 70A 2 81 0A \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u8be5\u8282\u70b9\u88ab\u590d\u4f4d\uff1a \u56fe x \u5c06NODE-ID\u4e3a0x0A\u8282\u70b9\u7684\u901a\u4fe1\u5c42\u590d\u4f4d\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 70A 2 82 0A \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u8be5\u8282\u70b9\u901a\u4fe1\u5c42\u88ab\u590d\u4f4d\uff0c\u91cd\u65b0\u4e0a\u7ebf\uff1a \u56fe x \u83b7\u53d6NODE-ID\u4e3a0x0A\u8282\u70b9\u7684\u5fc3\u8df3\u53d1\u9001\u95f4\u9694\u65f6\u95f4\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 60A 8 40 17 10 00 00 00 00 00 \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u8fd4\u56de\u8be5\u8282\u70b9\u5f53\u524d\u5fc3\u8df3\u53d1\u9001\u95f4\u9694\u65f6\u95f4\u4e3a1000(0x03E8)ms\uff1a \u56fe x \u8bbe\u7f6eNODE-ID\u4e3a0x0A\u8282\u70b9\u7684\u5fc3\u8df3\u53d1\u9001\u95f4\u9694\u65f6\u95f4\u4e3a500(0x01F4)ms\uff0c\u4e0a\u4f4d\u673aPCAN-View\u53d1\u9001\u5982\u4e0b\u6307\u4ee4\uff1a \u8868x CAN-ID(hex) Length Data(hex) 60A 8 2B 17 10 00 F4 01 00 00 \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u8be5\u8282\u70b9\u5f53\u524d\u5fc3\u8df3\u53d1\u9001\u95f4\u9694\u65f6\u95f4\u53d8\u4e3a500ms\uff1a \u56fe x","title":"\u4e0a\u7535\u8c03\u8bd5"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#_5","text":"\u672c\u7ae0\u8282\u8bb2\u89e3\u4e86CANopen\u7684\u57fa\u672c\u6982\u5ff5\uff0c\u5e76\u5bf9CANopenNode\u5f00\u6e90\u534f\u8bae\u6808\u8fdb\u884c\u4e86\u4ecb\u7ecd\uff0c\u8bb2\u89e3\u4e86\u5982\u4f55\u57fa\u4e8eMM32G5330 MCU\u5bf9CANopenNode\u534f\u8bae\u6808\u8fdb\u884c\u79fb\u690d\uff0c\u4ee5\u53ca\u5bf9\u79fb\u690d\u540e\u7684CANopen_Basic\u6837\u4f8b\u8fdb\u884c\u57fa\u672c\u6307\u4ee4\u54cd\u5e94\u529f\u80fd\u7684\u9a8c\u8bc1\u3002","title":"\u603b\u7ed3"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMM32G5330%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/#_6","text":"[CiA - CANopen] https://www.can-cia.org/canopen/ [CANopenNode] https://github.com/CANopenNode/CANopenNode [CANopen_easy_begin] https://www.zlg.cn/data/upload/software/Can/CANopen_easy_begin.pdf [CANopen Explained - A Simple Intro] https://www.csselectronics.com/pages/canopen-tutorial-simple-intro [CANopen: The Ultimate Guide (2023) (autopi.io)] https://www.autopi.io/blog/canopen-simple-introduction-explained/","title":"\u53c2\u8003\u6587\u732e"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/","text":"\u4ece\u96f6\u5f00\u59cb\u79fb\u690dTinyUSB\u534f\u8bae\u6808 \u4ece\u96f6\u5f00\u59cb\u79fb\u690dTinyUSB\u534f\u8bae\u6808 \u7b80\u4ecb \u83b7\u53d6MCU\u5e93\u51fd\u6570\u4e0e\u4f8b\u7a0b \u83b7\u53d6TinyUSB\u534f\u8bae\u6808 \u5de5\u7a0b\u76ee\u5f55\u7ed3\u6784 \u914d\u7f6e\u79fb\u690d\u63a5\u53e3 \u914d\u7f6eUSB Device\u63a5\u53e3 USB \u7aef\u70b9\u7ba1\u7406 USB \u9a71\u52a8\u4f7f\u80fd USB Device \u4e2d\u65ad \u914d\u7f6eUSB Host\u63a5\u53e3 \u53cc\u5411\u961f\u5217\u5b9e\u73b0 \u6570\u636e\u5e93\u5b9e\u73b0 USB \u7f13\u51b2\u63cf\u8ff0\u8868\u5b9a\u4e49 USB \u7aef\u70b9\u7ba1\u7406 USB\u9a71\u52a8\u4f7f\u80fd USB Host\u4e2d\u65ad \u521b\u5efa\u5de5\u7a0b\u6837\u4f8b \u6837\u4f8b\u6f14\u793a TinyUSB\u534f\u8bae\u6808\u6837\u4f8b\u4ecb\u7ecd board_test tud_cdc_dual_ports tud_cdc_msc tud_hid_composite tud_msc_dual_lun tud_video_capture tud_webusb_serial tuh_bare_api tuh_cdc_msc_hid tuh_hid_controller \u6ce8\u610f\u4e8b\u9879 USB\u672f\u8bed\u89e3\u6790 \u53c2\u8003\u6587\u732e \u7b80\u4ecb \u672c\u6587\u5c06\u57fa\u4e8e Mini-F5277-OB \u5f00\u53d1\u677f\uff0c\u8bb2\u89e3\u4ece\u96f6\u5f00\u59cb\u79fb\u690dTiny USB\u534f\u8bae\u6808\u7684\u5168\u8fc7\u7a0b\u3002 Mini-F5277-OB \u5f00\u53d1\u677f\u4ecb\u7ecd Mini-F5277-OB \u5f00\u53d1\u677f\uff0c\u642d\u8f7d\u4e86MM32F5270\u7cfb\u5217\u4e2d MM32F5277E7PV \u578b\u53f7\u7684MCU\uff0c\u4e3a32\u4f4d Arm China STAR-MC1 \u67b6\u6784\uff0c\u5185\u7f6e 256KB Flash\uff0c192KB SRAM\uff0c\u5e76\u5e26\u6709USB\u5168\u901f\u8bbe\u5907\u63a7\u5236\u5668\uff0c\u652f\u6301 12Mbps \u7684\u4f20\u8f93\u901f\u7387\u3002\u5728\u914d\u7f6e\u4e3a USB Host \u6a21\u5f0f\u4e0b\u652f\u6301 12Mbps \u7684\u5168\u901f\u4f20\u8f93\u548c 1.5 Mbps \u7684\u4f4e\u901f\u4f20\u8f93\u901f\u7387\u3002\u5176\u4e2d USB_FS \u63a7\u5236\u5668\u5185\u7f6e USB \u5168\u901f PHY\u3002\u8be6\u60c5\u89c1\uff1a \u4e0a\u6d77\u7075\u52a8\u5fae\u7535\u5b50\u80a1\u4efd\u6709\u9650\u516c\u53f8 (mindmotion.com.cn) \u5b98\u7f51\u3002 TinyUSB \u534f\u8bae\u6808\u4ecb\u7ecd TinyUSB \u662f\u4e00\u4e2a\u5e94\u7528\u4e8e\u5d4c\u5165\u5f0f\u7cfb\u7edf\u7684\u5f00\u6e90\u8de8\u5e73\u53f0 USB Host / Device \u534f\u8bae\u6808\uff0c\u5176\u4f18\u70b9\u4e3a\uff1a MIT \u5f00\u6e90\u534f\u8bae\uff0c\u4e0d\u7528\u62c5\u5fc3\u7248\u6743\u95ee\u9898\uff1b \u5185\u5b58\u5b89\u5168\uff08\u6ca1\u6709\u52a8\u6001\u5185\u5b58\u5206\u914d\uff09\uff1b \u7ebf\u7a0b\u5b89\u5168\uff08\u6240\u6709\u4e2d\u65ad\u4e8b\u4ef6\u90fd\u4f1a\u653e\u5728\u975e\u4e2d\u65ad\u51fd\u6570\u4e2d\u5904\u7406\uff09\u3002 \u5982\u4e0b\u56fe\u6240\u793a\uff0c\u4e3aTinyUSB\u534f\u8bae\u6808\u7ed3\u6784\u6846\u56fe\uff1a \u56fex TinyUSB \u534f\u8bae\u6808\u6846\u56fe \u7531\u4e0a\u56fe\u53ef\u77e5\uff0cTinyUSB\u534f\u8bae\u6808\u4e2d\u7684Host \u4e0e Device \u662f\u76f8\u4e92\u72ec\u7acb\u7684\u4e24\u4e2a\u534f\u8bae\u3002 TinyUSB \u534f\u8bae\u6808\u4e2d\u7684 Device \u534f\u8bae\u5e94\u7528\u8f83\u4e3a\u5e7f\u6cdb\uff0c\u652f\u6301\u7684 USB \u7c7b\u4e5f\u5341\u5206\u4e30\u5bcc\uff1a Audio Class 2.0 (UAC2) Bluetooth Host Controller Interface (BTH HCI) Communication Class (CDC) Device Firmware Update (DFU): DFU mode (WIP) and Runtinme Human Interface Device (HID): Generic (In & Out), Keyboard, Mouse, Gamepad etc \u2026 Mass Storage Class (MSC): with multiple LUNs Musical Instrument Digital Interface (MIDI) Network with RNDIS, CDC-ECM (work in progress) USB Test and Measurement Class (USBTMC) Vendor-specific class support with generic In & Out endpoints. Can be used with MS OS 2.0 compatible descriptor to load winUSB driver without INF file. WebUSB with vendor-specific class \u800c Host \u652f\u6301\u7684\u7c7b\uff0c\u6682\u65f6\u63d0\u4f9b\u4e86\u4e24\u4e2a\uff0c\u4e0d\u8fc7\u5bf9\u4e8e MCU \u7684\u8fd9\u79cd\u8d44\u6e90\u7684\u5e94\u7528\u800c\u8a00\uff0c\u4ee5\u4e0b\u4e24\u4e2a\u7c7b\u8db3\u591f\u6ee1\u8db3\u5927\u90e8\u5206\u9700\u6c42\u4e86\uff1a Human Interface Device (HID): Keyboard, Mouse, Generic Mass Storage Class (MSC) \u83b7\u53d6MCU\u5e93\u51fd\u6570\u4e0e\u4f8b\u7a0b Mini-F5277-OB \u5f00\u53d1\u677f\u7684\u9a71\u52a8\u6837\u4f8b\u53ca\u539f\u7406\u56fe\u4f4d\u4e8e\uff1a https://www.mindmotion.com.cn/support/development_tools/evaluation_boards/miniboard/mm32f5277e7pv/ \uff0c\u4e0b\u8f7d MM32F5270 \u5e93\u51fd\u6570\u4e0e\u4f8b\u7a0b \uff0c\u8fd9\u91cc\u6211\u4eec\u7528\u5230\u4e86\u8f6f\u4ef6\u5305\u4e2d\u7684 device \u6587\u4ef6\u5939\uff0c\u5176\u4e2d\u5305\u542bMCU\u7684\u542f\u52a8\u6587\u4ef6\u548c\u9a71\u52a8\u6587\u4ef6\u3002 \u83b7\u53d6TinyUSB\u534f\u8bae\u6808 TinyUSB\u534f\u8bae\u6808\u6e90\u7801\u4e0b\u8f7d\u5730\u5740\uff1a https://github.com/hathach/tinyusb/releases/tag/0.16.0 \u672c\u6b21\u79fb\u690d\u662f\u57fa\u4e8e\u622a\u6b62\u672c\u6587\u7f16\u5199\u65f6\u6700\u65b0\u7248\u672c\u7684 TinyUSB V0.16.0 \u8fdb\u884c\u79fb\u690d\uff0c\u8fd9\u91cc\u6211\u4eec\u7528\u5230\u4e86\u8f6f\u4ef6\u5305 tinyusb\\src \u4f5c\u4e3a\u534f\u8bae\u6808\u6e90\u7801\u3001 tinyusb\\examples \u6587\u4ef6\u5939\u4e2dUSB \u6837\u4f8b\u4ee3\u7801\u548c tinyusb\\hw\\bsp \u6587\u4ef6\u5939\u4e2d\u7684\u652f\u6301\u7684\u5f00\u53d1\u677f\u6e90\u6587\u4ef6\u3002 . \u251c\u2500\u2500 docs # Documentation \u251c\u2500\u2500 examples # Examples with make and cmake build system \u251c\u2500\u2500 hw \u2502 \u251c\u2500\u2500 bsp # Supported boards source files \u2502 \u2514\u2500\u2500 mcu # Low level mcu core & peripheral drivers \u251c\u2500\u2500 lib # Sources from 3rd party such as freeRTOS, fatfs ... \u251c\u2500\u2500 src # All sources files for TinyUSB stack itself. \u251c\u2500\u2500 test # Tests: unit test, fuzzing, hardware test \u2514\u2500\u2500 tools # Files used internally \u5de5\u7a0b\u76ee\u5f55\u7ed3\u6784 \u5982\u4e0b\u56fex\u6240\u793a\uff0c\u6574\u4e2aTinyUSB\u534f\u8bae\u6808\u9002\u914d\u5de5\u7a0b\u7684\u5efa\u7acb\u5206\u4e3a\u4ee5\u4e0b\u56db\u4e2a\u90e8\u5206\uff1a device - MCU\u542f\u52a8\u6587\u4ef6\u53ca\u5916\u8bbe\u9a71\u52a8 examples - TinyUSB\u534f\u8bae\u6808\u6837\u4f8b tinyusb - TinyUSB\u534f\u8bae\u6808\u6e90\u7801 tinyusb_port - TinyUSB\u534f\u8bae\u6808\u79fb\u690d\u63a5\u53e3\u53caUSB\u9a71\u52a8 \u56fex \u9664\u4e86\u5c06\u4e0a\u8ff0\u63d0\u5230\u7684 MM32F5270 \u5e93\u51fd\u6570\u4e0e\u4f8b\u7a0b \u8f6f\u4ef6\u5305\u4e2d\u7684 device \u6587\u4ef6\u5939\u548c TinyUSB V0.16.0 \u8f6f\u4ef6\u5305 \u4e2d tinyusb\\src \u6587\u4ef6\u5939\u62f7\u8d1d\u5230\u76ee\u6807\u5de5\u7a0b\u6587\u4ef6\u5939\u4e2d\u5916\uff0c\u8981\u65b0\u5efa examples \u6587\u4ef6\u5939\u548c tinyusb_port \u6587\u4ef6\u5939\u3002\u5728\u83b7\u53d6\u7684TinyUSB\u534f\u8bae\u6808\u7684 examples \u6587\u4ef6\u5939\u4e2d\uff0c\u627e\u5230\u76ee\u6807\u6837\u4f8b\u3002\u63a5\u4e0b\u6765\u672c\u6587\u5c06\u4ee5 tinyusb\\exmaples\\device \u6587\u4ef6\u5939\u4e2d\u7684 cdc_msc \u6837\u4f8b\u4e3a\u4f8b\u8fdb\u884c\u79fb\u690d\u6f14\u793a\u3002 \u914d\u7f6e\u79fb\u690d\u63a5\u53e3 TinyUSB \u534f\u8bae\u6808\u7684\u79fb\u690d\u63a5\u53e3\u5206\u4e3a USB Device\u63a5\u53e3\u548c USB Host\u63a5\u53e3\uff0c\u8fd9\u91cc\u7edf\u4e00\u5728\u76ee\u6807\u5de5\u7a0b\u6587\u4ef6\u5939\u7684 tinyusb_port \u6587\u4ef6\u5939\u4e2d\u8fdb\u884c\u5b9e\u73b0\uff0c\u5982\u56fex\u6240\u793a\u3002 \u56fex \u5176\u4e2d bsp \u6587\u4ef6\u5939\u4e2d\uff0c\u653e\u7f6e\u4e86TinyUSB\u534f\u8bae\u6808\u4e2d tinyusb\\hw\\bsp \u6587\u4ef6\u5939\u4e0b\u7684 ansi_escape.h \u3001 board.c \u3001 board_api.h \u548c board_mcu.h \u6587\u4ef6\uff0c\u5982\u56fex\u6240\u793a\u3002 \u56fex hal_usb.c \u3001 hal_usb.h \u3001 hal_usb_bdt.h \u548c reg_usb.h \u6587\u4ef6\u4e3a USB\u9a71\u52a8\u76f8\u5173\u6587\u4ef6\uff0c\u82e5MCU\u4e2d\u7684 USB IP\u4e00\u81f4\u5219\u53ef\u590d\u7528\u8be5USB \u9a71\u52a8\u6587\u4ef6\u3002 tud_dcd_port.c \u548c tuh_hcd_port.c \u662f\u57fa\u4e8e USB \u9a71\u52a8\u5b9e\u73b0\u7684TinyUSB\u534f\u8bae\u6808\u4e2dUSB Device\u79fb\u690d\u63a5\u53e3\u548cUSB Host\u79fb\u690d\u63a5\u53e3 \u3002 mini_f5277_ob.c \u6587\u4ef6\u5b9e\u73b0\u4e86\u677f\u8f7dMCU\u7684USB\u76f8\u5173\u7684\u65f6\u949f\u914d\u7f6e\u3001UART\u521d\u59cb\u5316\u3001printf \u51fd\u6570\u91cd\u6620\u5c04\u548c\u677f\u8f7dLED\u548c\u6309\u952e\u7684GPIO\u521d\u59cb\u5316\uff0c\u6b64\u6587\u4ef6\u53ef\u4ee5\u6839\u636e\u4e0d\u540c\u7684\u5f00\u53d1\u7248\u548cMCU\u578b\u53f7\u8fdb\u884c\u5b9e\u73b0\u3002 #include \"bsp/board_api.h\" #include \"mm32_device.h\" #include \"mm32f5270.h\" // Initialize on-board peripherals : led, button, uart and USB void board_init(void) { // Config PLL2 clock param. RCC_PLL2Config(1, 0, 7, 1); // PLL2 = HSE * (7+1) / (1+1) = 48MHz RCC->PLL2CFGR |= 3 << RCC_PLL2CFGR_PLL2_ICTRL_Pos; // Enable PLL2 clock. RCC_PLL2Cmd(ENABLE); while((RCC->CR & RCC_CR_PLL2RDY_Msk) == 0) { } // Select PLL2 as USB clock source. MODIFY_REG(RCC->CFGR, RCC_CFGR_USBCLKSEL_Msk, 1 << RCC_CFGR_USBCLKSEL_Pos); // Enable USB Clock. MODIFY_REG(RCC->CFGR, RCC_CFGR_USBPRE_Msk, 0 << RCC_CFGR_USBPRE_Pos); // Select HSE as system clock. RCC_SYSCLKConfig(2); // clock init. RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART2, ENABLE); // sys time init; #if CFG_TUSB_OS == OPT_OS_NONE RCC_ClocksTypeDef sys_clk; RCC_GetClocksFreq(&sys_clk); SysTick_Config(sys_clk.SYSCLK_Frequency / 1000); NVIC_SetPriority(SysTick_IRQn, 0); #endif // peripheral init; GPIO_InitTypeDef gpio_init; // led PB15-LED1,PB14-LED2 gpio_init.GPIO_Mode = GPIO_Mode_Out_PP; gpio_init.GPIO_Speed = GPIO_Speed_High; gpio_init.GPIO_Pin = GPIO_Pin_15; GPIO_Init(GPIOB, &gpio_init); gpio_init.GPIO_Pin = GPIO_Pin_14; GPIO_Init(GPIOB, &gpio_init); // btn PB0-K1,PB1-K2 gpio_init.GPIO_Mode = GPIO_Mode_IPU; gpio_init.GPIO_Pin = GPIO_Pin_0; GPIO_Init(GPIOB, &gpio_init); gpio_init.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOB, &gpio_init); // uart PA2-TX,PA3-RX gpio_init.GPIO_Mode = GPIO_Mode_AF_PP; gpio_init.GPIO_Pin = GPIO_Pin_2; GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_7); GPIO_Init(GPIOA, &gpio_init); gpio_init.GPIO_Mode = GPIO_Mode_IPU; gpio_init.GPIO_Pin = GPIO_Pin_3; GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_7); GPIO_Init(GPIOA, &gpio_init); UART_InitTypeDef UART_InitStruct; UART_StructInit(&UART_InitStruct); UART_InitStruct.BaudRate = CFG_BOARD_UART_BAUDRATE; UART_InitStruct.WordLength = UART_WordLength_8b; UART_InitStruct.StopBits = UART_StopBits_1; UART_InitStruct.Parity = UART_Parity_No; UART_InitStruct.HWFlowControl = UART_HWFlowControl_None; UART_InitStruct.Mode = UART_Mode_Tx | UART_Mode_Rx; UART_Init(UART2, &UART_InitStruct); UART_Cmd(UART2, ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_USB_FS, ENABLE); } // Turn LED on or off void board_led_write(bool state) { if (state) { GPIOB->BRR = 1 << 14; GPIOB->BRR = 1 << 15; } else { GPIOB->BSRR = 1 << 14; GPIOB->BSRR = 1 << 15; }; } // Control led pattern using phase duration in ms. // For each phase, LED is toggle then repeated, board_led_task() is required to be called //void board_led_pattern(uint32_t const phase_ms[], uint8_t count); // Get the current state of button // a '1' means active (pressed), a '0' means inactive. uint32_t board_button_read(void) { if (!(GPIOB->IDR & (1 << 0)) | !(GPIOB->IDR & (1 << 1)) ) { return 1; } else { return 0; } } // Get characters from UART. Return number of read bytes int board_uart_read(uint8_t *buf, int len) { if (UART2->CSR & UART_CSR_RXAVL_Msk) { buf[0] = UART2->RDR; return 1; } else { return 0; } } // Send characters to UART. Return number of sent bytes int board_uart_write(void const *buf, int len) { for (int i = 0; i < len; i++) { putchar(((char*)(buf))[i]); } return len; } #if CFG_TUSB_OS == OPT_OS_NONE volatile static uint32_t systime = 0; // Get current milliseconds, must be implemented when no RTOS is used uint32_t board_millis(void) { return systime; } void SysTick_Handler(void) { systime++; } #endif // stdio getchar() is blocking, this is non-blocking version int board_getchar(void) { if (UART2->CSR & UART_CSR_RXAVL_Msk) { return UART2->RDR; } else { return 0; } } int fputc(int ch, FILE *f) { UART2->TDR = ch; while (UART2->CSR & UART_CSR_TXFULL_Msk) {} return (ch); } int fgetc(FILE* file) { int ch; while((ch = board_getchar()) != 0) {} return ch; } \u9700\u8981\u6ce8\u610f\u7684\u662f\u63d0\u4f9b\u8fc7\u7ed9 USB \u6a21\u5757\u7684\u8fd9\u4e2a 48MHz \u65f6\u949f\u53ef\u4ee5\u6765\u81ea\u4e8ePLL1 \u7684 N \u5206\u9891\uff0cPLL2 \u7684 N \u5206\u9891\uff0c\u90e8\u5206 MCU \u53ef\u80fd\u8fd8\u6709\u5176\u4ed6\u7684\u9009\u62e9\u3002\u8fd9\u4e2a 48MHz \u65f6\u949f\u9700\u8981\u5c3d\u53ef\u80fd\u7cbe\u786e\uff0c\u5982\u6709\u5fc5\u8981\uff0c\u5411 MCU \u63d0\u4f9b\u65f6\u949f\u7684\u5916\u90e8\u6676\u632f\u90fd\u53ef\u4ee5\u6362\u6210 12.000MHz \uff08\u6ce8\u610f\u5c0f\u6570\u70b9\u540e\u9762\u67093\u4e2a0\uff09\u7684\u6676\u632f\uff0c\u4ee5\u4fdd\u8bc1 48MHz \u8db3\u591f\u7cbe\u786e\u3002 \u914d\u7f6eUSB Device\u63a5\u53e3 USB Device\u79fb\u690d\u63a5\u53e3\u5728 tud_dcd_port.c \u6587\u4ef6\u4e2d\u5b9e\u73b0\uff0c\u4e3b\u8981\u5206\u4e3a\u5982\u4e0b\u90e8\u5206\uff1a SETUP \u5305\u7684\u63a5\u6536 \u8bbe\u7f6e\u5730\u5740 \u63a5\u53e3\u9002\u914d \u4e2d\u65ad\u5904\u7406 \u5b9a\u4e49\u5168\u5c40\u53d8\u91cf \u4e3a\u4e86\u9002\u914d TinyUSB Device\uff0c\u5728\u9002\u914d\u5c42\u4e00\u5171\u8bbe\u7f6e\u5982\u4e0b\u5168\u5c40\u53d8\u91cf\uff1a /* OTG_FS BufferDescriptorTable Buffer. */ static __ALIGNED(512u) USB_BufDespTable_Type usb_bd_tbl = {0u}; /*usb_bufdesp_table */ static uint8_t usb_ep0_buf[CFG_TUD_ENDPOINT0_SIZE] = {0u}; /*usb_recv_buff. */ static uint8_t usb_setup_buf[8u] = {0u}; /* usb_setup_buff. */ static uint8_t usb_device_addr = 0u; /* usb_device_addr. */ typedef struct { uint8_t * xfer_buf; uint32_t max_packet_size; /* EndPoint max packet size. */ uint32_t length; /* EndPoint xfer data length. */ uint32_t remaining; /* EndPoint xfer data remaining. */ bool odd_even; /* EndPoint BD OddEven status. */ bool data_n; /* next packet is DATA0 or DATA1. */ bool xfer_done; } USB_EndPointManage_Type; static USB_EndPointManage_Type usb_epmng_tbl[16u][2u] = {0u}; /* EndPointManage Table. */ \u5728 tud_dcd_port.c \u6587\u4ef6\u4e2d\u5b9a\u4e49USB \u6570\u636e\u7f13\u51b2\u533a\uff08\u5728USB\u9a71\u52a8\u4e2d\u5b9a\u4e49USB_BufDespTable_Type\u7ed3\u6784\u4f53\u7c7b\u578b\uff09\uff0c\u5e76\u5728USB\u9a71\u52a8\u521d\u59cb\u5316\u548cUSB\u534f\u8bae\u6808\u4efb\u52a1\u5904\u7406\u65f6\u4f7f\u7528\u3002 static __ALIGNED(512u) USB_BufDespTable_Type usb_bd_tbl = {0u}; /* usb_bufdesp_table */ USB \u7aef\u70b9\u7ba1\u7406 \u5728 tud_dcd_port.c \u6587\u4ef6\u4e2d\u5b9a\u4e49 USB_EndPointManage_Type \u7ed3\u6784\u4f53\u7c7b\u578b\u3002 typedef struct { uint8_t * xfer_buf; uint32_t max_packet_size; /* EndPoint max packet size. */ uint32_t length; /* EndPoint xfer data length. */ uint32_t remaining; /* EndPoint xfer data remaining. */ bool odd_even; /* EndPoint BD OddEven status. */ bool data_n; /* next packet is DATA0 or DATA1. */ bool xfer_done; } USB_EndPointManage_Type; USB \u9a71\u52a8\u4f7f\u80fd \u5728 tud_dcd_port.c \u4e2d\u7684 dcd_init() \u51fd\u6570\u5b9e\u73b0\u3002 // Initialize controller to device mode void dcd_init (uint8_t rhport) { (void) rhport; USB_Device_Init_Type init = {0u}; init.BufDespTable_Addr = (uint32_t)&usb_bd_tbl; USB_InitDevice(BOARD_USB_PORT, &init); USB_Enable(BOARD_USB_PORT, true); NVIC_ClearPendingIRQ(BOARD_USB_IRQn); } USB Device \u4e2d\u65ad \u5728 tud_dcd_port.c \u4e2d\u7684 dcd_int_enable() \u548c dcd_int_disable() \u51fd\u6570\u5b9e\u73b0 USB Device\u8bbe\u5907\u7684\u4e2d\u65ad\u5f00\u542f\u4e0e\u5173\u95ed\u3002 // Enable device interrupt void dcd_int_enable (uint8_t rhport) { (void) rhport; USB_EnableInterrupts(BOARD_USB_PORT, USB_INT_RESET | USB_INT_TOKENDONE | USB_INT_SLEEP | USB_INT_RESUME | USB_INT_STALL | USB_INT_SOFTOK, true); /* enable interrupts*/ NVIC_SetPriority(BOARD_USB_IRQn, 3u); NVIC_EnableIRQ(BOARD_USB_IRQn); } \u5e76\u5728 tud_dcd_port.c \u4e2d\u7684 dcd_int_handler() \u51fd\u6570\u5b9e\u73b0 USB Device \u8bbe\u5907\u7684\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u3002 // Interrupt Handler void dcd_int_handler(uint8_t rhport) { uint32_t flag = USB_GetInterruptStatus(BOARD_USB_PORT); if (flag & USB_INT_TOKENDONE) { USB_TokenDoneHandler(rhport); return; } if (flag & USB_INT_RESET) { USB_ClearInterruptStatus(BOARD_USB_PORT, USB_INT_RESET); USB_BusResetHandler(); dcd_event_bus_reset(rhport, TUSB_SPEED_FULL, true); } if (flag & USB_INT_SLEEP) { USB_ClearInterruptStatus(BOARD_USB_PORT, USB_INT_SLEEP); dcd_event_bus_signal(rhport, DCD_EVENT_SUSPEND, true); } if (flag & USB_INT_RESUME) { USB_ClearInterruptStatus(BOARD_USB_PORT, USB_INT_RESUME); dcd_event_bus_signal(rhport, DCD_EVENT_RESUME, true); } if (flag & USB_INT_STALL) { USB_EnableEndPointStall(BOARD_USB_PORT, USB_EP_0, false); dcd_edpt_clear_stall(rhport, 0); USB_BufDesp_Xfer(&usb_bd_tbl.Table[0u][USB_Direction_OUT][usb_epmng_tbl[0u][USB_Direction_OUT].odd_even], 1, usb_ep0_buffer, 64); USB_ClearInterruptStatus(BOARD_USB_PORT, USB_INT_STALL); } if (flag & USB_INT_SOFTOK) { USB_ClearInterruptStatus(BOARD_USB_PORT, USB_INT_SOFTOK); } } /* USB IRQ. */ void BOARD_USB_IRQHandler(void) { dcd_int_handler(BOARD_TUD_RHPORT); } \u914d\u7f6eUSB Host\u63a5\u53e3 MM32G5330 USB \u652f\u6301 Host \u529f\u80fd\uff0cTinyUSB \u534f\u8bae\u6808\u4e2d\u4e5f\u5305\u542b\u4e86 Host \u90e8\u5206\uff0c\u5728\u9002\u914d Host \u8fc7\u7a0b\u4e2d\uff0c\u4f7f\u7528\u5230\u4e86\u53cc\u5411\u961f\u5217\u548c\u6570\u636e\u5e93\u7684\u6982\u5ff5\u3002USB Host\u79fb\u690d\u63a5\u53e3\u5728 tuh_dcd_port.c \u6587\u4ef6\u4e2d\u5b9e\u73b0\uff0c\u4e3b\u8981\u5206\u4e3a\u5982\u4e0b\u6b65\u9aa4\uff1a \u53cc\u5411\u961f\u5217\u5b9e\u73b0 \u6570\u636e\u5e93\u5b9e\u73b0 \u63a5\u53e3\u5b9e\u73b0 \u4e2d\u65ad\u5904\u7406 \u53cc\u5411\u961f\u5217\u5b9e\u73b0 USB \u603b\u7ebf\u4f1a\u50cf\u591a\u4e2a\u7aef\u70b9\u4f20\u8f93\u4e0d\u540c\u7684\u5185\u5bb9\uff0c\u4f46 USB \u603b\u7ebf\u53ea\u6709\u4e00\u6761\uff0c\u56e0\u6b64\u9700\u8981\u5c06\u4f20\u8f93\u4efb\u52a1\u653e\u5728\u4e00\u4e2a\u961f\u5217\u4e2d\uff0c\u6309\u7167\u961f\u5217\u7684\u987a\u5e8f\u4f20\u8f93\u6570\u636e \uff1b\u5728\u4f20\u8f93\u8fc7\u7a0b\u4e2d\uff0c\u53ef\u80fd\u4f1a\u6709\u5206\u6bb5\u4f20\u8f93\uff0c\u4f20\u8f93\u5931\u8d25\u7b49\u60c5\u51b5\uff0c\u53ef\u80fd\u8981\u5c06\u4f20\u8f93\u4efb\u52a1\u91cd\u65b0\u653e\u5728\u961f\u5217\u7684\u5934\u90e8\uff0c\u800c\u4e0d\u662f\u672b\u5c3e\uff0c\u56e0\u6b64\uff0c\u8fd9\u4e2a\u961f\u5217\u4e0d\u4ec5\u80fd\u5c06\u4f20\u8f93\u4efb\u52a1\u653e\u5728\u961f\u5217\u5c3e\u90e8\uff0c\u4e5f\u80fd\u5c06\u4f20\u8f93\u4efb\u52a1\u653e\u5728\u5934\u90e8\uff0c\u5c31\u50cf\u5806\u6808\u90a3\u6837\uff0c\u56e0\u6b64\uff0c\u9700\u8981\u5b9e\u73b0\u4e00\u4e2a\u53cc\u5411\u961f\u5217\u3002\u540c\u666e\u901a\u7684\u961f\u5217\u4e00\u6837\uff0c\u53cc\u5411\u961f\u5217\u9700\u8981\u4e00\u4e2a\u961f\u5217buffer\uff0c\u4ee5\u53ca\u7ba1\u7406\u961f\u5217 buffer \u7684\u5b57\u6bb5\uff0c\u7136\u540e\u6bcf\u6b21\u8bfb\u5199\u961f\u5217\u65f6\uff0c\u4e0d\u80fd\u76f4\u63a5\u64cd\u4f5c\u8fd9\u4e2a buffer\uff0c\u800c\u662f\u53ea\u80fd\u4f7f\u7528\u7ed9\u5b9a\u7684 push \u548c pop \u65b9\u6cd5\u64cd\u4f5c\u3002\u5b9e\u73b0\u64cd\u4f5c\u5982\u4e0b\uff1a buffer \u548c\u7ba1\u7406\u5b57\u6bb5\uff1a /* xfer task deque node. */ typedef struct { ...... } xfer_task_node_t; /* xfer task deque support. */ static xfer_task_node_t xfer_task_deque[TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE] ={0u}; /* xfer task deque buf. */ static uint32_t xfer_task_head = 0u; /* record deque head. */ static uint32_t xfer_task_tail = 0u; /* record deque tail. */ static uint32_t xfer_task_cnt = 0u; /* record xfer task num. */ \u64cd\u4f5c\u51fd\u6570\uff1a \u4ece\u5934\u90e8 pop\uff0c\u4ece\u5c3e\u90e8 push\uff1a /* get deque head node & delete the node in deque. */ bool xfer_task_pop_head(xfer_task_node_t * task) { if (0u == xfer_task_cnt) { return false; /* no xfer_task. */ } /* pop head: read head, head--, cnt--. */ memcpy(task, &xfer_task_deque[xfer_task_head], sizeof(xfer_task_node_t)); /* read head. */ if (xfer_task_head == 0u) /* head--. */ { xfer_task_head = TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE - 1u; } else { xfer_task_head--; } xfer_task_cnt--; /* cnt--. */ return true; } /* put node in deque tail. */ bool xfer_task_push_tail(xfer_task_node_t * task) { if (TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE == xfer_task_cnt) { return false; /* queue full. */ } /* push tail: write tail, tail--, cnt++ */ memcpy(&xfer_task_deque[xfer_task_tail], task, sizeof(xfer_task_node_t)); /* write tail. */ if (xfer_task_tail == 0u) /* head++. */ { xfer_task_tail = TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE - 1u; } else { xfer_task_tail--; } xfer_task_cnt++;/* cnt++. */ return true; } \u6709\u4e86\u4e0a\u9762\u7684\u4e24\u4e2a\u65b9\u6cd5\uff0c\u8fd9\u5c31\u662f\u4e00\u4e2a\u666e\u901a\u7684\u5355\u9879\u961f\u5217\uff0c\u82f1\u6587\u53eb\u505a queue\uff0c\u65e2\u7136\u662f\u53cc\u5411\u961f\u5217\uff0c\u5c31\u9700\u8981\u5728\u8fd9\u4e2a\u57fa\u7840\u4e0a\u5b9e\u73b0\u4ece\u5934\u90e8 push \u7684\u529f\u80fd\uff0c\u81f3\u4e8e\u5c3e\u90e8 pop \u7531\u4e8e\u5728\u9002\u914d\u8fc7\u7a0b\u4e2d\u6ca1\u6709\u4f7f\u7528\uff0c\u4e0d\u518d\u5b9e\u73b0\uff0c\u4e0b\u8ff0\u4e3a\u76f8\u5173\u4ee3\u7801\u5b9e\u73b0\uff1a /* put node in deque head. */ bool xfer_task_push_head(xfer_task_node_t * task) { if (TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE == xfer_task_cnt) { return false; /* queue full. */ } /* push head: head++, write head, cnt++ */ if (xfer_task_head == TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE - 1u) /* head++. */ { xfer_task_head = 0u; } else { xfer_task_head++; } memcpy(&xfer_task_deque[xfer_task_head], task, sizeof(xfer_task_node_t)); /* write tail. */ xfer_task_cnt++;/* cnt++. */ return true; } \u9700\u8981\u6e05\u7a7a\u53cc\u5411\u961f\u5217\u7684\u5185\u5bb9\u65f6\uff0c\u6216\u521d\u59cb\u5316\u53cc\u5411\u961f\u5217\u65f6\uff0c\u53ef\u4f7f\u7528\u4e0b\u5217\u65b9\u6cd5\u64cd\u4f5c: /* reset the deque, delete all node. */ void xfer_task_reset(void) { xfer_task_head = 0u; xfer_task_tail = 0u; xfer_task_cnt = 0u; } \u6570\u636e\u5e93\u5b9e\u73b0 \u6240\u8c13\u6570\u636e\u5e93\uff0c\u53ea\u662f\u7528\u4e8e\u5b58\u653e\u5404\u8bbe\u5907\u5404\u7aef\u70b9\u4fe1\u606f\u7684\u5730\u65b9\u3002\u6bcf\u6b21\u53d1\u9001\u4f20\u8f93\u6570\u636e\u7684\u65f6\u5019\uff0c\u9700\u8981\u77e5\u9053\u7aef\u70b9\u7684buffer \u5927\u5c0f\u7b49\u4fe1\u606f\uff0c\u6240\u4ee5\u9700\u8981\u5728\u6570\u636e\u5e93\u4e2d\u67e5\u8be2\u7aef\u70b9\u4fe1\u606f\u3002\u9700\u8981\u652f\u6301inset\u64cd\u4f5c\uff0cdelete\u64cd\u4f5c\uff0cupdate \u64cd\u4f5c\u548cselect\u64cd\u4f5c\uff0c\u5373\u589e\u5220\u6539\u67e5\uff1a insert \u64cd\u4f5c\uff0c\u6307\u5c06\u4e00\u6761\u6570\u636e\u6761\u76ee\u63d2\u5165\u5230\u6570\u636e\u8868\u4e2d\uff0c\u8be5\u6761\u76ee\u662f\u6570\u636e\u8868\u4e2d\u539f\u6765\u6ca1\u6709\u7684\u5185\u5bb9 delete \u64cd\u4f5c\uff0c\u6307\u5220\u9664\u6570\u636e\u6761\u76ee\u6216\u6570\u636e\u8868 update \u64cd\u4f5c\uff0c\u6307\u5c06\u4e00\u6761\u6570\u636e\u6761\u76ee\u66f4\u65b0\u5230\u539f\u6709\u7684\u6761\u76ee\u4e2d\uff0c\u4e3b\u8981\u66f4\u65b0\u539f\u6709\u6761\u76ee\u7684\u5b57\u6bb5\u5185\u5bb9 select \u64cd\u4f5c\uff0c\u6839\u636e\u5173\u952e\u5b57\u67e5\u627e\u6570\u636e\u8868\u4e2d\u7684\u6761\u76ee buffer \u548c\u7ba1\u7406\u5b57\u6bb5\uff1a /* endpoint status table. */ static ep_status_t ep_tbl[TUH_HCD_PORT_MAX_EP_NUM]; /* the table that record the ep_status. */ static uint32_t ep_count = 0u; /* record the how many endpoint status in ep_tbl[]. */ insert & update \u64cd\u4f5c\uff1a /* add new or modify endpoint status. */ bool ep_set_status(ep_status_t * status) { ep_status_t * ep_status = ep_get_status(status->dev_ep_addr); if (NULL == ep_status) { if (ep_count == TUH_HCD_PORT_MAX_EP_NUM) { return false; } ep_status = &ep_tbl[ep_count]; ep_count++; } memcpy(ep_status, status, sizeof(ep_status_t)); return true; } select \u64cd\u4f5c\uff1a /* get endpoint status. */ ep_status_t * ep_get_status(uint32_t dev_ep_addr) { ep_status_t * ep_status = NULL; for(uint32_t i = 0u; i < ep_count; i++) { if(dev_ep_addr == ep_tbl[i].dev_ep_addr) { ep_status = &ep_tbl[i]; break; } } return ep_status; } \u9664\u4e86\u4e0a\u9762\u7684\u64cd\u4f5c\uff0c\u5f53 USB Device \u62d4\u6389\u7684\u65f6\u5019\uff0c\u6570\u636e\u5e93\u9700\u8981\u8fdb\u884c\u590d\u4f4d\uff0c\u76f8\u5f53\u4e8e\u6267\u884c delete \u64cd\u4f5c\uff1a /* clear all endpoint status. */ void ep_reset(void) { ep_count = 0u; } USB \u7f13\u51b2\u63cf\u8ff0\u8868\u5b9a\u4e49 \u5728 tuh_dcd_port.c \u6587\u4ef6\u4e2d\u5b9a\u4e49USB \u6570\u636e\u7f13\u51b2\u533a\uff08\u5728USB\u9a71\u52a8\u4e2d\u5b9a\u4e49USB_BufDespTable_Type\u7ed3\u6784\u4f53\u7c7b\u578b\uff09\uff0c\u5728USB\u9a71\u52a8\u521d\u59cb\u5316\u548cUSB\u534f\u8bae\u6808\u4efb\u52a1\u5904\u7406\u65f6\u4f7f\u7528\u3002 USB\u7684\u914d\u7f6e\u7531\u4e24\u90e8\u5206\u7ec4\u6210\uff1a\u4e00\u90e8\u5206\u662f\u5b9e\u5b9e\u5728\u5728\u7684 USB \u5bc4\u5b58\u5668\u914d\u7f6e\uff0c\u4e00\u90e8\u5206\u662f SRAM \u4ee5 512 \u5b57\u8282\u5bf9\u9f50\u7684 512 \u5b57\u8282\u5927\u5c0f\u7684\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u3002 \u90a3\u4e48\u5982\u4f55\u5f97\u5230\u4e00\u5757 512 Bytes \u5bf9\u9f50\u7684\u5185\u5b58\uff1f\u8fd9\u91cc\u4e3e\u51fa\u4e09\u79cd\u65b9\u6cd5\uff1a \u5728 linker \u4e2d\u58f0\u660e\u51fa\u4e00\u6bb5 512 \u5b57\u8282\u5bf9\u9f50\u7684 512 \u5b57\u8282\u5927\u5c0f\u7684\u7a7a\u95f4\u3002 \u4f7f\u7528 \"__ALIGNED(512)\" \u6216 \"__attribute__((__aligned__(512)))\" \u7b49\u6307\u4ee4\u8ba9\u7f16\u8bd1\u5668\u5904\u7406\u3002 \u58f0\u660e\u4e00\u6bb5 1K \u5927\u5c0f\u7684\u7a7a\u95f4\uff0c\u7136\u540e\u5728\u5176\u4e2d\u627e\u5230 512 \u5b57\u8282\u5bf9\u9f50\u7684\u4f4d\u7f6e\u3002 \u8fd9\u91cc\u6211\u4eec\u91c7\u7528\u4e86\u7b2c2\u79cd\u65b9\u6cd5\u8fdb\u884c\u4e86\u5b9e\u73b0\uff1a /* usb buf descriptor table. */ __attribute__ ((aligned(512))) static USB_BufDespTable_Type usb_bdt = {0u}; /* speed status. */ volatile static tusb_speed_t device_speed = TUSB_SPEED_FULL; /* xfer_buf. */ __attribute__ ((aligned(4))) static uint8_t usb_xfer_buf[TUH_HCD_PORT_XFER_BUF_SIZE] = {0u}; \u5728\u521d\u59cb\u5316 USB \u7684\u65f6\u5019\uff0c\u9700\u8981\u5c06\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u7684\u8d77\u59cb\u5730\u5740\u5199\u5165\u5230 USB \u5bc4\u5b58\u5668\u4e2d\uff08USB_FS_BDTPAGE1\uff0cUSB_FS_BDTPAGE2\uff0cUSB_FS_BDTPAGE3\uff09\uff0c\u968f\u540e\uff0c\u8fd9\u5757\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u5c31 \u201c\u6210\u4e3a\u201d \u4e86 USB \u5bc4\u5b58\u5668\u4e2d\u7684\u4e00\u90e8\u5206\uff0c\u5f53\u6211\u4eec\u60f3\u8981\u4f20\u8f93\u6570\u636e\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u628a\u8981\u4f20\u8f93\u6570\u636e\u7684\u7f13\u51b2\u533a\u5730\u5740\uff0c\u7f13\u51b2\u533a\u5927\u5c0f\u7b49\u4fe1\u606f\u5199\u5165\u5230\u8fd9\u4e2a\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u4e2d\uff0c\u5f85\u4f20\u8f93\u6570\u636e\u5b8c\u6210\u540e\uff0c\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u4e2d\u8bb0\u5f55\u7684\u5185\u5bb9\u4e5f\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u5bf9\u8fd9\u5757\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u7684\u64cd\u4f5c\uff0c\u5c31\u5982\u540c\u5728 USB \u5bc4\u5b58\u5668\u4e0a\u8fdb\u884c\u64cd\u4f5c\u4e00\u822c\u3002 USB \u6570\u636e\u7684\u4f20\u8f93\u5b9e\u9645\u4e0a\u662f\u4f9d\u9760 DMA \u642c\u8fd0\u5b9e\u73b0\u7684\uff0c\u4f46\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0cUSB \u4f7f\u7528\u7684 DMA \u5e76\u4e0d\u662f MCU \u4e2d\u7684 DMA \u5916\u8bbe\uff0c\u800c\u662f USB \u81ea\u5e26\u7684 DMA\uff0c\u5e76\u4e14\u9664\u4e86\u4f7f\u7528 USB \u81ea\u5e26\u7684 DMA \u642c\u8fd0\u7684\u65b9\u5f0f\u4f20\u8f93\u6570\u636e\u5916\uff0cUSB \u5e76\u6ca1\u6709\u63d0\u4f9b\u5176\u4ed6\u4f20\u8f93\u6570\u636e\u7684\u65b9\u6cd5\u3002\u7531\u4e8e\u91c7\u7528 DMA \u642c\u8fd0\u7684\u65b9\u6cd5\u4f20\u8f93\u6570\u636e\uff0c\u5728\u4f7f\u7528 USB \u529f\u80fd\u7684\u65f6\u5019\uff0c\u9700\u8981\u6ce8\u610f\u4e00\u4e9b\u4f1a\u5f71\u54cd DMA \u5de5\u4f5c\u7684\u5730\u65b9\uff1a\u4f8b\u5982\uff0c\u6253\u5f00 DCACHE \u540e\uff0c\u5bf9 SRAM \u7684\u8bbf\u95ee\u5e76\u975e\u76f4\u63a5\u5199\u5165\u5230 SRAM \u4e2d\uff0c\u800c\u662f\u5148\u6682\u65f6\u653e\u5165\u5230\u5185\u6838\u7684 CACHE \u4e2d\uff0c\u4f1a\u9020\u6210 DMA \u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c\uff0c\u6240\u4ee5\uff0c\u5728\u4f7f\u7528 USB \u529f\u80fd\u7684\u65f6\u5019\uff0c\u5e94\u5173\u95ed DCACHE \u529f\u80fd\uff08\u6216\u8005\u4f7f\u7528 MPU \u5bf9 USB \u4f7f\u7528\u5230\u7684\u5185\u5b58\u52a0\u4ee5\u4fdd\u62a4\uff09\uff1b\u518d\u4f8b\u5982\uff0c\u6709\u4e9b RAM \u4ec5\u80fd\u88ab CPU \u8bbf\u95ee\uff0c\u5982 DTCM\uff0c\u8fd9\u90e8\u5206\u7a7a\u95f4\u65e0\u6cd5\u8ba9 DMA \u6b63\u5e38\u5de5\u4f5c\uff0c\u56e0\u6b64\u4e5f\u8981\u907f\u514d\u5c06\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u548c\u8981\u4f20\u8f93\u7684\u6570\u636e\u5b58\u653e\u5728\u6b64\u7c7b\u533a\u57df\u3002 \u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u63a7\u5236\u7740\u5341\u516d\u4e2a\u7aef\u70b9\u7684\u4f20\u8f93\u529f\u80fd\uff0c\u6bcf\u4e2a\u7aef\u70b9\u6709\u4e24\u4e2a\u4f20\u8f93\u65b9\u5411\uff0c\u5206\u522b\u662f IN \u548c OUT\uff08\u5982\u679c\u6bcf\u4e2a\u4f20\u8f93\u65b9\u5411\u7b97\u4e00\u4e2a\u7aef\u70b9\u7684\u8bdd\uff0cUSB_0 \u4e00\u5171\u6709 32 \u4e2a\u7aef\u70b9\uff09\u6bcf\u4e2a\u4f20\u8f93\u65b9\u5411\u6709\u4e24\u4e2a\u7f13\u51b2\u533a\u63cf\u8ff0\u7b26\u7ec4\u6210\uff0c\u5728\u4f20\u8f93\u6570\u636e\u7684\u65f6\u5019\uff0c\u4e24\u4e2a\u7f13\u51b2\u533a\u63cf\u8ff0\u7b26\u4ea4\u66ff\u5de5\u4f5c\uff0c\u4ece\u800c\u5b9e\u73b0\u4e52\u4e53\u64cd\u4f5c\u7684\u8fc7\u7a0b\uff0c\u52a0\u5feb\u6570\u636e\u4f20\u8f93\u7684\u901f\u5ea6\u3002\u5f53\u7136\uff0c\u53cc\u7f13\u51b2\u7684\u64cd\u4f5c\u8f83\u4e3a\u590d\u6742\uff0c\u589e\u52a0\u4e86 USB \u7684\u64cd\u4f5c\u96be\u5ea6\uff0c\u53cc\u7f13\u51b2\u4e5f\u53ef\u914d\u7f6e\u4e3a\u5355\u7f13\u51b2\uff0c\u7b80\u5316\u4f7f\u7528\u65b9\u6cd5\u3002 \u56fex \u7f13\u51b2\u533a\u63cf\u8ff0\u7b26 \u5982\u56fex\u6240\u793a\uff0c\u6bcf\u4e2a\u7f13\u51b2\u533a\u63cf\u8ff0\u7b26\u7531\u4e24\u4e2a\u56db\u5b57\u8282\u6570\u636e\u7ec4\u6210\uff0c\u7b2c\u4e00\u4e2a\u56db\u5b57\u8282\u6570\u636e\u8bb0\u5f55\u4e86\u8981\u4f20\u8f93\u6570\u636e\u7684\u5927\u5c0f\uff0cdata toggle\uff0c\u7f13\u51b2\u533a\u63cf\u8ff0\u7b26\u7684\u62e5\u6709\u8005\u7b49\u5b57\u6bb5\u4fe1\u606f\uff0c\u7b2c\u4e8c\u4e2a\u56db\u5b57\u8282\u6570\u636e\u5219\u8bb0\u5f55\u4e86\u8981\u4f20\u8f93\u6570\u636e\u7684\u8d77\u59cb\u4f4d\u7f6e\u3002\u5177\u4f53\u7684\u5b57\u6bb5\u4fe1\u606f\uff0c\u53ef\u53c2\u8003\u5404 MCU \u7684 UM\u3002 USB \u7aef\u70b9\u7ba1\u7406 \u5728 tud_dcd_port.c \u6587\u4ef6\u4e2d\u5b9a\u4e49 USB_EndPointManage_Type \u7ed3\u6784\u4f53\u7c7b\u578b\u3002 typedef struct { uint8_t * xfer_buf; uint32_t max_packet_size; /* EndPoint max packet size. */ uint32_t length; /* EndPoint xfer data length. */ uint32_t remaining; /* EndPoint xfer data remaining. */ bool odd_even; /* EndPoint BD OddEven status. */ bool data_n; /* next packet is DATA0 or DATA1. */ bool xfer_done; } USB_EndPointManage_Type; USB\u9a71\u52a8\u4f7f\u80fd \u5728 tuh_dcd_port.c \u4e2d\u7684 dcd_init() \u51fd\u6570\u5b9e\u73b0\u3002 /* Initialize controller to host mode. */ bool hcd_init(uint8_t rhport) { (void)rhport; /* init usb host module. */ USB_Host_Init_Type usb_init; usb_init.BufDespTable_Addr = (uint32_t)(&usb_bdt); usb_init.SofThreshold = BOARD_USB_SOFTHRESHOLD; usb_init.NakRetry = false; USB_InitHost(BOARD_USB_PORT, &usb_init); USB_EnableOddEvenReset(BOARD_USB_PORT, true); /* only use even buf desp, this example will not usb odd buf desp xfer data. */ USB_SetDeviceAddr(BOARD_USB_PORT, 0x00); /* set usb addr is 0x00, to xfer data when device attached. */ /* enable interrupt, but not use NVIC_EnableIRQ(). */ NVIC_ClearPendingIRQ(BOARD_USB_IRQn); USB_EnableInterrupts(BOARD_USB_PORT, USB_INT_ATTACH | USB_INT_ERROR, true); USB_EnableErrInterrupts(BOARD_USB_PORT, 0xFF, true); return true; } USB Host\u4e2d\u65ad USB Host \u4e2d\u65ad\u7684\u4f7f\u80fd\u5728 tuh_dcd_port.c \u4e2d\u7684 hcd_init() \u51fd\u6570\u4e2d\u5df2\u7ecf\u5b9e\u73b0\u3002\u76f8\u8f83\u4e8e USB Device \u4e2d\u65ad\u7684\u4f7f\u80fd\uff0cUSB Host \u4e2d\u65ad\u53ea\u5f00\u542f\u4e86 USB_INT_ATTACH \u4e2d\u65ad\u548c USB_INT_ERROR \u4e2d\u65ad\u3002\u5728 tud_dcd_port.c \u4e2d\u7684 BOARD_USB_IRQHandler() \u51fd\u6570\u5b9e\u73b0 USB Host \u8bbe\u5907\u7684\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u3002 /* * USB interrupt handler. */ void BOARD_USB_IRQHandler(void) { uint32_t flag = USB_GetInterruptStatus(BOARD_USB_PORT); flag &= USB_GetEnabledInterrupts(BOARD_USB_PORT); /* device attached. */ if (0u != (flag & USB_INT_ATTACH)) { process_attach(); } /* sof token, prepare to xfer packet. */ if (0u != (flag & USB_INT_SOFTOK)) { process_softok(); } /* xfer a token done. */ if (0u != (flag & USB_INT_TOKENDONE)) { process_token_done(); } /* device detached. */ if (0u != (flag & USB_INT_RESET)) { tuh_task(); /* clear all event. */ process_detach(); /* do detache process. */ } if (0u != (flag & USB_INT_ERROR)) { tuh_task(); /* clear all event. */ process_detach(); /* do detache process. */ uint32_t err = USB_GetErrInterruptStatus(BOARD_USB_PORT); USB_ClearErrInterruptStatus(BOARD_USB_PORT, err); /* clear err interrut. */ } USB_ClearInterruptStatus(BOARD_USB_PORT, flag); } \u521b\u5efa\u5de5\u7a0b\u6837\u4f8b \u5728\u76ee\u6807\u5de5\u7a0b\u7684 examples \u6587\u4ef6\u5939\u4e0b\u65b0\u5efa tud_cdc_msc \u6587\u4ef6\u5939\uff0c\u5c06 cdc_msc\\src \u6587\u4ef6\u5939\u4e2d\u7684\u6837\u4f8b\u6e90\u7801 main.c \u3001 msc_disk.c \u3001 tusb_config.h \u548c usb_descriptors.c \u62f7\u8d1d\u5230\u76ee\u6807\u5de5\u7a0b\u4e2d\u7684 examples\\tud_cdc_msc \u6587\u4ef6\u5939\u4e2d\uff0c\u5982\u56fex\u6240\u793a\uff1b\u5728\u8be5\u6587\u4ef6\u5939\u4e0b\u6839\u636e\u5bf9\u5e94\u5de5\u5177\u94fe\u65b0\u5efa\u6587\u4ef6\u5939\u548c\u521b\u5efa\u5bf9\u5e94\u7684\u7f16\u8bd1\u914d\u7f6e\u5de5\u7a0b\uff0c\u4e0b\u56fex\u5c55\u793a\u4e86\u4ee5Keil MDK \u5de5\u5177\u94fe\u4e3a\u4f8b\u7684\u5de5\u7a0b\u6a21\u677f\u3002 \u56fex \u6837\u4f8b\u6587\u4ef6\u7ed3\u6784 \u56fex Keil MDK \u5de5\u7a0b\u6837\u4f8b \u5bf9\u4e8e\u5de5\u7a0b\u4e2d\u7684\u5168\u5c40\u5b8f\u7684\u914d\u7f6e\u5982\u4e0b\u56fex\u6240\u793a\u3002\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e14\u6211\u4eec\u4f7f\u7528\u5230\u4e86\u677f\u8f7d\u7684 12.000MHz \u9ad8\u7cbe\u5ea6\u5916\u90e8\u9ad8\u901f\u6676\u632f\uff0c\u9700\u8981\u5728\u5de5\u7a0b\u914d\u7f6e\u4e2d\u5b9a\u4e49\u5168\u5c40\u5b8f CUSTOM_HSE_VAL \u3002 \u914d\u7f6e\u5de5\u7a0b\u5168\u5c40\u5b8f\u53c2\u6570 \u6837\u4f8b\u6f14\u793a TinyUSB \u534f\u8bae\u6808\u81ea\u8eab\u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684 USB Device\u6837\u4f8b\u548c USB Host \u6837\u4f8b\uff0c\u6211\u4eec\u53ea\u9700\u8981\u901a\u8fc7\u4f7f\u7528\u914d\u7f6e\u597d\u7684 USB Device\u63a5\u53e3\u548c USB Host \u63a5\u53e3\uff0c\u548c TinyUSB \u534f\u8bae\u6808\u63d0\u4f9b\u534f\u8bae\u6808\u6e90\u6587\u4ef6\u548c\u6837\u4f8b\u4ee3\u7801\uff0c\u6309\u7167\u4e0d\u540c\u7684\u6837\u4f8b\u91cd\u65b0\u5efa\u7acb\u5bf9\u5e94\u7684\u5de5\u7a0b\u4fbf\u53ef\u5b9e\u73b0 TinyUSB \u63d0\u4f9b\u7684USB Device\u6837\u4f8b\u548c USB Host \u6837\u4f8b\u3002 LibTinyUSB \u4e2d\u5df2\u5b9e\u73b0\u591a\u4e2a tinyusb \u7684\u6837\u4f8b\uff0c\u6837\u4f8b\u5168\u90e8\u6765\u81ea tinyusb \u5b98\u65b9\u5b9e\u73b0\u7684\u4ee3\u7801\uff0c\u4f46 LibTinyUSB \u4e2d\u7684 examples \u4e3a\u4e86\u51cf\u5c0f size\uff0c\u5220\u9664\u4e86 examples \u6587\u4ef6\u5939\uff0c\u53ef\u5230 tinyusb \u5b98\u7f51\u62c9\u53d6\u6700\u65b0\u7684 git \u4ed3\u5e93\uff0c\u83b7\u53d6 examples\u3002 \u5c06 examples \u7684\u67d0\u4e00\u4e2a\u6837\u4f8b\u4e2d\u7684\u6e90\u4ee3\u7801\u590d\u5236\uff0c\u66ff\u6362 LibTinyUSB \u6837\u4f8b\u4e2d\u7684 app \u4ee3\u7801\uff0c\u5373\u53ef\u5b9e\u73b0\u65b0\u7684 app \u4ee3\u7801\u3002 \u8fd9\u91cc\u6211\u4eec\u4ecd\u7136\u4ee5\u57fa\u4e8e Mini-F5277-OB \u5f00\u53d1\u677f\u7684 tud_cdc_msc \u6837\u4f8b\u7684 Keil MDK\u5de5\u7a0b\u4e3a\u4f8b\uff0c\u9a8c\u8bc1\u5176\u5b9e\u73b0\u6548\u679c\uff1a \u5728\u5b8c\u6210\u524d\u8ff0\u4ee3\u7801\u79fb\u690d\u548c\u5de5\u7a0b\u914d\u7f6e\u4e4b\u540e\uff0c\u8fdb\u884c\u7f16\u8bd1\u4e0b\u8f7d\uff0c\u8fd9\u91cc\u4e0b\u8f7d\u5668\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 Mini-F5277-OB \u5f00\u53d1\u677f\u677f\u8f7d\u7684 CMSIS-DAP \u4e0b\u8f7d\u5668\uff0c\u7136\u540e\u76f4\u63a5\u8fdb\u884c\u4e0b\u8f7d\u3002 \u56fa\u4ef6\u4e0b\u8f7d\u5b8c\u6210\u540e\u901a\u8fc7 USB \u6570\u636e\u7ebf\u5c06 PC \u7aef\u548c\u5f00\u53d1\u677f\u7684 USB-MCU \u63a5\u53e3\u8fdb\u884c\u8fde\u63a5\uff08\u8fd9\u91cc\u6211\u4eecPC\u7aef\u7528\u5230\u7684\u64cd\u4f5c\u7cfb\u7edf\u662f Win10\uff09\uff0c\u8fde\u63a5\u597d\u540e\u6309\u4e0b\u5f00\u53d1\u677f\u7684\u590d\u4f4d\u6309\u952e\uff0cPC\u7aef\u5c06\u4f1a\u81ea\u52a8\u5f39\u51fa USB Device \u5728PC \u7aef\u679a\u4e3e\u7684\u4e00\u4e2a\u63cf\u8ff0\u7b26\u4e3a TinyUSB MSC \u7684\u53ef\u79fb\u52a8\u78c1\u76d8\u8bbe\u5907\uff0c\u5982\u4e0b\u56fex\u6240\u793a\uff1a \u56fex \u81f3\u6b64\uff0c\u4ee3\u8868\u6837\u4f8b\u5de5\u7a0b tud_cdc_msc \u6210\u529f\u8fd0\u884c\uff0c\u5e76\u5728 PC \u7aef\u5b8c\u6210\u4e86USB Device\u679a\u4e3e\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u5907\u529f\u80fd\u3002 TinyUSB\u534f\u8bae\u6808\u6837\u4f8b\u4ecb\u7ecd board_test \u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684\u57fa\u672c\u677f\u8f7d\u6837\u4f8b\uff0c\u7528\u4e8e\u6d4b\u8bd5\u9a8c\u8bc1MCU\u548c\u5f00\u53d1\u677f\u80fd\u5426\u6b63\u5e38\u8fd0\u884c\uff0c\u82e5\u8fd0\u884c\u6b63\u5e38\u5219\u677f\u8f7dLED\u4f1a\u8fdb\u884c\u95ea\u70c1\uff0c\u5e76\u5728\u4e32\u53e3\u8f93\u51fa\u6307\u5b9a\u5b57\u7b26\u4e32\u3002 tud_cdc_dual_ports \u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device\u53cc\u4e32\u53e3\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u53cc\u4e32\u53e3\u529f\u80fd\u3002 tud_cdc_msc \u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u5907\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u5907\u529f\u80fd\u3002 tud_hid_composite \u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device HID\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u9f20\u6807\u952e\u76d8\u8bbe\u5907\u529f\u80fd\u3002 tud_msc_dual_lun \u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u5907\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u4e24\u4e2a\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u5907\u529f\u80fd\u3002 tud_video_capture \u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device\u6444\u50cf\u5934\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u4e00\u4e2a\u6444\u50cf\u5934\u8bbe\u5907\u529f\u80fd\u3002 tud_webusb_serial \u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device\u7684Vender\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u7f51\u9875USB\u4e32\u53e3\u8bbe\u5907\u529f\u80fd\u3002 tuh_bare_api \u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Host\u7684\u57fa\u672cAPI\u4f7f\u7528\u6f14\u793a\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Host\u8bfb\u53d6FATFS \u683c\u5f0f\u7684\u5b58\u50a8\u8bbe\u5907\uff08\u5982\uff1aU\u76d8\uff09\u529f\u80fd\u3002 tuh_cdc_msc_hid \u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Host\u8bfb\u53d6\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u6f14\u793a\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Host\u8bfb\u53d6FATFS \u683c\u5f0f\u7684\u5b58\u50a8\u8bbe\u5907\uff08\u5982\uff1aU\u76d8\uff09\u529f\u80fd\u3002 tuh_hid_controller \u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Host\u63a7\u5236\u5668\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Host\u8bfb\u53d6\u6e38\u620f\u624b\u67c4\u4fe1\u606f\uff08\u8fd9\u91cc\u6307\u5b9a\u4e86\u7d22\u5c3cPS4\u6e38\u620f\u624b\u67c4\uff09\u529f\u80fd\u3002 \u6ce8\u610f\u4e8b\u9879 USB \u4f7f\u7528 12.000MHz \u9ad8\u7cbe\u5ea6\u6676\u632f\uff0c\u9700\u5728\u5de5\u7a0b\u4e2d\u5f00\u542f\u5168\u5c40\u5b8f\u5b9a\u4e49 CUSTOM_HSE_VAL \u6765\u5f00\u542f\u3002 \u542f\u7528 USB Host \u65f6\uff0c\u9700\u8981\u901a\u8fc7\u7535\u6e90\u5f00\u5173\u82af\u7247\uff08\u5982\uff1aSY6280AAC\uff09\u6765\u63a7\u5236\u5bf9USB Device \u7684\u4f9b\u7535\uff0c\u56e0 Mini-F5277-OB \u5f00\u53d1\u677f\u672a\u63d0\u4f9b USB A \u63a5\u53e3\u548c\u7535\u6e90\u5f00\u5173\u82af\u7247\uff0c\u8fd9\u91cc\u53ef\u4ee5\u5c06 D+(PA11)\u3001D-(PA12) \u548c EN(PC13)\u5f15\u811a\u5916\u63a5\u81f3\u5916\u90e8\u7684 USB A \u5916\u56f4\u7535\u8def\u4e2d\u8fdb\u884c\u6d4b\u8bd5\u9a8c\u8bc1\uff0c\u5e76\u9700\u8981\u5c06Mini-F5277-OB \u5f00\u53d1\u677f\u7684SP6\u548cSP4\u8fdb\u884c\u901a\u8fc7\u710a\u9521\u8fdb\u884c\u586b\u5145\u3002 USB\u672f\u8bed\u89e3\u6790 SIE SIE \u5728 USB \u9a71\u52a8\u4e2d\u662f\u6307 Serial Interface Engine\uff0c\u5373\u4e32\u884c\u63a5\u53e3\u5f15\u64ce\u3002\u5b83\u662f USB \u5916\u8bbe\u4e2d\u6700\u5173\u952e\u7684\u786c\u4ef6\u7ec4\u6210\u90e8\u5206\u4e4b\u4e00\u3002SIE \u8d1f\u8d23\u5904\u7406\u4e0e USB \u901a\u4fe1\u534f\u8bae\u76f8\u5173\u7684\u6240\u6709\u5e95\u5c42\u64cd\u4f5c\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u4ee5\u4e0b\u529f\u80fd\uff1a \u901f\u5ea6\u8bc6\u522b\uff1a\u8bc6\u522b\u8bbe\u5907\u7684\u4f20\u8f93\u901f\u5ea6\uff08\u4f4e\u901f\u3001\u5168\u901f\u3001\u9ad8\u901f\uff09\u3002 \u5305\u89e3\u6790\u548c\u6784\u9020\uff1a\u89e3\u6790\u63a5\u6536\u5230\u7684 USB \u6570\u636e\u5305\uff0c\u5e76\u6784\u9020\u8981\u53d1\u9001\u7684\u6570\u636e\u5305\u3002 NRZI \u7f16/\u8bd1\u7801\u548c\u586b\u5145\u4f4d\u64cd\u4f5c\uff1aNRZI \uff08Non-Return-to-Zero Inverted\uff09\u662f\u4e00\u79cd\u4fe1\u53f7\u7f16\u7801\u65b9\u5f0f\uff0cSIE \u80fd\u591f\u8fdb\u884c NRZI \u7f16\u7801\u548c\u89e3\u7801\uff0c\u4ee5\u53ca\u6dfb\u52a0\u548c\u53bb\u9664\u6570\u636e\u5305\u4e2d\u7684\u586b\u5145\u4f4d\u4ee5\u4fdd\u6301\u65f6\u949f\u540c\u6b65\u3002 \u4e0e USB \u603b\u7ebf\u7684\u7535\u6c14\u63a5\u53e3\uff1a\u5305\u62ec UTMI\uff08Universal Transceiver Macrocell Interface\uff09\u6216\u5176\u4ed6\u7c7b\u4f3c\u7684\u7269\u7406\u5c42\u63a5\u53e3\uff0c\u7528\u4e8e\u5b9e\u73b0\u4e0e USB \u603b\u7ebf\u7684\u7535\u6c14\u8fde\u63a5\u548c\u4fe1\u53f7\u4f20\u8f93\u3002 OTA USB OTG\uff08On-The-Go\uff09\u7684\u53cc\u89d2\u8272\u529f\u80fd\u662f\u6307\u8bbe\u5907\u80fd\u591f\u540c\u65f6\u626e\u6f14\u4e3b\u673a\uff08Host\uff09\u548c\u5916\u8bbe\uff08Peripheral\uff09\u7684\u89d2\u8272\u3002\u5728\u4f20\u7edf\u7684USB\u7cfb\u7edf\u4e2d\uff0c\u901a\u5e38\u6709\u4e00\u4e2a\u8bbe\u5907\u4f5c\u4e3a\u4e3b\u673a\uff0c\u8d1f\u8d23\u63a7\u5236\u548c\u7ba1\u7406\u6570\u636e\u4f20\u8f93\uff0c\u800c\u5176\u4ed6\u8bbe\u5907\u5219\u662f\u5916\u8bbe\uff0c\u53ea\u80fd\u88ab\u52a8\u54cd\u5e94\u4e3b\u673a\u7684\u8bf7\u6c42\u3002 \u7136\u800c\uff0c\u5728USB OTG\u4e2d\uff0c\u53cc\u89d2\u8272\u8bbe\u5907\uff08Dual-Role Device\uff0cDRD\uff09\u7684\u8bbe\u8ba1\u5141\u8bb8\u4e00\u4e2a\u8bbe\u5907\u5728\u4e0d\u540c\u7684\u65f6\u95f4\u6216\u5728\u9700\u8981\u7684\u65f6\u5019\u5207\u6362\u5176\u89d2\u8272\u3002\u8fd9\u610f\u5473\u7740\u8fd9\u6837\u7684\u8bbe\u5907\u65e2\u53ef\u4ee5\u4f5c\u4e3a\u4e3b\u673a\u6765\u53d1\u8d77\u6570\u636e\u4f20\u8f93\uff0c\u4f8b\u5982\u4ece\u4e00\u4e2aUSB\u95ea\u5b58\u9a71\u52a8\u5668\u8bfb\u53d6\u6570\u636e\uff0c\u4e5f\u53ef\u4ee5\u4f5c\u4e3a\u5916\u8bbe\u4e0e\u5176\u4ed6\u8bbe\u5907\u8fde\u63a5\uff0c\u5982\u88ab\u53e6\u4e00\u53f0\u8bbe\u5907\uff08\u53ef\u80fd\u662f\u53e6\u4e00\u53f0OTG\u8bbe\u5907\u6216\u8005\u4f20\u7edf\u7684\u4e3b\u673a\uff09\u8bbf\u95ee\u6216\u5145\u7535\u3002 \u8fd9\u79cd\u7075\u6d3b\u6027\u4f7f\u5f97USB OTG\u53cc\u89d2\u8272\u8bbe\u5907\u5728\u79fb\u52a8\u8bbe\u5907\u548c\u4fbf\u643a\u5f0f\u8bbe\u5907\u4e2d\u7279\u522b\u6709\u7528\uff0c\u6bd4\u5982\u667a\u80fd\u624b\u673a\u548c\u5e73\u677f\u7535\u8111\uff0c\u8fd9\u4e9b\u8bbe\u5907\u53ef\u80fd\u9700\u8981\u4e0e\u5176\u4ed6\u8bbe\u5907\u4ea4\u6362\u6570\u636e\uff0c\u6216\u8005\u5728\u6ca1\u6709\u4f20\u7edf\u4e3b\u673a\uff08\u5982\u7535\u8111\uff09\u7684\u60c5\u51b5\u4e0b\u76f4\u63a5\u8fdb\u884c\u6570\u636e\u4f20\u8f93\u548c\u4f9b\u7535\u64cd\u4f5c\u3002\u901a\u8fc7USB OTG\u7684\u53cc\u89d2\u8272\u652f\u6301\uff0c\u8bbe\u5907\u4e4b\u95f4\u7684\u4ea4\u4e92\u53d8\u5f97\u66f4\u52a0\u4fbf\u6377\u548c\u591a\u6837\u5316\u3002 \u652f\u6301\u4e3b\u673a\u534f\u5546\u534f\u8bae\uff08HNP\uff09\u548c\u4f1a\u8bdd\u8bf7\u6c42\u534f\u8bae\uff08SRP\uff09\u662fUSB On-The-Go\uff08OTG\uff09\u89c4\u8303\u4e2d\u7684\u4e24\u4e2a\u5173\u952e\u7279\u6027\u3002 \u4e3b\u673a\u534f\u5546\u534f\u8bae\uff08HNP\uff09\uff1a HNP\u5141\u8bb8USB OTG\u8bbe\u5907\u5728\u64cd\u4f5c\u8fc7\u7a0b\u4e2d\u52a8\u6001\u5207\u6362\u5176\u89d2\u8272\uff0c\u5373\u4ece\u4e3b\u673a\u89d2\u8272\u5207\u6362\u5230\u5916\u8bbe\u89d2\u8272\uff0c\u6216\u8005\u4ece\u5916\u8bbe\u89d2\u8272\u5207\u6362\u5230\u4e3b\u673a\u89d2\u8272\u3002\u8fd9\u79cd\u5207\u6362\u662f\u5728\u8bbe\u5907\u4e4b\u95f4\u76f4\u63a5\u8fdb\u884c\u7684\uff0c\u65e0\u9700\u4eba\u5de5\u5e72\u9884\u3002\u4f8b\u5982\uff0c\u5f53\u4e00\u4e2aOTG\u8bbe\u5907\u6b63\u5728\u4f5c\u4e3a\u4e3b\u673a\u4e0e\u53e6\u4e00\u4e2a\u8bbe\u5907\u901a\u4fe1\uff0c\u4f46\u968f\u540e\u5e0c\u671b\u88ab\u8fde\u63a5\u5230\u4e00\u4e2a\u66f4\u5f3a\u5927\u7684\u4e3b\u673a\uff08\u5982\u7535\u8111\uff09\u65f6\uff0c\u5b83\u53ef\u4ee5\u4f7f\u7528HNP\u8bf7\u6c42\u5c06\u4e3b\u673a\u89d2\u8272\u8f6c\u79fb\u7ed9\u65b0\u8fde\u63a5\u7684\u8bbe\u5907\u3002 \u4f1a\u8bdd\u8bf7\u6c42\u534f\u8bae\uff08SRP\uff09\uff1a SRP\u662fUSB OTG\u4e2d\u7684\u53e6\u4e00\u4e2a\u91cd\u8981\u7279\u6027\uff0c\u5b83\u5141\u8bb8\u65e0\u4e3b\u7535\u6e90\uff08\u5373\u81ea\u8eab\u4e0d\u4f9b\u7535\u7684\u8bbe\u5907\uff0c\u901a\u5e38\u79f0\u4e3aA\u8bbe\u5907\uff09\u542f\u52a8\u4e0e\u6709\u4e3b\u7535\u6e90\u8bbe\u5907\uff08\u901a\u5e38\u79f0\u4e3aB\u8bbe\u5907\uff09\u7684\u901a\u4fe1\u4f1a\u8bdd\u3002\u5728\u4f20\u7edf\u7684USB\u7cfb\u7edf\u4e2d\uff0c\u6570\u636e\u4f20\u8f93\u603b\u662f\u7531\u4e3b\u673a\u53d1\u8d77\u3002\u4f46\u5728USB OTG\u4e2d\uff0c\u7531\u4e8e\u8bbe\u5907\u53ef\u4ee5\u52a8\u6001\u5207\u6362\u89d2\u8272\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u79cd\u673a\u5236\u8ba9\u65e0\u4e3b\u7535\u6e90\u8bbe\u5907\u80fd\u591f\u542f\u52a8\u901a\u4fe1\u3002SRP\u5c31\u662f\u7528\u4e8e\u5b9e\u73b0\u8fd9\u4e00\u76ee\u6807\u7684\u534f\u8bae\uff0c\u5b83\u5141\u8bb8\u65e0\u4e3b\u7535\u6e90\u8bbe\u5907\u901a\u8fc7\u5411\u6709\u4e3b\u7535\u6e90\u8bbe\u5907\u53d1\u9001\u4e00\u4e2a\u4f1a\u8bdd\u8bf7\u6c42\u6765\u542f\u52a8\u6570\u636e\u4f20\u8f93\u3002 \u603b\u7684\u6765\u8bf4\uff0cHNP\u548cSRP\u90fd\u662f\u4e3a\u4e86\u589e\u5f3aUSB OTG\u8bbe\u5907\u7684\u7075\u6d3b\u6027\u548c\u4e92\u64cd\u4f5c\u6027\uff0c\u4f7f\u5f97\u8bbe\u5907\u80fd\u591f\u6839\u636e\u9700\u8981\u52a8\u6001\u8c03\u6574\u5176\u89d2\u8272\u548c\u884c\u4e3a\uff0c\u4ece\u800c\u5728\u5404\u79cd\u4e0d\u540c\u7684\u4f7f\u7528\u573a\u666f\u4e0b\u63d0\u4f9b\u66f4\u597d\u7684\u7528\u6237\u4f53\u9a8c\u3002 USB\u7684SE0\u4fe1\u53f7 \u5728USB\uff08Universal Serial Bus\uff09\u534f\u8bae\u4e2d\uff0cSE0\uff08Single-Ended Zero\uff09\u4fe1\u53f7\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u4fe1\u53f7\u72b6\u6001\uff0c\u5b83\u8868\u793a\u6570\u636e\u7ebfD+\u548cD-\u4e0a\u7684\u7535\u5e73\u90fd\u4e3a\u903b\u8f910\uff08\u4f4e\u7535\u5e73\uff09\u3002 SE0\u4fe1\u53f7\u5728USB\u901a\u4fe1\u4e2d\u626e\u6f14\u7740\u91cd\u8981\u7684\u89d2\u8272\uff0c\u4e3b\u8981\u7528\u4e8e\u9519\u8bef\u68c0\u6d4b\u3001\u8bbe\u5907\u521d\u59cb\u5316\u548c\u603b\u7ebf\u6062\u590d\u7b49\u64cd\u4f5c\u3002\u5b83\u662f\u786e\u4fddUSB\u603b\u7ebf\u7a33\u5b9a\u6027\u548c\u53ef\u9760\u6027\u7684\u5173\u952e\u90e8\u5206\u3002 USB\u7684JSTATE \u4fe1\u53f7 USB\u5dee\u5206\u63a5\u6536\u5668\u63a5\u6536\u5230JSTATE\u4fe1\u53f7\u65f6\uff0c\u5b83\u901a\u5e38\u662f\u4f5c\u4e3a\u8bbe\u5907\u679a\u4e3e\u548c\u901f\u5ea6\u68c0\u6d4b\u8fc7\u7a0b\u7684\u4e00\u90e8\u5206\uff0c\u5e2e\u52a9\u4e3b\u673a\u6b63\u786e\u8bc6\u522b\u548c\u914d\u7f6e\u8fde\u63a5\u7684USB\u8bbe\u5907\u3002 STALL \u4e2d\u65ad STALL\u4e2d\u65ad\u662fUSB\u534f\u8bae\u4e2d\u4e00\u79cd\u91cd\u8981\u7684\u9519\u8bef\u5904\u7406\u548c\u901a\u4fe1\u673a\u5236\uff0c\u5b83\u5141\u8bb8\u8bbe\u5907\u5411\u4e3b\u673a\u62a5\u544a\u65e0\u6cd5\u5904\u7406\u8bf7\u6c42\u7684\u60c5\u51b5\uff0c\u5e76\u4fc3\u4f7f\u4e3b\u673a\u91c7\u53d6\u76f8\u5e94\u7684\u63aa\u65bd\u6765\u89e3\u51b3\u95ee\u9898\u3002\u901a\u8fc7\u6b63\u786e\u5904\u7406STALL\u4e2d\u65ad\uff0c\u53ef\u4ee5\u63d0\u9ad8USB\u901a\u4fe1\u7684\u53ef\u9760\u6027\u548c\u7a33\u5b9a\u6027\u3002 RESUME\u4e2d\u65ad RESUME\u4e2d\u65ad\u662fUSB\u534f\u8bae\u4e2d\u4e00\u79cd\u91cd\u8981\u7684\u7535\u6e90\u7ba1\u7406\u673a\u5236\uff0c\u5b83\u5141\u8bb8\u8bbe\u5907\u5728\u6682\u505c\u540e\u91cd\u65b0\u542f\u52a8\u6570\u636e\u4f20\u8f93\uff0c\u5e76\u786e\u4fdd\u4e3b\u673a\u80fd\u591f\u6b63\u786e\u5730\u5904\u7406\u8bbe\u5907\u7684\u6062\u590d\u8bf7\u6c42\u3002\u901a\u8fc7\u6709\u6548\u7ba1\u7406RESUME\u4e2d\u65ad\uff0c\u53ef\u4ee5\u63d0\u9ad8USB\u8bbe\u5907\u7684\u80fd\u6548\u548c\u7528\u6237\u4f53\u9a8c\u3002 \u53c2\u8003\u6587\u732e USB 2.0 Specification\uff1ahttps://usb.org/document-library/usb-20-specification TinyUSB \u5b98\u7f51\uff1ahttps://docs.tinyusb.org/en/latest/ MM32F5270 UM\uff1ahttps://mindmotion.com.cn/download/products/UM_MM32F5270_MM32F5280_SC.pdf \u300a\u5708\u5708\u6559\u4f60\u73a9 USB\u300b\uff0c\u5218\u8363\uff0c\u5317\u4eac\u822a\u7a7a\u822a\u5929\u5927\u5b66\u51fa\u7248\u793e\uff0cISBN: 9787811246001","title":"TinyUSB\u79fb\u690d"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tinyusb","text":"\u4ece\u96f6\u5f00\u59cb\u79fb\u690dTinyUSB\u534f\u8bae\u6808 \u7b80\u4ecb \u83b7\u53d6MCU\u5e93\u51fd\u6570\u4e0e\u4f8b\u7a0b \u83b7\u53d6TinyUSB\u534f\u8bae\u6808 \u5de5\u7a0b\u76ee\u5f55\u7ed3\u6784 \u914d\u7f6e\u79fb\u690d\u63a5\u53e3 \u914d\u7f6eUSB Device\u63a5\u53e3 USB \u7aef\u70b9\u7ba1\u7406 USB \u9a71\u52a8\u4f7f\u80fd USB Device \u4e2d\u65ad \u914d\u7f6eUSB Host\u63a5\u53e3 \u53cc\u5411\u961f\u5217\u5b9e\u73b0 \u6570\u636e\u5e93\u5b9e\u73b0 USB \u7f13\u51b2\u63cf\u8ff0\u8868\u5b9a\u4e49 USB \u7aef\u70b9\u7ba1\u7406 USB\u9a71\u52a8\u4f7f\u80fd USB Host\u4e2d\u65ad \u521b\u5efa\u5de5\u7a0b\u6837\u4f8b \u6837\u4f8b\u6f14\u793a TinyUSB\u534f\u8bae\u6808\u6837\u4f8b\u4ecb\u7ecd board_test tud_cdc_dual_ports tud_cdc_msc tud_hid_composite tud_msc_dual_lun tud_video_capture tud_webusb_serial tuh_bare_api tuh_cdc_msc_hid tuh_hid_controller \u6ce8\u610f\u4e8b\u9879 USB\u672f\u8bed\u89e3\u6790 \u53c2\u8003\u6587\u732e","title":"\u4ece\u96f6\u5f00\u59cb\u79fb\u690dTinyUSB\u534f\u8bae\u6808"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#_1","text":"\u672c\u6587\u5c06\u57fa\u4e8e Mini-F5277-OB \u5f00\u53d1\u677f\uff0c\u8bb2\u89e3\u4ece\u96f6\u5f00\u59cb\u79fb\u690dTiny USB\u534f\u8bae\u6808\u7684\u5168\u8fc7\u7a0b\u3002 Mini-F5277-OB \u5f00\u53d1\u677f\u4ecb\u7ecd Mini-F5277-OB \u5f00\u53d1\u677f\uff0c\u642d\u8f7d\u4e86MM32F5270\u7cfb\u5217\u4e2d MM32F5277E7PV \u578b\u53f7\u7684MCU\uff0c\u4e3a32\u4f4d Arm China STAR-MC1 \u67b6\u6784\uff0c\u5185\u7f6e 256KB Flash\uff0c192KB SRAM\uff0c\u5e76\u5e26\u6709USB\u5168\u901f\u8bbe\u5907\u63a7\u5236\u5668\uff0c\u652f\u6301 12Mbps \u7684\u4f20\u8f93\u901f\u7387\u3002\u5728\u914d\u7f6e\u4e3a USB Host \u6a21\u5f0f\u4e0b\u652f\u6301 12Mbps \u7684\u5168\u901f\u4f20\u8f93\u548c 1.5 Mbps \u7684\u4f4e\u901f\u4f20\u8f93\u901f\u7387\u3002\u5176\u4e2d USB_FS \u63a7\u5236\u5668\u5185\u7f6e USB \u5168\u901f PHY\u3002\u8be6\u60c5\u89c1\uff1a \u4e0a\u6d77\u7075\u52a8\u5fae\u7535\u5b50\u80a1\u4efd\u6709\u9650\u516c\u53f8 (mindmotion.com.cn) \u5b98\u7f51\u3002 TinyUSB \u534f\u8bae\u6808\u4ecb\u7ecd TinyUSB \u662f\u4e00\u4e2a\u5e94\u7528\u4e8e\u5d4c\u5165\u5f0f\u7cfb\u7edf\u7684\u5f00\u6e90\u8de8\u5e73\u53f0 USB Host / Device \u534f\u8bae\u6808\uff0c\u5176\u4f18\u70b9\u4e3a\uff1a MIT \u5f00\u6e90\u534f\u8bae\uff0c\u4e0d\u7528\u62c5\u5fc3\u7248\u6743\u95ee\u9898\uff1b \u5185\u5b58\u5b89\u5168\uff08\u6ca1\u6709\u52a8\u6001\u5185\u5b58\u5206\u914d\uff09\uff1b \u7ebf\u7a0b\u5b89\u5168\uff08\u6240\u6709\u4e2d\u65ad\u4e8b\u4ef6\u90fd\u4f1a\u653e\u5728\u975e\u4e2d\u65ad\u51fd\u6570\u4e2d\u5904\u7406\uff09\u3002 \u5982\u4e0b\u56fe\u6240\u793a\uff0c\u4e3aTinyUSB\u534f\u8bae\u6808\u7ed3\u6784\u6846\u56fe\uff1a \u56fex TinyUSB \u534f\u8bae\u6808\u6846\u56fe \u7531\u4e0a\u56fe\u53ef\u77e5\uff0cTinyUSB\u534f\u8bae\u6808\u4e2d\u7684Host \u4e0e Device \u662f\u76f8\u4e92\u72ec\u7acb\u7684\u4e24\u4e2a\u534f\u8bae\u3002 TinyUSB \u534f\u8bae\u6808\u4e2d\u7684 Device \u534f\u8bae\u5e94\u7528\u8f83\u4e3a\u5e7f\u6cdb\uff0c\u652f\u6301\u7684 USB \u7c7b\u4e5f\u5341\u5206\u4e30\u5bcc\uff1a Audio Class 2.0 (UAC2) Bluetooth Host Controller Interface (BTH HCI) Communication Class (CDC) Device Firmware Update (DFU): DFU mode (WIP) and Runtinme Human Interface Device (HID): Generic (In & Out), Keyboard, Mouse, Gamepad etc \u2026 Mass Storage Class (MSC): with multiple LUNs Musical Instrument Digital Interface (MIDI) Network with RNDIS, CDC-ECM (work in progress) USB Test and Measurement Class (USBTMC) Vendor-specific class support with generic In & Out endpoints. Can be used with MS OS 2.0 compatible descriptor to load winUSB driver without INF file. WebUSB with vendor-specific class \u800c Host \u652f\u6301\u7684\u7c7b\uff0c\u6682\u65f6\u63d0\u4f9b\u4e86\u4e24\u4e2a\uff0c\u4e0d\u8fc7\u5bf9\u4e8e MCU \u7684\u8fd9\u79cd\u8d44\u6e90\u7684\u5e94\u7528\u800c\u8a00\uff0c\u4ee5\u4e0b\u4e24\u4e2a\u7c7b\u8db3\u591f\u6ee1\u8db3\u5927\u90e8\u5206\u9700\u6c42\u4e86\uff1a Human Interface Device (HID): Keyboard, Mouse, Generic Mass Storage Class (MSC)","title":"\u7b80\u4ecb"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#mcu","text":"Mini-F5277-OB \u5f00\u53d1\u677f\u7684\u9a71\u52a8\u6837\u4f8b\u53ca\u539f\u7406\u56fe\u4f4d\u4e8e\uff1a https://www.mindmotion.com.cn/support/development_tools/evaluation_boards/miniboard/mm32f5277e7pv/ \uff0c\u4e0b\u8f7d MM32F5270 \u5e93\u51fd\u6570\u4e0e\u4f8b\u7a0b \uff0c\u8fd9\u91cc\u6211\u4eec\u7528\u5230\u4e86\u8f6f\u4ef6\u5305\u4e2d\u7684 device \u6587\u4ef6\u5939\uff0c\u5176\u4e2d\u5305\u542bMCU\u7684\u542f\u52a8\u6587\u4ef6\u548c\u9a71\u52a8\u6587\u4ef6\u3002","title":"\u83b7\u53d6MCU\u5e93\u51fd\u6570\u4e0e\u4f8b\u7a0b"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tinyusb_1","text":"TinyUSB\u534f\u8bae\u6808\u6e90\u7801\u4e0b\u8f7d\u5730\u5740\uff1a https://github.com/hathach/tinyusb/releases/tag/0.16.0 \u672c\u6b21\u79fb\u690d\u662f\u57fa\u4e8e\u622a\u6b62\u672c\u6587\u7f16\u5199\u65f6\u6700\u65b0\u7248\u672c\u7684 TinyUSB V0.16.0 \u8fdb\u884c\u79fb\u690d\uff0c\u8fd9\u91cc\u6211\u4eec\u7528\u5230\u4e86\u8f6f\u4ef6\u5305 tinyusb\\src \u4f5c\u4e3a\u534f\u8bae\u6808\u6e90\u7801\u3001 tinyusb\\examples \u6587\u4ef6\u5939\u4e2dUSB \u6837\u4f8b\u4ee3\u7801\u548c tinyusb\\hw\\bsp \u6587\u4ef6\u5939\u4e2d\u7684\u652f\u6301\u7684\u5f00\u53d1\u677f\u6e90\u6587\u4ef6\u3002 . \u251c\u2500\u2500 docs # Documentation \u251c\u2500\u2500 examples # Examples with make and cmake build system \u251c\u2500\u2500 hw \u2502 \u251c\u2500\u2500 bsp # Supported boards source files \u2502 \u2514\u2500\u2500 mcu # Low level mcu core & peripheral drivers \u251c\u2500\u2500 lib # Sources from 3rd party such as freeRTOS, fatfs ... \u251c\u2500\u2500 src # All sources files for TinyUSB stack itself. \u251c\u2500\u2500 test # Tests: unit test, fuzzing, hardware test \u2514\u2500\u2500 tools # Files used internally","title":"\u83b7\u53d6TinyUSB\u534f\u8bae\u6808"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#_2","text":"\u5982\u4e0b\u56fex\u6240\u793a\uff0c\u6574\u4e2aTinyUSB\u534f\u8bae\u6808\u9002\u914d\u5de5\u7a0b\u7684\u5efa\u7acb\u5206\u4e3a\u4ee5\u4e0b\u56db\u4e2a\u90e8\u5206\uff1a device - MCU\u542f\u52a8\u6587\u4ef6\u53ca\u5916\u8bbe\u9a71\u52a8 examples - TinyUSB\u534f\u8bae\u6808\u6837\u4f8b tinyusb - TinyUSB\u534f\u8bae\u6808\u6e90\u7801 tinyusb_port - TinyUSB\u534f\u8bae\u6808\u79fb\u690d\u63a5\u53e3\u53caUSB\u9a71\u52a8 \u56fex \u9664\u4e86\u5c06\u4e0a\u8ff0\u63d0\u5230\u7684 MM32F5270 \u5e93\u51fd\u6570\u4e0e\u4f8b\u7a0b \u8f6f\u4ef6\u5305\u4e2d\u7684 device \u6587\u4ef6\u5939\u548c TinyUSB V0.16.0 \u8f6f\u4ef6\u5305 \u4e2d tinyusb\\src \u6587\u4ef6\u5939\u62f7\u8d1d\u5230\u76ee\u6807\u5de5\u7a0b\u6587\u4ef6\u5939\u4e2d\u5916\uff0c\u8981\u65b0\u5efa examples \u6587\u4ef6\u5939\u548c tinyusb_port \u6587\u4ef6\u5939\u3002\u5728\u83b7\u53d6\u7684TinyUSB\u534f\u8bae\u6808\u7684 examples \u6587\u4ef6\u5939\u4e2d\uff0c\u627e\u5230\u76ee\u6807\u6837\u4f8b\u3002\u63a5\u4e0b\u6765\u672c\u6587\u5c06\u4ee5 tinyusb\\exmaples\\device \u6587\u4ef6\u5939\u4e2d\u7684 cdc_msc \u6837\u4f8b\u4e3a\u4f8b\u8fdb\u884c\u79fb\u690d\u6f14\u793a\u3002","title":"\u5de5\u7a0b\u76ee\u5f55\u7ed3\u6784"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#_3","text":"TinyUSB \u534f\u8bae\u6808\u7684\u79fb\u690d\u63a5\u53e3\u5206\u4e3a USB Device\u63a5\u53e3\u548c USB Host\u63a5\u53e3\uff0c\u8fd9\u91cc\u7edf\u4e00\u5728\u76ee\u6807\u5de5\u7a0b\u6587\u4ef6\u5939\u7684 tinyusb_port \u6587\u4ef6\u5939\u4e2d\u8fdb\u884c\u5b9e\u73b0\uff0c\u5982\u56fex\u6240\u793a\u3002 \u56fex \u5176\u4e2d bsp \u6587\u4ef6\u5939\u4e2d\uff0c\u653e\u7f6e\u4e86TinyUSB\u534f\u8bae\u6808\u4e2d tinyusb\\hw\\bsp \u6587\u4ef6\u5939\u4e0b\u7684 ansi_escape.h \u3001 board.c \u3001 board_api.h \u548c board_mcu.h \u6587\u4ef6\uff0c\u5982\u56fex\u6240\u793a\u3002 \u56fex hal_usb.c \u3001 hal_usb.h \u3001 hal_usb_bdt.h \u548c reg_usb.h \u6587\u4ef6\u4e3a USB\u9a71\u52a8\u76f8\u5173\u6587\u4ef6\uff0c\u82e5MCU\u4e2d\u7684 USB IP\u4e00\u81f4\u5219\u53ef\u590d\u7528\u8be5USB \u9a71\u52a8\u6587\u4ef6\u3002 tud_dcd_port.c \u548c tuh_hcd_port.c \u662f\u57fa\u4e8e USB \u9a71\u52a8\u5b9e\u73b0\u7684TinyUSB\u534f\u8bae\u6808\u4e2dUSB Device\u79fb\u690d\u63a5\u53e3\u548cUSB Host\u79fb\u690d\u63a5\u53e3 \u3002 mini_f5277_ob.c \u6587\u4ef6\u5b9e\u73b0\u4e86\u677f\u8f7dMCU\u7684USB\u76f8\u5173\u7684\u65f6\u949f\u914d\u7f6e\u3001UART\u521d\u59cb\u5316\u3001printf \u51fd\u6570\u91cd\u6620\u5c04\u548c\u677f\u8f7dLED\u548c\u6309\u952e\u7684GPIO\u521d\u59cb\u5316\uff0c\u6b64\u6587\u4ef6\u53ef\u4ee5\u6839\u636e\u4e0d\u540c\u7684\u5f00\u53d1\u7248\u548cMCU\u578b\u53f7\u8fdb\u884c\u5b9e\u73b0\u3002 #include \"bsp/board_api.h\" #include \"mm32_device.h\" #include \"mm32f5270.h\" // Initialize on-board peripherals : led, button, uart and USB void board_init(void) { // Config PLL2 clock param. RCC_PLL2Config(1, 0, 7, 1); // PLL2 = HSE * (7+1) / (1+1) = 48MHz RCC->PLL2CFGR |= 3 << RCC_PLL2CFGR_PLL2_ICTRL_Pos; // Enable PLL2 clock. RCC_PLL2Cmd(ENABLE); while((RCC->CR & RCC_CR_PLL2RDY_Msk) == 0) { } // Select PLL2 as USB clock source. MODIFY_REG(RCC->CFGR, RCC_CFGR_USBCLKSEL_Msk, 1 << RCC_CFGR_USBCLKSEL_Pos); // Enable USB Clock. MODIFY_REG(RCC->CFGR, RCC_CFGR_USBPRE_Msk, 0 << RCC_CFGR_USBPRE_Pos); // Select HSE as system clock. RCC_SYSCLKConfig(2); // clock init. RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART2, ENABLE); // sys time init; #if CFG_TUSB_OS == OPT_OS_NONE RCC_ClocksTypeDef sys_clk; RCC_GetClocksFreq(&sys_clk); SysTick_Config(sys_clk.SYSCLK_Frequency / 1000); NVIC_SetPriority(SysTick_IRQn, 0); #endif // peripheral init; GPIO_InitTypeDef gpio_init; // led PB15-LED1,PB14-LED2 gpio_init.GPIO_Mode = GPIO_Mode_Out_PP; gpio_init.GPIO_Speed = GPIO_Speed_High; gpio_init.GPIO_Pin = GPIO_Pin_15; GPIO_Init(GPIOB, &gpio_init); gpio_init.GPIO_Pin = GPIO_Pin_14; GPIO_Init(GPIOB, &gpio_init); // btn PB0-K1,PB1-K2 gpio_init.GPIO_Mode = GPIO_Mode_IPU; gpio_init.GPIO_Pin = GPIO_Pin_0; GPIO_Init(GPIOB, &gpio_init); gpio_init.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOB, &gpio_init); // uart PA2-TX,PA3-RX gpio_init.GPIO_Mode = GPIO_Mode_AF_PP; gpio_init.GPIO_Pin = GPIO_Pin_2; GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_7); GPIO_Init(GPIOA, &gpio_init); gpio_init.GPIO_Mode = GPIO_Mode_IPU; gpio_init.GPIO_Pin = GPIO_Pin_3; GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_7); GPIO_Init(GPIOA, &gpio_init); UART_InitTypeDef UART_InitStruct; UART_StructInit(&UART_InitStruct); UART_InitStruct.BaudRate = CFG_BOARD_UART_BAUDRATE; UART_InitStruct.WordLength = UART_WordLength_8b; UART_InitStruct.StopBits = UART_StopBits_1; UART_InitStruct.Parity = UART_Parity_No; UART_InitStruct.HWFlowControl = UART_HWFlowControl_None; UART_InitStruct.Mode = UART_Mode_Tx | UART_Mode_Rx; UART_Init(UART2, &UART_InitStruct); UART_Cmd(UART2, ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_USB_FS, ENABLE); } // Turn LED on or off void board_led_write(bool state) { if (state) { GPIOB->BRR = 1 << 14; GPIOB->BRR = 1 << 15; } else { GPIOB->BSRR = 1 << 14; GPIOB->BSRR = 1 << 15; }; } // Control led pattern using phase duration in ms. // For each phase, LED is toggle then repeated, board_led_task() is required to be called //void board_led_pattern(uint32_t const phase_ms[], uint8_t count); // Get the current state of button // a '1' means active (pressed), a '0' means inactive. uint32_t board_button_read(void) { if (!(GPIOB->IDR & (1 << 0)) | !(GPIOB->IDR & (1 << 1)) ) { return 1; } else { return 0; } } // Get characters from UART. Return number of read bytes int board_uart_read(uint8_t *buf, int len) { if (UART2->CSR & UART_CSR_RXAVL_Msk) { buf[0] = UART2->RDR; return 1; } else { return 0; } } // Send characters to UART. Return number of sent bytes int board_uart_write(void const *buf, int len) { for (int i = 0; i < len; i++) { putchar(((char*)(buf))[i]); } return len; } #if CFG_TUSB_OS == OPT_OS_NONE volatile static uint32_t systime = 0; // Get current milliseconds, must be implemented when no RTOS is used uint32_t board_millis(void) { return systime; } void SysTick_Handler(void) { systime++; } #endif // stdio getchar() is blocking, this is non-blocking version int board_getchar(void) { if (UART2->CSR & UART_CSR_RXAVL_Msk) { return UART2->RDR; } else { return 0; } } int fputc(int ch, FILE *f) { UART2->TDR = ch; while (UART2->CSR & UART_CSR_TXFULL_Msk) {} return (ch); } int fgetc(FILE* file) { int ch; while((ch = board_getchar()) != 0) {} return ch; } \u9700\u8981\u6ce8\u610f\u7684\u662f\u63d0\u4f9b\u8fc7\u7ed9 USB \u6a21\u5757\u7684\u8fd9\u4e2a 48MHz \u65f6\u949f\u53ef\u4ee5\u6765\u81ea\u4e8ePLL1 \u7684 N \u5206\u9891\uff0cPLL2 \u7684 N \u5206\u9891\uff0c\u90e8\u5206 MCU \u53ef\u80fd\u8fd8\u6709\u5176\u4ed6\u7684\u9009\u62e9\u3002\u8fd9\u4e2a 48MHz \u65f6\u949f\u9700\u8981\u5c3d\u53ef\u80fd\u7cbe\u786e\uff0c\u5982\u6709\u5fc5\u8981\uff0c\u5411 MCU \u63d0\u4f9b\u65f6\u949f\u7684\u5916\u90e8\u6676\u632f\u90fd\u53ef\u4ee5\u6362\u6210 12.000MHz \uff08\u6ce8\u610f\u5c0f\u6570\u70b9\u540e\u9762\u67093\u4e2a0\uff09\u7684\u6676\u632f\uff0c\u4ee5\u4fdd\u8bc1 48MHz \u8db3\u591f\u7cbe\u786e\u3002","title":"\u914d\u7f6e\u79fb\u690d\u63a5\u53e3"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#usb-device","text":"USB Device\u79fb\u690d\u63a5\u53e3\u5728 tud_dcd_port.c \u6587\u4ef6\u4e2d\u5b9e\u73b0\uff0c\u4e3b\u8981\u5206\u4e3a\u5982\u4e0b\u90e8\u5206\uff1a SETUP \u5305\u7684\u63a5\u6536 \u8bbe\u7f6e\u5730\u5740 \u63a5\u53e3\u9002\u914d \u4e2d\u65ad\u5904\u7406 \u5b9a\u4e49\u5168\u5c40\u53d8\u91cf \u4e3a\u4e86\u9002\u914d TinyUSB Device\uff0c\u5728\u9002\u914d\u5c42\u4e00\u5171\u8bbe\u7f6e\u5982\u4e0b\u5168\u5c40\u53d8\u91cf\uff1a /* OTG_FS BufferDescriptorTable Buffer. */ static __ALIGNED(512u) USB_BufDespTable_Type usb_bd_tbl = {0u}; /*usb_bufdesp_table */ static uint8_t usb_ep0_buf[CFG_TUD_ENDPOINT0_SIZE] = {0u}; /*usb_recv_buff. */ static uint8_t usb_setup_buf[8u] = {0u}; /* usb_setup_buff. */ static uint8_t usb_device_addr = 0u; /* usb_device_addr. */ typedef struct { uint8_t * xfer_buf; uint32_t max_packet_size; /* EndPoint max packet size. */ uint32_t length; /* EndPoint xfer data length. */ uint32_t remaining; /* EndPoint xfer data remaining. */ bool odd_even; /* EndPoint BD OddEven status. */ bool data_n; /* next packet is DATA0 or DATA1. */ bool xfer_done; } USB_EndPointManage_Type; static USB_EndPointManage_Type usb_epmng_tbl[16u][2u] = {0u}; /* EndPointManage Table. */ \u5728 tud_dcd_port.c \u6587\u4ef6\u4e2d\u5b9a\u4e49USB \u6570\u636e\u7f13\u51b2\u533a\uff08\u5728USB\u9a71\u52a8\u4e2d\u5b9a\u4e49USB_BufDespTable_Type\u7ed3\u6784\u4f53\u7c7b\u578b\uff09\uff0c\u5e76\u5728USB\u9a71\u52a8\u521d\u59cb\u5316\u548cUSB\u534f\u8bae\u6808\u4efb\u52a1\u5904\u7406\u65f6\u4f7f\u7528\u3002 static __ALIGNED(512u) USB_BufDespTable_Type usb_bd_tbl = {0u}; /* usb_bufdesp_table */","title":"\u914d\u7f6eUSB Device\u63a5\u53e3"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#usb","text":"\u5728 tud_dcd_port.c \u6587\u4ef6\u4e2d\u5b9a\u4e49 USB_EndPointManage_Type \u7ed3\u6784\u4f53\u7c7b\u578b\u3002 typedef struct { uint8_t * xfer_buf; uint32_t max_packet_size; /* EndPoint max packet size. */ uint32_t length; /* EndPoint xfer data length. */ uint32_t remaining; /* EndPoint xfer data remaining. */ bool odd_even; /* EndPoint BD OddEven status. */ bool data_n; /* next packet is DATA0 or DATA1. */ bool xfer_done; } USB_EndPointManage_Type;","title":"USB \u7aef\u70b9\u7ba1\u7406"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#usb_1","text":"\u5728 tud_dcd_port.c \u4e2d\u7684 dcd_init() \u51fd\u6570\u5b9e\u73b0\u3002 // Initialize controller to device mode void dcd_init (uint8_t rhport) { (void) rhport; USB_Device_Init_Type init = {0u}; init.BufDespTable_Addr = (uint32_t)&usb_bd_tbl; USB_InitDevice(BOARD_USB_PORT, &init); USB_Enable(BOARD_USB_PORT, true); NVIC_ClearPendingIRQ(BOARD_USB_IRQn); }","title":"USB \u9a71\u52a8\u4f7f\u80fd"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#usb-device_1","text":"\u5728 tud_dcd_port.c \u4e2d\u7684 dcd_int_enable() \u548c dcd_int_disable() \u51fd\u6570\u5b9e\u73b0 USB Device\u8bbe\u5907\u7684\u4e2d\u65ad\u5f00\u542f\u4e0e\u5173\u95ed\u3002 // Enable device interrupt void dcd_int_enable (uint8_t rhport) { (void) rhport; USB_EnableInterrupts(BOARD_USB_PORT, USB_INT_RESET | USB_INT_TOKENDONE | USB_INT_SLEEP | USB_INT_RESUME | USB_INT_STALL | USB_INT_SOFTOK, true); /* enable interrupts*/ NVIC_SetPriority(BOARD_USB_IRQn, 3u); NVIC_EnableIRQ(BOARD_USB_IRQn); } \u5e76\u5728 tud_dcd_port.c \u4e2d\u7684 dcd_int_handler() \u51fd\u6570\u5b9e\u73b0 USB Device \u8bbe\u5907\u7684\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u3002 // Interrupt Handler void dcd_int_handler(uint8_t rhport) { uint32_t flag = USB_GetInterruptStatus(BOARD_USB_PORT); if (flag & USB_INT_TOKENDONE) { USB_TokenDoneHandler(rhport); return; } if (flag & USB_INT_RESET) { USB_ClearInterruptStatus(BOARD_USB_PORT, USB_INT_RESET); USB_BusResetHandler(); dcd_event_bus_reset(rhport, TUSB_SPEED_FULL, true); } if (flag & USB_INT_SLEEP) { USB_ClearInterruptStatus(BOARD_USB_PORT, USB_INT_SLEEP); dcd_event_bus_signal(rhport, DCD_EVENT_SUSPEND, true); } if (flag & USB_INT_RESUME) { USB_ClearInterruptStatus(BOARD_USB_PORT, USB_INT_RESUME); dcd_event_bus_signal(rhport, DCD_EVENT_RESUME, true); } if (flag & USB_INT_STALL) { USB_EnableEndPointStall(BOARD_USB_PORT, USB_EP_0, false); dcd_edpt_clear_stall(rhport, 0); USB_BufDesp_Xfer(&usb_bd_tbl.Table[0u][USB_Direction_OUT][usb_epmng_tbl[0u][USB_Direction_OUT].odd_even], 1, usb_ep0_buffer, 64); USB_ClearInterruptStatus(BOARD_USB_PORT, USB_INT_STALL); } if (flag & USB_INT_SOFTOK) { USB_ClearInterruptStatus(BOARD_USB_PORT, USB_INT_SOFTOK); } } /* USB IRQ. */ void BOARD_USB_IRQHandler(void) { dcd_int_handler(BOARD_TUD_RHPORT); }","title":"USB Device \u4e2d\u65ad"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#usb-host","text":"MM32G5330 USB \u652f\u6301 Host \u529f\u80fd\uff0cTinyUSB \u534f\u8bae\u6808\u4e2d\u4e5f\u5305\u542b\u4e86 Host \u90e8\u5206\uff0c\u5728\u9002\u914d Host \u8fc7\u7a0b\u4e2d\uff0c\u4f7f\u7528\u5230\u4e86\u53cc\u5411\u961f\u5217\u548c\u6570\u636e\u5e93\u7684\u6982\u5ff5\u3002USB Host\u79fb\u690d\u63a5\u53e3\u5728 tuh_dcd_port.c \u6587\u4ef6\u4e2d\u5b9e\u73b0\uff0c\u4e3b\u8981\u5206\u4e3a\u5982\u4e0b\u6b65\u9aa4\uff1a \u53cc\u5411\u961f\u5217\u5b9e\u73b0 \u6570\u636e\u5e93\u5b9e\u73b0 \u63a5\u53e3\u5b9e\u73b0 \u4e2d\u65ad\u5904\u7406","title":"\u914d\u7f6eUSB Host\u63a5\u53e3"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#_4","text":"USB \u603b\u7ebf\u4f1a\u50cf\u591a\u4e2a\u7aef\u70b9\u4f20\u8f93\u4e0d\u540c\u7684\u5185\u5bb9\uff0c\u4f46 USB \u603b\u7ebf\u53ea\u6709\u4e00\u6761\uff0c\u56e0\u6b64\u9700\u8981\u5c06\u4f20\u8f93\u4efb\u52a1\u653e\u5728\u4e00\u4e2a\u961f\u5217\u4e2d\uff0c\u6309\u7167\u961f\u5217\u7684\u987a\u5e8f\u4f20\u8f93\u6570\u636e \uff1b\u5728\u4f20\u8f93\u8fc7\u7a0b\u4e2d\uff0c\u53ef\u80fd\u4f1a\u6709\u5206\u6bb5\u4f20\u8f93\uff0c\u4f20\u8f93\u5931\u8d25\u7b49\u60c5\u51b5\uff0c\u53ef\u80fd\u8981\u5c06\u4f20\u8f93\u4efb\u52a1\u91cd\u65b0\u653e\u5728\u961f\u5217\u7684\u5934\u90e8\uff0c\u800c\u4e0d\u662f\u672b\u5c3e\uff0c\u56e0\u6b64\uff0c\u8fd9\u4e2a\u961f\u5217\u4e0d\u4ec5\u80fd\u5c06\u4f20\u8f93\u4efb\u52a1\u653e\u5728\u961f\u5217\u5c3e\u90e8\uff0c\u4e5f\u80fd\u5c06\u4f20\u8f93\u4efb\u52a1\u653e\u5728\u5934\u90e8\uff0c\u5c31\u50cf\u5806\u6808\u90a3\u6837\uff0c\u56e0\u6b64\uff0c\u9700\u8981\u5b9e\u73b0\u4e00\u4e2a\u53cc\u5411\u961f\u5217\u3002\u540c\u666e\u901a\u7684\u961f\u5217\u4e00\u6837\uff0c\u53cc\u5411\u961f\u5217\u9700\u8981\u4e00\u4e2a\u961f\u5217buffer\uff0c\u4ee5\u53ca\u7ba1\u7406\u961f\u5217 buffer \u7684\u5b57\u6bb5\uff0c\u7136\u540e\u6bcf\u6b21\u8bfb\u5199\u961f\u5217\u65f6\uff0c\u4e0d\u80fd\u76f4\u63a5\u64cd\u4f5c\u8fd9\u4e2a buffer\uff0c\u800c\u662f\u53ea\u80fd\u4f7f\u7528\u7ed9\u5b9a\u7684 push \u548c pop \u65b9\u6cd5\u64cd\u4f5c\u3002\u5b9e\u73b0\u64cd\u4f5c\u5982\u4e0b\uff1a buffer \u548c\u7ba1\u7406\u5b57\u6bb5\uff1a /* xfer task deque node. */ typedef struct { ...... } xfer_task_node_t; /* xfer task deque support. */ static xfer_task_node_t xfer_task_deque[TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE] ={0u}; /* xfer task deque buf. */ static uint32_t xfer_task_head = 0u; /* record deque head. */ static uint32_t xfer_task_tail = 0u; /* record deque tail. */ static uint32_t xfer_task_cnt = 0u; /* record xfer task num. */ \u64cd\u4f5c\u51fd\u6570\uff1a \u4ece\u5934\u90e8 pop\uff0c\u4ece\u5c3e\u90e8 push\uff1a /* get deque head node & delete the node in deque. */ bool xfer_task_pop_head(xfer_task_node_t * task) { if (0u == xfer_task_cnt) { return false; /* no xfer_task. */ } /* pop head: read head, head--, cnt--. */ memcpy(task, &xfer_task_deque[xfer_task_head], sizeof(xfer_task_node_t)); /* read head. */ if (xfer_task_head == 0u) /* head--. */ { xfer_task_head = TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE - 1u; } else { xfer_task_head--; } xfer_task_cnt--; /* cnt--. */ return true; } /* put node in deque tail. */ bool xfer_task_push_tail(xfer_task_node_t * task) { if (TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE == xfer_task_cnt) { return false; /* queue full. */ } /* push tail: write tail, tail--, cnt++ */ memcpy(&xfer_task_deque[xfer_task_tail], task, sizeof(xfer_task_node_t)); /* write tail. */ if (xfer_task_tail == 0u) /* head++. */ { xfer_task_tail = TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE - 1u; } else { xfer_task_tail--; } xfer_task_cnt++;/* cnt++. */ return true; } \u6709\u4e86\u4e0a\u9762\u7684\u4e24\u4e2a\u65b9\u6cd5\uff0c\u8fd9\u5c31\u662f\u4e00\u4e2a\u666e\u901a\u7684\u5355\u9879\u961f\u5217\uff0c\u82f1\u6587\u53eb\u505a queue\uff0c\u65e2\u7136\u662f\u53cc\u5411\u961f\u5217\uff0c\u5c31\u9700\u8981\u5728\u8fd9\u4e2a\u57fa\u7840\u4e0a\u5b9e\u73b0\u4ece\u5934\u90e8 push \u7684\u529f\u80fd\uff0c\u81f3\u4e8e\u5c3e\u90e8 pop \u7531\u4e8e\u5728\u9002\u914d\u8fc7\u7a0b\u4e2d\u6ca1\u6709\u4f7f\u7528\uff0c\u4e0d\u518d\u5b9e\u73b0\uff0c\u4e0b\u8ff0\u4e3a\u76f8\u5173\u4ee3\u7801\u5b9e\u73b0\uff1a /* put node in deque head. */ bool xfer_task_push_head(xfer_task_node_t * task) { if (TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE == xfer_task_cnt) { return false; /* queue full. */ } /* push head: head++, write head, cnt++ */ if (xfer_task_head == TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE - 1u) /* head++. */ { xfer_task_head = 0u; } else { xfer_task_head++; } memcpy(&xfer_task_deque[xfer_task_head], task, sizeof(xfer_task_node_t)); /* write tail. */ xfer_task_cnt++;/* cnt++. */ return true; } \u9700\u8981\u6e05\u7a7a\u53cc\u5411\u961f\u5217\u7684\u5185\u5bb9\u65f6\uff0c\u6216\u521d\u59cb\u5316\u53cc\u5411\u961f\u5217\u65f6\uff0c\u53ef\u4f7f\u7528\u4e0b\u5217\u65b9\u6cd5\u64cd\u4f5c: /* reset the deque, delete all node. */ void xfer_task_reset(void) { xfer_task_head = 0u; xfer_task_tail = 0u; xfer_task_cnt = 0u; }","title":"\u53cc\u5411\u961f\u5217\u5b9e\u73b0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#_5","text":"\u6240\u8c13\u6570\u636e\u5e93\uff0c\u53ea\u662f\u7528\u4e8e\u5b58\u653e\u5404\u8bbe\u5907\u5404\u7aef\u70b9\u4fe1\u606f\u7684\u5730\u65b9\u3002\u6bcf\u6b21\u53d1\u9001\u4f20\u8f93\u6570\u636e\u7684\u65f6\u5019\uff0c\u9700\u8981\u77e5\u9053\u7aef\u70b9\u7684buffer \u5927\u5c0f\u7b49\u4fe1\u606f\uff0c\u6240\u4ee5\u9700\u8981\u5728\u6570\u636e\u5e93\u4e2d\u67e5\u8be2\u7aef\u70b9\u4fe1\u606f\u3002\u9700\u8981\u652f\u6301inset\u64cd\u4f5c\uff0cdelete\u64cd\u4f5c\uff0cupdate \u64cd\u4f5c\u548cselect\u64cd\u4f5c\uff0c\u5373\u589e\u5220\u6539\u67e5\uff1a insert \u64cd\u4f5c\uff0c\u6307\u5c06\u4e00\u6761\u6570\u636e\u6761\u76ee\u63d2\u5165\u5230\u6570\u636e\u8868\u4e2d\uff0c\u8be5\u6761\u76ee\u662f\u6570\u636e\u8868\u4e2d\u539f\u6765\u6ca1\u6709\u7684\u5185\u5bb9 delete \u64cd\u4f5c\uff0c\u6307\u5220\u9664\u6570\u636e\u6761\u76ee\u6216\u6570\u636e\u8868 update \u64cd\u4f5c\uff0c\u6307\u5c06\u4e00\u6761\u6570\u636e\u6761\u76ee\u66f4\u65b0\u5230\u539f\u6709\u7684\u6761\u76ee\u4e2d\uff0c\u4e3b\u8981\u66f4\u65b0\u539f\u6709\u6761\u76ee\u7684\u5b57\u6bb5\u5185\u5bb9 select \u64cd\u4f5c\uff0c\u6839\u636e\u5173\u952e\u5b57\u67e5\u627e\u6570\u636e\u8868\u4e2d\u7684\u6761\u76ee buffer \u548c\u7ba1\u7406\u5b57\u6bb5\uff1a /* endpoint status table. */ static ep_status_t ep_tbl[TUH_HCD_PORT_MAX_EP_NUM]; /* the table that record the ep_status. */ static uint32_t ep_count = 0u; /* record the how many endpoint status in ep_tbl[]. */ insert & update \u64cd\u4f5c\uff1a /* add new or modify endpoint status. */ bool ep_set_status(ep_status_t * status) { ep_status_t * ep_status = ep_get_status(status->dev_ep_addr); if (NULL == ep_status) { if (ep_count == TUH_HCD_PORT_MAX_EP_NUM) { return false; } ep_status = &ep_tbl[ep_count]; ep_count++; } memcpy(ep_status, status, sizeof(ep_status_t)); return true; } select \u64cd\u4f5c\uff1a /* get endpoint status. */ ep_status_t * ep_get_status(uint32_t dev_ep_addr) { ep_status_t * ep_status = NULL; for(uint32_t i = 0u; i < ep_count; i++) { if(dev_ep_addr == ep_tbl[i].dev_ep_addr) { ep_status = &ep_tbl[i]; break; } } return ep_status; } \u9664\u4e86\u4e0a\u9762\u7684\u64cd\u4f5c\uff0c\u5f53 USB Device \u62d4\u6389\u7684\u65f6\u5019\uff0c\u6570\u636e\u5e93\u9700\u8981\u8fdb\u884c\u590d\u4f4d\uff0c\u76f8\u5f53\u4e8e\u6267\u884c delete \u64cd\u4f5c\uff1a /* clear all endpoint status. */ void ep_reset(void) { ep_count = 0u; }","title":"\u6570\u636e\u5e93\u5b9e\u73b0"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#usb_2","text":"\u5728 tuh_dcd_port.c \u6587\u4ef6\u4e2d\u5b9a\u4e49USB \u6570\u636e\u7f13\u51b2\u533a\uff08\u5728USB\u9a71\u52a8\u4e2d\u5b9a\u4e49USB_BufDespTable_Type\u7ed3\u6784\u4f53\u7c7b\u578b\uff09\uff0c\u5728USB\u9a71\u52a8\u521d\u59cb\u5316\u548cUSB\u534f\u8bae\u6808\u4efb\u52a1\u5904\u7406\u65f6\u4f7f\u7528\u3002 USB\u7684\u914d\u7f6e\u7531\u4e24\u90e8\u5206\u7ec4\u6210\uff1a\u4e00\u90e8\u5206\u662f\u5b9e\u5b9e\u5728\u5728\u7684 USB \u5bc4\u5b58\u5668\u914d\u7f6e\uff0c\u4e00\u90e8\u5206\u662f SRAM \u4ee5 512 \u5b57\u8282\u5bf9\u9f50\u7684 512 \u5b57\u8282\u5927\u5c0f\u7684\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u3002 \u90a3\u4e48\u5982\u4f55\u5f97\u5230\u4e00\u5757 512 Bytes \u5bf9\u9f50\u7684\u5185\u5b58\uff1f\u8fd9\u91cc\u4e3e\u51fa\u4e09\u79cd\u65b9\u6cd5\uff1a \u5728 linker \u4e2d\u58f0\u660e\u51fa\u4e00\u6bb5 512 \u5b57\u8282\u5bf9\u9f50\u7684 512 \u5b57\u8282\u5927\u5c0f\u7684\u7a7a\u95f4\u3002 \u4f7f\u7528 \"__ALIGNED(512)\" \u6216 \"__attribute__((__aligned__(512)))\" \u7b49\u6307\u4ee4\u8ba9\u7f16\u8bd1\u5668\u5904\u7406\u3002 \u58f0\u660e\u4e00\u6bb5 1K \u5927\u5c0f\u7684\u7a7a\u95f4\uff0c\u7136\u540e\u5728\u5176\u4e2d\u627e\u5230 512 \u5b57\u8282\u5bf9\u9f50\u7684\u4f4d\u7f6e\u3002 \u8fd9\u91cc\u6211\u4eec\u91c7\u7528\u4e86\u7b2c2\u79cd\u65b9\u6cd5\u8fdb\u884c\u4e86\u5b9e\u73b0\uff1a /* usb buf descriptor table. */ __attribute__ ((aligned(512))) static USB_BufDespTable_Type usb_bdt = {0u}; /* speed status. */ volatile static tusb_speed_t device_speed = TUSB_SPEED_FULL; /* xfer_buf. */ __attribute__ ((aligned(4))) static uint8_t usb_xfer_buf[TUH_HCD_PORT_XFER_BUF_SIZE] = {0u}; \u5728\u521d\u59cb\u5316 USB \u7684\u65f6\u5019\uff0c\u9700\u8981\u5c06\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u7684\u8d77\u59cb\u5730\u5740\u5199\u5165\u5230 USB \u5bc4\u5b58\u5668\u4e2d\uff08USB_FS_BDTPAGE1\uff0cUSB_FS_BDTPAGE2\uff0cUSB_FS_BDTPAGE3\uff09\uff0c\u968f\u540e\uff0c\u8fd9\u5757\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u5c31 \u201c\u6210\u4e3a\u201d \u4e86 USB \u5bc4\u5b58\u5668\u4e2d\u7684\u4e00\u90e8\u5206\uff0c\u5f53\u6211\u4eec\u60f3\u8981\u4f20\u8f93\u6570\u636e\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u628a\u8981\u4f20\u8f93\u6570\u636e\u7684\u7f13\u51b2\u533a\u5730\u5740\uff0c\u7f13\u51b2\u533a\u5927\u5c0f\u7b49\u4fe1\u606f\u5199\u5165\u5230\u8fd9\u4e2a\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u4e2d\uff0c\u5f85\u4f20\u8f93\u6570\u636e\u5b8c\u6210\u540e\uff0c\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u4e2d\u8bb0\u5f55\u7684\u5185\u5bb9\u4e5f\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u5bf9\u8fd9\u5757\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u7684\u64cd\u4f5c\uff0c\u5c31\u5982\u540c\u5728 USB \u5bc4\u5b58\u5668\u4e0a\u8fdb\u884c\u64cd\u4f5c\u4e00\u822c\u3002 USB \u6570\u636e\u7684\u4f20\u8f93\u5b9e\u9645\u4e0a\u662f\u4f9d\u9760 DMA \u642c\u8fd0\u5b9e\u73b0\u7684\uff0c\u4f46\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0cUSB \u4f7f\u7528\u7684 DMA \u5e76\u4e0d\u662f MCU \u4e2d\u7684 DMA \u5916\u8bbe\uff0c\u800c\u662f USB \u81ea\u5e26\u7684 DMA\uff0c\u5e76\u4e14\u9664\u4e86\u4f7f\u7528 USB \u81ea\u5e26\u7684 DMA \u642c\u8fd0\u7684\u65b9\u5f0f\u4f20\u8f93\u6570\u636e\u5916\uff0cUSB \u5e76\u6ca1\u6709\u63d0\u4f9b\u5176\u4ed6\u4f20\u8f93\u6570\u636e\u7684\u65b9\u6cd5\u3002\u7531\u4e8e\u91c7\u7528 DMA \u642c\u8fd0\u7684\u65b9\u6cd5\u4f20\u8f93\u6570\u636e\uff0c\u5728\u4f7f\u7528 USB \u529f\u80fd\u7684\u65f6\u5019\uff0c\u9700\u8981\u6ce8\u610f\u4e00\u4e9b\u4f1a\u5f71\u54cd DMA \u5de5\u4f5c\u7684\u5730\u65b9\uff1a\u4f8b\u5982\uff0c\u6253\u5f00 DCACHE \u540e\uff0c\u5bf9 SRAM \u7684\u8bbf\u95ee\u5e76\u975e\u76f4\u63a5\u5199\u5165\u5230 SRAM \u4e2d\uff0c\u800c\u662f\u5148\u6682\u65f6\u653e\u5165\u5230\u5185\u6838\u7684 CACHE \u4e2d\uff0c\u4f1a\u9020\u6210 DMA \u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c\uff0c\u6240\u4ee5\uff0c\u5728\u4f7f\u7528 USB \u529f\u80fd\u7684\u65f6\u5019\uff0c\u5e94\u5173\u95ed DCACHE \u529f\u80fd\uff08\u6216\u8005\u4f7f\u7528 MPU \u5bf9 USB \u4f7f\u7528\u5230\u7684\u5185\u5b58\u52a0\u4ee5\u4fdd\u62a4\uff09\uff1b\u518d\u4f8b\u5982\uff0c\u6709\u4e9b RAM \u4ec5\u80fd\u88ab CPU \u8bbf\u95ee\uff0c\u5982 DTCM\uff0c\u8fd9\u90e8\u5206\u7a7a\u95f4\u65e0\u6cd5\u8ba9 DMA \u6b63\u5e38\u5de5\u4f5c\uff0c\u56e0\u6b64\u4e5f\u8981\u907f\u514d\u5c06\u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u548c\u8981\u4f20\u8f93\u7684\u6570\u636e\u5b58\u653e\u5728\u6b64\u7c7b\u533a\u57df\u3002 \u7f13\u51b2\u533a\u63cf\u8ff0\u8868\u63a7\u5236\u7740\u5341\u516d\u4e2a\u7aef\u70b9\u7684\u4f20\u8f93\u529f\u80fd\uff0c\u6bcf\u4e2a\u7aef\u70b9\u6709\u4e24\u4e2a\u4f20\u8f93\u65b9\u5411\uff0c\u5206\u522b\u662f IN \u548c OUT\uff08\u5982\u679c\u6bcf\u4e2a\u4f20\u8f93\u65b9\u5411\u7b97\u4e00\u4e2a\u7aef\u70b9\u7684\u8bdd\uff0cUSB_0 \u4e00\u5171\u6709 32 \u4e2a\u7aef\u70b9\uff09\u6bcf\u4e2a\u4f20\u8f93\u65b9\u5411\u6709\u4e24\u4e2a\u7f13\u51b2\u533a\u63cf\u8ff0\u7b26\u7ec4\u6210\uff0c\u5728\u4f20\u8f93\u6570\u636e\u7684\u65f6\u5019\uff0c\u4e24\u4e2a\u7f13\u51b2\u533a\u63cf\u8ff0\u7b26\u4ea4\u66ff\u5de5\u4f5c\uff0c\u4ece\u800c\u5b9e\u73b0\u4e52\u4e53\u64cd\u4f5c\u7684\u8fc7\u7a0b\uff0c\u52a0\u5feb\u6570\u636e\u4f20\u8f93\u7684\u901f\u5ea6\u3002\u5f53\u7136\uff0c\u53cc\u7f13\u51b2\u7684\u64cd\u4f5c\u8f83\u4e3a\u590d\u6742\uff0c\u589e\u52a0\u4e86 USB \u7684\u64cd\u4f5c\u96be\u5ea6\uff0c\u53cc\u7f13\u51b2\u4e5f\u53ef\u914d\u7f6e\u4e3a\u5355\u7f13\u51b2\uff0c\u7b80\u5316\u4f7f\u7528\u65b9\u6cd5\u3002 \u56fex \u7f13\u51b2\u533a\u63cf\u8ff0\u7b26 \u5982\u56fex\u6240\u793a\uff0c\u6bcf\u4e2a\u7f13\u51b2\u533a\u63cf\u8ff0\u7b26\u7531\u4e24\u4e2a\u56db\u5b57\u8282\u6570\u636e\u7ec4\u6210\uff0c\u7b2c\u4e00\u4e2a\u56db\u5b57\u8282\u6570\u636e\u8bb0\u5f55\u4e86\u8981\u4f20\u8f93\u6570\u636e\u7684\u5927\u5c0f\uff0cdata toggle\uff0c\u7f13\u51b2\u533a\u63cf\u8ff0\u7b26\u7684\u62e5\u6709\u8005\u7b49\u5b57\u6bb5\u4fe1\u606f\uff0c\u7b2c\u4e8c\u4e2a\u56db\u5b57\u8282\u6570\u636e\u5219\u8bb0\u5f55\u4e86\u8981\u4f20\u8f93\u6570\u636e\u7684\u8d77\u59cb\u4f4d\u7f6e\u3002\u5177\u4f53\u7684\u5b57\u6bb5\u4fe1\u606f\uff0c\u53ef\u53c2\u8003\u5404 MCU \u7684 UM\u3002","title":"USB \u7f13\u51b2\u63cf\u8ff0\u8868\u5b9a\u4e49"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#usb_3","text":"\u5728 tud_dcd_port.c \u6587\u4ef6\u4e2d\u5b9a\u4e49 USB_EndPointManage_Type \u7ed3\u6784\u4f53\u7c7b\u578b\u3002 typedef struct { uint8_t * xfer_buf; uint32_t max_packet_size; /* EndPoint max packet size. */ uint32_t length; /* EndPoint xfer data length. */ uint32_t remaining; /* EndPoint xfer data remaining. */ bool odd_even; /* EndPoint BD OddEven status. */ bool data_n; /* next packet is DATA0 or DATA1. */ bool xfer_done; } USB_EndPointManage_Type;","title":"USB \u7aef\u70b9\u7ba1\u7406"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#usb_4","text":"\u5728 tuh_dcd_port.c \u4e2d\u7684 dcd_init() \u51fd\u6570\u5b9e\u73b0\u3002 /* Initialize controller to host mode. */ bool hcd_init(uint8_t rhport) { (void)rhport; /* init usb host module. */ USB_Host_Init_Type usb_init; usb_init.BufDespTable_Addr = (uint32_t)(&usb_bdt); usb_init.SofThreshold = BOARD_USB_SOFTHRESHOLD; usb_init.NakRetry = false; USB_InitHost(BOARD_USB_PORT, &usb_init); USB_EnableOddEvenReset(BOARD_USB_PORT, true); /* only use even buf desp, this example will not usb odd buf desp xfer data. */ USB_SetDeviceAddr(BOARD_USB_PORT, 0x00); /* set usb addr is 0x00, to xfer data when device attached. */ /* enable interrupt, but not use NVIC_EnableIRQ(). */ NVIC_ClearPendingIRQ(BOARD_USB_IRQn); USB_EnableInterrupts(BOARD_USB_PORT, USB_INT_ATTACH | USB_INT_ERROR, true); USB_EnableErrInterrupts(BOARD_USB_PORT, 0xFF, true); return true; }","title":"USB\u9a71\u52a8\u4f7f\u80fd"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#usb-host_1","text":"USB Host \u4e2d\u65ad\u7684\u4f7f\u80fd\u5728 tuh_dcd_port.c \u4e2d\u7684 hcd_init() \u51fd\u6570\u4e2d\u5df2\u7ecf\u5b9e\u73b0\u3002\u76f8\u8f83\u4e8e USB Device \u4e2d\u65ad\u7684\u4f7f\u80fd\uff0cUSB Host \u4e2d\u65ad\u53ea\u5f00\u542f\u4e86 USB_INT_ATTACH \u4e2d\u65ad\u548c USB_INT_ERROR \u4e2d\u65ad\u3002\u5728 tud_dcd_port.c \u4e2d\u7684 BOARD_USB_IRQHandler() \u51fd\u6570\u5b9e\u73b0 USB Host \u8bbe\u5907\u7684\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u3002 /* * USB interrupt handler. */ void BOARD_USB_IRQHandler(void) { uint32_t flag = USB_GetInterruptStatus(BOARD_USB_PORT); flag &= USB_GetEnabledInterrupts(BOARD_USB_PORT); /* device attached. */ if (0u != (flag & USB_INT_ATTACH)) { process_attach(); } /* sof token, prepare to xfer packet. */ if (0u != (flag & USB_INT_SOFTOK)) { process_softok(); } /* xfer a token done. */ if (0u != (flag & USB_INT_TOKENDONE)) { process_token_done(); } /* device detached. */ if (0u != (flag & USB_INT_RESET)) { tuh_task(); /* clear all event. */ process_detach(); /* do detache process. */ } if (0u != (flag & USB_INT_ERROR)) { tuh_task(); /* clear all event. */ process_detach(); /* do detache process. */ uint32_t err = USB_GetErrInterruptStatus(BOARD_USB_PORT); USB_ClearErrInterruptStatus(BOARD_USB_PORT, err); /* clear err interrut. */ } USB_ClearInterruptStatus(BOARD_USB_PORT, flag); }","title":"USB Host\u4e2d\u65ad"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#_6","text":"\u5728\u76ee\u6807\u5de5\u7a0b\u7684 examples \u6587\u4ef6\u5939\u4e0b\u65b0\u5efa tud_cdc_msc \u6587\u4ef6\u5939\uff0c\u5c06 cdc_msc\\src \u6587\u4ef6\u5939\u4e2d\u7684\u6837\u4f8b\u6e90\u7801 main.c \u3001 msc_disk.c \u3001 tusb_config.h \u548c usb_descriptors.c \u62f7\u8d1d\u5230\u76ee\u6807\u5de5\u7a0b\u4e2d\u7684 examples\\tud_cdc_msc \u6587\u4ef6\u5939\u4e2d\uff0c\u5982\u56fex\u6240\u793a\uff1b\u5728\u8be5\u6587\u4ef6\u5939\u4e0b\u6839\u636e\u5bf9\u5e94\u5de5\u5177\u94fe\u65b0\u5efa\u6587\u4ef6\u5939\u548c\u521b\u5efa\u5bf9\u5e94\u7684\u7f16\u8bd1\u914d\u7f6e\u5de5\u7a0b\uff0c\u4e0b\u56fex\u5c55\u793a\u4e86\u4ee5Keil MDK \u5de5\u5177\u94fe\u4e3a\u4f8b\u7684\u5de5\u7a0b\u6a21\u677f\u3002 \u56fex \u6837\u4f8b\u6587\u4ef6\u7ed3\u6784 \u56fex Keil MDK \u5de5\u7a0b\u6837\u4f8b \u5bf9\u4e8e\u5de5\u7a0b\u4e2d\u7684\u5168\u5c40\u5b8f\u7684\u914d\u7f6e\u5982\u4e0b\u56fex\u6240\u793a\u3002\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e14\u6211\u4eec\u4f7f\u7528\u5230\u4e86\u677f\u8f7d\u7684 12.000MHz \u9ad8\u7cbe\u5ea6\u5916\u90e8\u9ad8\u901f\u6676\u632f\uff0c\u9700\u8981\u5728\u5de5\u7a0b\u914d\u7f6e\u4e2d\u5b9a\u4e49\u5168\u5c40\u5b8f CUSTOM_HSE_VAL \u3002 \u914d\u7f6e\u5de5\u7a0b\u5168\u5c40\u5b8f\u53c2\u6570","title":"\u521b\u5efa\u5de5\u7a0b\u6837\u4f8b"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#_7","text":"TinyUSB \u534f\u8bae\u6808\u81ea\u8eab\u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684 USB Device\u6837\u4f8b\u548c USB Host \u6837\u4f8b\uff0c\u6211\u4eec\u53ea\u9700\u8981\u901a\u8fc7\u4f7f\u7528\u914d\u7f6e\u597d\u7684 USB Device\u63a5\u53e3\u548c USB Host \u63a5\u53e3\uff0c\u548c TinyUSB \u534f\u8bae\u6808\u63d0\u4f9b\u534f\u8bae\u6808\u6e90\u6587\u4ef6\u548c\u6837\u4f8b\u4ee3\u7801\uff0c\u6309\u7167\u4e0d\u540c\u7684\u6837\u4f8b\u91cd\u65b0\u5efa\u7acb\u5bf9\u5e94\u7684\u5de5\u7a0b\u4fbf\u53ef\u5b9e\u73b0 TinyUSB \u63d0\u4f9b\u7684USB Device\u6837\u4f8b\u548c USB Host \u6837\u4f8b\u3002 LibTinyUSB \u4e2d\u5df2\u5b9e\u73b0\u591a\u4e2a tinyusb \u7684\u6837\u4f8b\uff0c\u6837\u4f8b\u5168\u90e8\u6765\u81ea tinyusb \u5b98\u65b9\u5b9e\u73b0\u7684\u4ee3\u7801\uff0c\u4f46 LibTinyUSB \u4e2d\u7684 examples \u4e3a\u4e86\u51cf\u5c0f size\uff0c\u5220\u9664\u4e86 examples \u6587\u4ef6\u5939\uff0c\u53ef\u5230 tinyusb \u5b98\u7f51\u62c9\u53d6\u6700\u65b0\u7684 git \u4ed3\u5e93\uff0c\u83b7\u53d6 examples\u3002 \u5c06 examples \u7684\u67d0\u4e00\u4e2a\u6837\u4f8b\u4e2d\u7684\u6e90\u4ee3\u7801\u590d\u5236\uff0c\u66ff\u6362 LibTinyUSB \u6837\u4f8b\u4e2d\u7684 app \u4ee3\u7801\uff0c\u5373\u53ef\u5b9e\u73b0\u65b0\u7684 app \u4ee3\u7801\u3002 \u8fd9\u91cc\u6211\u4eec\u4ecd\u7136\u4ee5\u57fa\u4e8e Mini-F5277-OB \u5f00\u53d1\u677f\u7684 tud_cdc_msc \u6837\u4f8b\u7684 Keil MDK\u5de5\u7a0b\u4e3a\u4f8b\uff0c\u9a8c\u8bc1\u5176\u5b9e\u73b0\u6548\u679c\uff1a \u5728\u5b8c\u6210\u524d\u8ff0\u4ee3\u7801\u79fb\u690d\u548c\u5de5\u7a0b\u914d\u7f6e\u4e4b\u540e\uff0c\u8fdb\u884c\u7f16\u8bd1\u4e0b\u8f7d\uff0c\u8fd9\u91cc\u4e0b\u8f7d\u5668\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 Mini-F5277-OB \u5f00\u53d1\u677f\u677f\u8f7d\u7684 CMSIS-DAP \u4e0b\u8f7d\u5668\uff0c\u7136\u540e\u76f4\u63a5\u8fdb\u884c\u4e0b\u8f7d\u3002 \u56fa\u4ef6\u4e0b\u8f7d\u5b8c\u6210\u540e\u901a\u8fc7 USB \u6570\u636e\u7ebf\u5c06 PC \u7aef\u548c\u5f00\u53d1\u677f\u7684 USB-MCU \u63a5\u53e3\u8fdb\u884c\u8fde\u63a5\uff08\u8fd9\u91cc\u6211\u4eecPC\u7aef\u7528\u5230\u7684\u64cd\u4f5c\u7cfb\u7edf\u662f Win10\uff09\uff0c\u8fde\u63a5\u597d\u540e\u6309\u4e0b\u5f00\u53d1\u677f\u7684\u590d\u4f4d\u6309\u952e\uff0cPC\u7aef\u5c06\u4f1a\u81ea\u52a8\u5f39\u51fa USB Device \u5728PC \u7aef\u679a\u4e3e\u7684\u4e00\u4e2a\u63cf\u8ff0\u7b26\u4e3a TinyUSB MSC \u7684\u53ef\u79fb\u52a8\u78c1\u76d8\u8bbe\u5907\uff0c\u5982\u4e0b\u56fex\u6240\u793a\uff1a \u56fex \u81f3\u6b64\uff0c\u4ee3\u8868\u6837\u4f8b\u5de5\u7a0b tud_cdc_msc \u6210\u529f\u8fd0\u884c\uff0c\u5e76\u5728 PC \u7aef\u5b8c\u6210\u4e86USB Device\u679a\u4e3e\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u5907\u529f\u80fd\u3002","title":"\u6837\u4f8b\u6f14\u793a"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tinyusb_2","text":"","title":"TinyUSB\u534f\u8bae\u6808\u6837\u4f8b\u4ecb\u7ecd"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#board_test","text":"\u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684\u57fa\u672c\u677f\u8f7d\u6837\u4f8b\uff0c\u7528\u4e8e\u6d4b\u8bd5\u9a8c\u8bc1MCU\u548c\u5f00\u53d1\u677f\u80fd\u5426\u6b63\u5e38\u8fd0\u884c\uff0c\u82e5\u8fd0\u884c\u6b63\u5e38\u5219\u677f\u8f7dLED\u4f1a\u8fdb\u884c\u95ea\u70c1\uff0c\u5e76\u5728\u4e32\u53e3\u8f93\u51fa\u6307\u5b9a\u5b57\u7b26\u4e32\u3002","title":"board_test"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tud_cdc_dual_ports","text":"\u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device\u53cc\u4e32\u53e3\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u53cc\u4e32\u53e3\u529f\u80fd\u3002","title":"tud_cdc_dual_ports"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tud_cdc_msc","text":"\u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u5907\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u5907\u529f\u80fd\u3002","title":"tud_cdc_msc"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tud_hid_composite","text":"\u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device HID\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u9f20\u6807\u952e\u76d8\u8bbe\u5907\u529f\u80fd\u3002","title":"tud_hid_composite"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tud_msc_dual_lun","text":"\u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u5907\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u4e24\u4e2a\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u5907\u529f\u80fd\u3002","title":"tud_msc_dual_lun"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tud_video_capture","text":"\u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device\u6444\u50cf\u5934\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u4e00\u4e2a\u6444\u50cf\u5934\u8bbe\u5907\u529f\u80fd\u3002","title":"tud_video_capture"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tud_webusb_serial","text":"\u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Device\u7684Vender\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Device\u679a\u4e3e\u7f51\u9875USB\u4e32\u53e3\u8bbe\u5907\u529f\u80fd\u3002","title":"tud_webusb_serial"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tuh_bare_api","text":"\u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Host\u7684\u57fa\u672cAPI\u4f7f\u7528\u6f14\u793a\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Host\u8bfb\u53d6FATFS \u683c\u5f0f\u7684\u5b58\u50a8\u8bbe\u5907\uff08\u5982\uff1aU\u76d8\uff09\u529f\u80fd\u3002","title":"tuh_bare_api"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tuh_cdc_msc_hid","text":"\u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Host\u8bfb\u53d6\u5927\u5bb9\u91cf\u5b58\u50a8\u8bbe\u6f14\u793a\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Host\u8bfb\u53d6FATFS \u683c\u5f0f\u7684\u5b58\u50a8\u8bbe\u5907\uff08\u5982\uff1aU\u76d8\uff09\u529f\u80fd\u3002","title":"tuh_cdc_msc_hid"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#tuh_hid_controller","text":"\u8be5\u6837\u4f8b\u4e3aTinyUSB\u63d0\u4f9b\u7684USB Host\u63a7\u5236\u5668\u6837\u4f8b\uff0c\u7528\u4e8e\u6f14\u793aUSB Host\u8bfb\u53d6\u6e38\u620f\u624b\u67c4\u4fe1\u606f\uff08\u8fd9\u91cc\u6307\u5b9a\u4e86\u7d22\u5c3cPS4\u6e38\u620f\u624b\u67c4\uff09\u529f\u80fd\u3002","title":"tuh_hid_controller"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#_8","text":"USB \u4f7f\u7528 12.000MHz \u9ad8\u7cbe\u5ea6\u6676\u632f\uff0c\u9700\u5728\u5de5\u7a0b\u4e2d\u5f00\u542f\u5168\u5c40\u5b8f\u5b9a\u4e49 CUSTOM_HSE_VAL \u6765\u5f00\u542f\u3002 \u542f\u7528 USB Host \u65f6\uff0c\u9700\u8981\u901a\u8fc7\u7535\u6e90\u5f00\u5173\u82af\u7247\uff08\u5982\uff1aSY6280AAC\uff09\u6765\u63a7\u5236\u5bf9USB Device \u7684\u4f9b\u7535\uff0c\u56e0 Mini-F5277-OB \u5f00\u53d1\u677f\u672a\u63d0\u4f9b USB A \u63a5\u53e3\u548c\u7535\u6e90\u5f00\u5173\u82af\u7247\uff0c\u8fd9\u91cc\u53ef\u4ee5\u5c06 D+(PA11)\u3001D-(PA12) \u548c EN(PC13)\u5f15\u811a\u5916\u63a5\u81f3\u5916\u90e8\u7684 USB A \u5916\u56f4\u7535\u8def\u4e2d\u8fdb\u884c\u6d4b\u8bd5\u9a8c\u8bc1\uff0c\u5e76\u9700\u8981\u5c06Mini-F5277-OB \u5f00\u53d1\u677f\u7684SP6\u548cSP4\u8fdb\u884c\u901a\u8fc7\u710a\u9521\u8fdb\u884c\u586b\u5145\u3002","title":"\u6ce8\u610f\u4e8b\u9879"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#usb_5","text":"SIE SIE \u5728 USB \u9a71\u52a8\u4e2d\u662f\u6307 Serial Interface Engine\uff0c\u5373\u4e32\u884c\u63a5\u53e3\u5f15\u64ce\u3002\u5b83\u662f USB \u5916\u8bbe\u4e2d\u6700\u5173\u952e\u7684\u786c\u4ef6\u7ec4\u6210\u90e8\u5206\u4e4b\u4e00\u3002SIE \u8d1f\u8d23\u5904\u7406\u4e0e USB \u901a\u4fe1\u534f\u8bae\u76f8\u5173\u7684\u6240\u6709\u5e95\u5c42\u64cd\u4f5c\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u4ee5\u4e0b\u529f\u80fd\uff1a \u901f\u5ea6\u8bc6\u522b\uff1a\u8bc6\u522b\u8bbe\u5907\u7684\u4f20\u8f93\u901f\u5ea6\uff08\u4f4e\u901f\u3001\u5168\u901f\u3001\u9ad8\u901f\uff09\u3002 \u5305\u89e3\u6790\u548c\u6784\u9020\uff1a\u89e3\u6790\u63a5\u6536\u5230\u7684 USB \u6570\u636e\u5305\uff0c\u5e76\u6784\u9020\u8981\u53d1\u9001\u7684\u6570\u636e\u5305\u3002 NRZI \u7f16/\u8bd1\u7801\u548c\u586b\u5145\u4f4d\u64cd\u4f5c\uff1aNRZI \uff08Non-Return-to-Zero Inverted\uff09\u662f\u4e00\u79cd\u4fe1\u53f7\u7f16\u7801\u65b9\u5f0f\uff0cSIE \u80fd\u591f\u8fdb\u884c NRZI \u7f16\u7801\u548c\u89e3\u7801\uff0c\u4ee5\u53ca\u6dfb\u52a0\u548c\u53bb\u9664\u6570\u636e\u5305\u4e2d\u7684\u586b\u5145\u4f4d\u4ee5\u4fdd\u6301\u65f6\u949f\u540c\u6b65\u3002 \u4e0e USB \u603b\u7ebf\u7684\u7535\u6c14\u63a5\u53e3\uff1a\u5305\u62ec UTMI\uff08Universal Transceiver Macrocell Interface\uff09\u6216\u5176\u4ed6\u7c7b\u4f3c\u7684\u7269\u7406\u5c42\u63a5\u53e3\uff0c\u7528\u4e8e\u5b9e\u73b0\u4e0e USB \u603b\u7ebf\u7684\u7535\u6c14\u8fde\u63a5\u548c\u4fe1\u53f7\u4f20\u8f93\u3002 OTA USB OTG\uff08On-The-Go\uff09\u7684\u53cc\u89d2\u8272\u529f\u80fd\u662f\u6307\u8bbe\u5907\u80fd\u591f\u540c\u65f6\u626e\u6f14\u4e3b\u673a\uff08Host\uff09\u548c\u5916\u8bbe\uff08Peripheral\uff09\u7684\u89d2\u8272\u3002\u5728\u4f20\u7edf\u7684USB\u7cfb\u7edf\u4e2d\uff0c\u901a\u5e38\u6709\u4e00\u4e2a\u8bbe\u5907\u4f5c\u4e3a\u4e3b\u673a\uff0c\u8d1f\u8d23\u63a7\u5236\u548c\u7ba1\u7406\u6570\u636e\u4f20\u8f93\uff0c\u800c\u5176\u4ed6\u8bbe\u5907\u5219\u662f\u5916\u8bbe\uff0c\u53ea\u80fd\u88ab\u52a8\u54cd\u5e94\u4e3b\u673a\u7684\u8bf7\u6c42\u3002 \u7136\u800c\uff0c\u5728USB OTG\u4e2d\uff0c\u53cc\u89d2\u8272\u8bbe\u5907\uff08Dual-Role Device\uff0cDRD\uff09\u7684\u8bbe\u8ba1\u5141\u8bb8\u4e00\u4e2a\u8bbe\u5907\u5728\u4e0d\u540c\u7684\u65f6\u95f4\u6216\u5728\u9700\u8981\u7684\u65f6\u5019\u5207\u6362\u5176\u89d2\u8272\u3002\u8fd9\u610f\u5473\u7740\u8fd9\u6837\u7684\u8bbe\u5907\u65e2\u53ef\u4ee5\u4f5c\u4e3a\u4e3b\u673a\u6765\u53d1\u8d77\u6570\u636e\u4f20\u8f93\uff0c\u4f8b\u5982\u4ece\u4e00\u4e2aUSB\u95ea\u5b58\u9a71\u52a8\u5668\u8bfb\u53d6\u6570\u636e\uff0c\u4e5f\u53ef\u4ee5\u4f5c\u4e3a\u5916\u8bbe\u4e0e\u5176\u4ed6\u8bbe\u5907\u8fde\u63a5\uff0c\u5982\u88ab\u53e6\u4e00\u53f0\u8bbe\u5907\uff08\u53ef\u80fd\u662f\u53e6\u4e00\u53f0OTG\u8bbe\u5907\u6216\u8005\u4f20\u7edf\u7684\u4e3b\u673a\uff09\u8bbf\u95ee\u6216\u5145\u7535\u3002 \u8fd9\u79cd\u7075\u6d3b\u6027\u4f7f\u5f97USB OTG\u53cc\u89d2\u8272\u8bbe\u5907\u5728\u79fb\u52a8\u8bbe\u5907\u548c\u4fbf\u643a\u5f0f\u8bbe\u5907\u4e2d\u7279\u522b\u6709\u7528\uff0c\u6bd4\u5982\u667a\u80fd\u624b\u673a\u548c\u5e73\u677f\u7535\u8111\uff0c\u8fd9\u4e9b\u8bbe\u5907\u53ef\u80fd\u9700\u8981\u4e0e\u5176\u4ed6\u8bbe\u5907\u4ea4\u6362\u6570\u636e\uff0c\u6216\u8005\u5728\u6ca1\u6709\u4f20\u7edf\u4e3b\u673a\uff08\u5982\u7535\u8111\uff09\u7684\u60c5\u51b5\u4e0b\u76f4\u63a5\u8fdb\u884c\u6570\u636e\u4f20\u8f93\u548c\u4f9b\u7535\u64cd\u4f5c\u3002\u901a\u8fc7USB OTG\u7684\u53cc\u89d2\u8272\u652f\u6301\uff0c\u8bbe\u5907\u4e4b\u95f4\u7684\u4ea4\u4e92\u53d8\u5f97\u66f4\u52a0\u4fbf\u6377\u548c\u591a\u6837\u5316\u3002 \u652f\u6301\u4e3b\u673a\u534f\u5546\u534f\u8bae\uff08HNP\uff09\u548c\u4f1a\u8bdd\u8bf7\u6c42\u534f\u8bae\uff08SRP\uff09\u662fUSB On-The-Go\uff08OTG\uff09\u89c4\u8303\u4e2d\u7684\u4e24\u4e2a\u5173\u952e\u7279\u6027\u3002 \u4e3b\u673a\u534f\u5546\u534f\u8bae\uff08HNP\uff09\uff1a HNP\u5141\u8bb8USB OTG\u8bbe\u5907\u5728\u64cd\u4f5c\u8fc7\u7a0b\u4e2d\u52a8\u6001\u5207\u6362\u5176\u89d2\u8272\uff0c\u5373\u4ece\u4e3b\u673a\u89d2\u8272\u5207\u6362\u5230\u5916\u8bbe\u89d2\u8272\uff0c\u6216\u8005\u4ece\u5916\u8bbe\u89d2\u8272\u5207\u6362\u5230\u4e3b\u673a\u89d2\u8272\u3002\u8fd9\u79cd\u5207\u6362\u662f\u5728\u8bbe\u5907\u4e4b\u95f4\u76f4\u63a5\u8fdb\u884c\u7684\uff0c\u65e0\u9700\u4eba\u5de5\u5e72\u9884\u3002\u4f8b\u5982\uff0c\u5f53\u4e00\u4e2aOTG\u8bbe\u5907\u6b63\u5728\u4f5c\u4e3a\u4e3b\u673a\u4e0e\u53e6\u4e00\u4e2a\u8bbe\u5907\u901a\u4fe1\uff0c\u4f46\u968f\u540e\u5e0c\u671b\u88ab\u8fde\u63a5\u5230\u4e00\u4e2a\u66f4\u5f3a\u5927\u7684\u4e3b\u673a\uff08\u5982\u7535\u8111\uff09\u65f6\uff0c\u5b83\u53ef\u4ee5\u4f7f\u7528HNP\u8bf7\u6c42\u5c06\u4e3b\u673a\u89d2\u8272\u8f6c\u79fb\u7ed9\u65b0\u8fde\u63a5\u7684\u8bbe\u5907\u3002 \u4f1a\u8bdd\u8bf7\u6c42\u534f\u8bae\uff08SRP\uff09\uff1a SRP\u662fUSB OTG\u4e2d\u7684\u53e6\u4e00\u4e2a\u91cd\u8981\u7279\u6027\uff0c\u5b83\u5141\u8bb8\u65e0\u4e3b\u7535\u6e90\uff08\u5373\u81ea\u8eab\u4e0d\u4f9b\u7535\u7684\u8bbe\u5907\uff0c\u901a\u5e38\u79f0\u4e3aA\u8bbe\u5907\uff09\u542f\u52a8\u4e0e\u6709\u4e3b\u7535\u6e90\u8bbe\u5907\uff08\u901a\u5e38\u79f0\u4e3aB\u8bbe\u5907\uff09\u7684\u901a\u4fe1\u4f1a\u8bdd\u3002\u5728\u4f20\u7edf\u7684USB\u7cfb\u7edf\u4e2d\uff0c\u6570\u636e\u4f20\u8f93\u603b\u662f\u7531\u4e3b\u673a\u53d1\u8d77\u3002\u4f46\u5728USB OTG\u4e2d\uff0c\u7531\u4e8e\u8bbe\u5907\u53ef\u4ee5\u52a8\u6001\u5207\u6362\u89d2\u8272\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u79cd\u673a\u5236\u8ba9\u65e0\u4e3b\u7535\u6e90\u8bbe\u5907\u80fd\u591f\u542f\u52a8\u901a\u4fe1\u3002SRP\u5c31\u662f\u7528\u4e8e\u5b9e\u73b0\u8fd9\u4e00\u76ee\u6807\u7684\u534f\u8bae\uff0c\u5b83\u5141\u8bb8\u65e0\u4e3b\u7535\u6e90\u8bbe\u5907\u901a\u8fc7\u5411\u6709\u4e3b\u7535\u6e90\u8bbe\u5907\u53d1\u9001\u4e00\u4e2a\u4f1a\u8bdd\u8bf7\u6c42\u6765\u542f\u52a8\u6570\u636e\u4f20\u8f93\u3002 \u603b\u7684\u6765\u8bf4\uff0cHNP\u548cSRP\u90fd\u662f\u4e3a\u4e86\u589e\u5f3aUSB OTG\u8bbe\u5907\u7684\u7075\u6d3b\u6027\u548c\u4e92\u64cd\u4f5c\u6027\uff0c\u4f7f\u5f97\u8bbe\u5907\u80fd\u591f\u6839\u636e\u9700\u8981\u52a8\u6001\u8c03\u6574\u5176\u89d2\u8272\u548c\u884c\u4e3a\uff0c\u4ece\u800c\u5728\u5404\u79cd\u4e0d\u540c\u7684\u4f7f\u7528\u573a\u666f\u4e0b\u63d0\u4f9b\u66f4\u597d\u7684\u7528\u6237\u4f53\u9a8c\u3002 USB\u7684SE0\u4fe1\u53f7 \u5728USB\uff08Universal Serial Bus\uff09\u534f\u8bae\u4e2d\uff0cSE0\uff08Single-Ended Zero\uff09\u4fe1\u53f7\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u4fe1\u53f7\u72b6\u6001\uff0c\u5b83\u8868\u793a\u6570\u636e\u7ebfD+\u548cD-\u4e0a\u7684\u7535\u5e73\u90fd\u4e3a\u903b\u8f910\uff08\u4f4e\u7535\u5e73\uff09\u3002 SE0\u4fe1\u53f7\u5728USB\u901a\u4fe1\u4e2d\u626e\u6f14\u7740\u91cd\u8981\u7684\u89d2\u8272\uff0c\u4e3b\u8981\u7528\u4e8e\u9519\u8bef\u68c0\u6d4b\u3001\u8bbe\u5907\u521d\u59cb\u5316\u548c\u603b\u7ebf\u6062\u590d\u7b49\u64cd\u4f5c\u3002\u5b83\u662f\u786e\u4fddUSB\u603b\u7ebf\u7a33\u5b9a\u6027\u548c\u53ef\u9760\u6027\u7684\u5173\u952e\u90e8\u5206\u3002 USB\u7684JSTATE \u4fe1\u53f7 USB\u5dee\u5206\u63a5\u6536\u5668\u63a5\u6536\u5230JSTATE\u4fe1\u53f7\u65f6\uff0c\u5b83\u901a\u5e38\u662f\u4f5c\u4e3a\u8bbe\u5907\u679a\u4e3e\u548c\u901f\u5ea6\u68c0\u6d4b\u8fc7\u7a0b\u7684\u4e00\u90e8\u5206\uff0c\u5e2e\u52a9\u4e3b\u673a\u6b63\u786e\u8bc6\u522b\u548c\u914d\u7f6e\u8fde\u63a5\u7684USB\u8bbe\u5907\u3002 STALL \u4e2d\u65ad STALL\u4e2d\u65ad\u662fUSB\u534f\u8bae\u4e2d\u4e00\u79cd\u91cd\u8981\u7684\u9519\u8bef\u5904\u7406\u548c\u901a\u4fe1\u673a\u5236\uff0c\u5b83\u5141\u8bb8\u8bbe\u5907\u5411\u4e3b\u673a\u62a5\u544a\u65e0\u6cd5\u5904\u7406\u8bf7\u6c42\u7684\u60c5\u51b5\uff0c\u5e76\u4fc3\u4f7f\u4e3b\u673a\u91c7\u53d6\u76f8\u5e94\u7684\u63aa\u65bd\u6765\u89e3\u51b3\u95ee\u9898\u3002\u901a\u8fc7\u6b63\u786e\u5904\u7406STALL\u4e2d\u65ad\uff0c\u53ef\u4ee5\u63d0\u9ad8USB\u901a\u4fe1\u7684\u53ef\u9760\u6027\u548c\u7a33\u5b9a\u6027\u3002 RESUME\u4e2d\u65ad RESUME\u4e2d\u65ad\u662fUSB\u534f\u8bae\u4e2d\u4e00\u79cd\u91cd\u8981\u7684\u7535\u6e90\u7ba1\u7406\u673a\u5236\uff0c\u5b83\u5141\u8bb8\u8bbe\u5907\u5728\u6682\u505c\u540e\u91cd\u65b0\u542f\u52a8\u6570\u636e\u4f20\u8f93\uff0c\u5e76\u786e\u4fdd\u4e3b\u673a\u80fd\u591f\u6b63\u786e\u5730\u5904\u7406\u8bbe\u5907\u7684\u6062\u590d\u8bf7\u6c42\u3002\u901a\u8fc7\u6709\u6548\u7ba1\u7406RESUME\u4e2d\u65ad\uff0c\u53ef\u4ee5\u63d0\u9ad8USB\u8bbe\u5907\u7684\u80fd\u6548\u548c\u7528\u6237\u4f53\u9a8c\u3002","title":"USB\u672f\u8bed\u89e3\u6790"},{"location":"%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9F%BA%E4%BA%8EMini-F5277-OB%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/#_9","text":"USB 2.0 Specification\uff1ahttps://usb.org/document-library/usb-20-specification TinyUSB \u5b98\u7f51\uff1ahttps://docs.tinyusb.org/en/latest/ MM32F5270 UM\uff1ahttps://mindmotion.com.cn/download/products/UM_MM32F5270_MM32F5280_SC.pdf \u300a\u5708\u5708\u6559\u4f60\u73a9 USB\u300b\uff0c\u5218\u8363\uff0c\u5317\u4eac\u822a\u7a7a\u822a\u5929\u5927\u5b66\u51fa\u7248\u793e\uff0cISBN: 9787811246001","title":"\u53c2\u8003\u6587\u732e"}]}